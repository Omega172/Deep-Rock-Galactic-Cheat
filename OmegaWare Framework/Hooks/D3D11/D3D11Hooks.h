#pragma once
#include "pch.h"

// This was stolen from https://github.com/rdbo/ImGui-DirectX-11-Kiero-Hook and modified to work with my framework and to be more readable

// These comments were generated by GitHub Copilot
#if FRAMEWORK_RENDER_D3D11 // If the rendering API is D3D11 include the D3D11 headers and define the D3D11 hooks

#include <D3D11.h>
#include <DXGI.h>


// Include the necessary header files
#include "../../ImGUI/Styles.h"

// Define function pointers for Present and WndProc
typedef HRESULT(__stdcall* Present) (IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags);
typedef LRESULT(CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
typedef HRESULT(__stdcall* ResizeBuffers) (IDXGISwapChain* pSwapChain, UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT NewFormat, UINT SwapChainFlags);

// Declare external function for handling Win32 window messages
extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Declare variables for original Present and WndProc functions
Present oPresent;
WNDPROC oWndProc;
ResizeBuffers oResizeBuffers;

// Declare variables for window, device, context, and render target view
HWND window = NULL;
ID3D11Device* pDevice = NULL;
ID3D11DeviceContext* pContext = NULL;
ID3D11RenderTargetView* mainRenderTargetView;

// Declare a boolean variable to track initialization status
bool hkInit = false;

// Function to initialize ImGui
void InitImGui()
{
	// Create ImGui context
	ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO();
	io.ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;

	// Initialize ImGui for Win32 and DirectX 11
	ImGui_ImplWin32_Init(window);
	ImGui_ImplDX11_Init(pDevice, pContext);

	// Setup ImGui style and import fonts
	SetupStyle();
	ImportFonts();
}

// Custom window procedure to handle Win32 window messages
LRESULT __stdcall WndProc(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// Pass window messages to ImGui for handling
	ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);

	// If the menu is open, return true to prevent further processing of the message
	return (GUI::bMenuOpen ? true : CallWindowProcA(oWndProc, hWnd, uMsg, wParam, lParam));
}

static DXGI_FORMAT GetCorrectDXGIFormat(DXGI_FORMAT currentFormat) {
	switch (currentFormat) {
	case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
		return DXGI_FORMAT_R8G8B8A8_UNORM;
	}

	return currentFormat;
}

void CreateRenderTarget(IDXGISwapChain* pSwapChain) {
	ID3D11Texture2D* pBackBuffer = nullptr;
	pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
	if (pBackBuffer != NULL)
	{
		DXGI_SWAP_CHAIN_DESC sd;
		pSwapChain->GetDesc(&sd);

		D3D11_RENDER_TARGET_VIEW_DESC desc = {};
		desc.Format = GetCorrectDXGIFormat(sd.BufferDesc.Format);

		pDevice->CreateRenderTargetView(pBackBuffer, NULL, &mainRenderTargetView);
		desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DMS;
		if (FAILED(pDevice->CreateRenderTargetView(pBackBuffer, &desc, &mainRenderTargetView))) {
			desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
			if (FAILED(pDevice->CreateRenderTargetView(pBackBuffer, &desc, &mainRenderTargetView))) {
				if (FAILED(pDevice->CreateRenderTargetView(pBackBuffer, NULL, &mainRenderTargetView))) {
					Utils::LogError(Utils::GetLocation(CurrentLoc), "Failed to create render target view");
				}
			}
		}

		pBackBuffer->Release();
	}
}

// Hooked Present function
HRESULT __stdcall hkPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	// Check if initialization has been performed
	if (!hkInit)
	{
		// Get the device and context from the swap chain
		if (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&pDevice)))
		{
			pDevice->GetImmediateContext(&pContext);

			// Get the window handle and create the render target view
			DXGI_SWAP_CHAIN_DESC sd;
			pSwapChain->GetDesc(&sd);
			window = sd.OutputWindow;
			
			CreateRenderTarget(pSwapChain);

			// Hook the window procedure and initialize ImGui
			oWndProc = (WNDPROC)SetWindowLongPtrA(window, GWLP_WNDPROC, (LONG_PTR)WndProc);
			InitImGui();

			// Set initialization flag and call the original Present function
			hkInit = true;
			return oPresent(pSwapChain, SyncInterval, Flags);
		}
		else
			return oPresent(pSwapChain, SyncInterval, Flags);
	}

	if (!mainRenderTargetView)
		CreateRenderTarget(pSwapChain);

	// Begin rendering ImGui
	GUI::BeginRender();

	// Push a custom font and render the GUI
	ImGui::PushFont(tahomaFont);
	GUI::Render();
	ImGui::PopFont();

	// End rendering ImGui
	GUI::EndRender();

	// Set the render target and render ImGui draw data
	pContext->OMSetRenderTargets(1, &mainRenderTargetView, NULL);
	ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

	// Check if the cheat should stop running
	if (!Cheat::bShouldRun)
	{
		// Release resources and call the original Present function
		pDevice->Release();
		pContext->Release();
		pSwapChain->Release();
		oWndProc = (WNDPROC)SetWindowLongPtr(window, GWLP_WNDPROC, (LONG_PTR)(oWndProc));
		oPresent(pSwapChain, SyncInterval, Flags);
		kiero::shutdown();
		return 0;
	}

	// Call the original Present function
	return oPresent(pSwapChain, SyncInterval, Flags);
}

HRESULT __stdcall hkResizeBuffers(IDXGISwapChain* pSwapChain, UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT NewFormat, UINT SwapChainFlags)
{
	mainRenderTargetView->Release();

	return oResizeBuffers(pSwapChain, BufferCount, Width, Height, NewFormat, SwapChainFlags);;
}

#endif // FRAMEWORK_RENDER_D3D11