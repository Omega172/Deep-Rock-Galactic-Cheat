#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SimpleUGC

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "SimpleUGC_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace CG
{

// Class SimpleUGC.MakeReplaceableActorComponent
// 0x0008 (0x00B8 - 0x00B0)
class UMakeReplaceableActorComponent final : public UActorComponent
{
public:
	TSubclassOf<class AActor>                     CompatibleReplacement;                             // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MakeReplaceableActorComponent">();
	}
	static class UMakeReplaceableActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMakeReplaceableActorComponent>();
	}
};
static_assert(alignof(UMakeReplaceableActorComponent) == 0x000008, "Wrong alignment on UMakeReplaceableActorComponent");
static_assert(sizeof(UMakeReplaceableActorComponent) == 0x0000B8, "Wrong size on UMakeReplaceableActorComponent");
static_assert(offsetof(UMakeReplaceableActorComponent, CompatibleReplacement) == 0x0000B0, "Member 'UMakeReplaceableActorComponent::CompatibleReplacement' has a wrong offset!");

// Class SimpleUGC.ReplacementActorComponent
// 0x0010 (0x00C0 - 0x00B0)
class UReplacementActorComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class AActor>>             ActorClassesToReplace;                             // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplacementActorComponent">();
	}
	static class UReplacementActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplacementActorComponent>();
	}
};
static_assert(alignof(UReplacementActorComponent) == 0x000008, "Wrong alignment on UReplacementActorComponent");
static_assert(sizeof(UReplacementActorComponent) == 0x0000C0, "Wrong size on UReplacementActorComponent");
static_assert(offsetof(UReplacementActorComponent, ActorClassesToReplace) == 0x0000B0, "Member 'UReplacementActorComponent::ActorClassesToReplace' has a wrong offset!");

// Class SimpleUGC.UGCBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UUGCBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UUGCLatentActionManager* GetUGCLatentActionManager(class UObject* WorldContextObject);
	static class UUGCRegistry* GetUGCRegistry(class UObject* WorldContextObject);
	static class UUGCSettings* GetUGCSettings(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCBlueprintLibrary">();
	}
	static class UUGCBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCBlueprintLibrary>();
	}
};
static_assert(alignof(UUGCBlueprintLibrary) == 0x000008, "Wrong alignment on UUGCBlueprintLibrary");
static_assert(sizeof(UUGCBlueprintLibrary) == 0x000028, "Wrong size on UUGCBlueprintLibrary");

// Class SimpleUGC.ModioModInfoWrapper
// 0x0068 (0x0090 - 0x0028)
class UModioModInfoWrapper final : public UObject
{
public:
	class FString                                 ModId;                                             // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModName;                                           // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModURL;                                            // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModAuthor;                                         // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModVersion;                                        // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModDescription;                                    // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUGCApprovalStatus                            Status;                                            // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C7[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsModIdInvalid();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioModInfoWrapper">();
	}
	static class UModioModInfoWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioModInfoWrapper>();
	}
};
static_assert(alignof(UModioModInfoWrapper) == 0x000008, "Wrong alignment on UModioModInfoWrapper");
static_assert(sizeof(UModioModInfoWrapper) == 0x000090, "Wrong size on UModioModInfoWrapper");
static_assert(offsetof(UModioModInfoWrapper, ModId) == 0x000028, "Member 'UModioModInfoWrapper::ModId' has a wrong offset!");
static_assert(offsetof(UModioModInfoWrapper, ModName) == 0x000038, "Member 'UModioModInfoWrapper::ModName' has a wrong offset!");
static_assert(offsetof(UModioModInfoWrapper, ModURL) == 0x000048, "Member 'UModioModInfoWrapper::ModURL' has a wrong offset!");
static_assert(offsetof(UModioModInfoWrapper, ModAuthor) == 0x000058, "Member 'UModioModInfoWrapper::ModAuthor' has a wrong offset!");
static_assert(offsetof(UModioModInfoWrapper, ModVersion) == 0x000068, "Member 'UModioModInfoWrapper::ModVersion' has a wrong offset!");
static_assert(offsetof(UModioModInfoWrapper, ModDescription) == 0x000078, "Member 'UModioModInfoWrapper::ModDescription' has a wrong offset!");
static_assert(offsetof(UModioModInfoWrapper, Status) == 0x000088, "Member 'UModioModInfoWrapper::Status' has a wrong offset!");

// Class SimpleUGC.ModioTermsWrapper
// 0x0070 (0x0098 - 0x0028)
class UModioTermsWrapper final : public UObject
{
public:
	class FString                                 AgreeButtonText;                                   // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisagreeButtonText;                                // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TermsLink;                                         // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TermsText;                                         // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrivacyLink;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrivacyText;                                       // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TermsOfUseText;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsEmpty();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioTermsWrapper">();
	}
	static class UModioTermsWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioTermsWrapper>();
	}
};
static_assert(alignof(UModioTermsWrapper) == 0x000008, "Wrong alignment on UModioTermsWrapper");
static_assert(sizeof(UModioTermsWrapper) == 0x000098, "Wrong size on UModioTermsWrapper");
static_assert(offsetof(UModioTermsWrapper, AgreeButtonText) == 0x000028, "Member 'UModioTermsWrapper::AgreeButtonText' has a wrong offset!");
static_assert(offsetof(UModioTermsWrapper, DisagreeButtonText) == 0x000038, "Member 'UModioTermsWrapper::DisagreeButtonText' has a wrong offset!");
static_assert(offsetof(UModioTermsWrapper, TermsLink) == 0x000048, "Member 'UModioTermsWrapper::TermsLink' has a wrong offset!");
static_assert(offsetof(UModioTermsWrapper, TermsText) == 0x000058, "Member 'UModioTermsWrapper::TermsText' has a wrong offset!");
static_assert(offsetof(UModioTermsWrapper, PrivacyLink) == 0x000068, "Member 'UModioTermsWrapper::PrivacyLink' has a wrong offset!");
static_assert(offsetof(UModioTermsWrapper, PrivacyText) == 0x000078, "Member 'UModioTermsWrapper::PrivacyText' has a wrong offset!");
static_assert(offsetof(UModioTermsWrapper, TermsOfUseText) == 0x000088, "Member 'UModioTermsWrapper::TermsOfUseText' has a wrong offset!");

// Class SimpleUGC.UGCLatentActionManager
// 0x01F0 (0x0218 - 0x0028)
class UUGCLatentActionManager final : public UObject
{
public:
	uint8                                         Pad_14C8[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UModioTermsWrapper>      LatestModioTermsAndConditions;                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C9[0x50];                                    // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int64, class UModioModInfoWrapper*>      ModioModMetaDatas;                                 // 0x0088(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_14CA[0x50];                                    // 0x00D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int64, class UTexture2DDynamic*>         ModioModThumbnails;                                // 0x0128(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_14CB[0xA0];                                    // 0x0178(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UModioModInfoWrapper* GetCachedModioModMetaData(int64 ModId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCLatentActionManager">();
	}
	static class UUGCLatentActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCLatentActionManager>();
	}
};
static_assert(alignof(UUGCLatentActionManager) == 0x000008, "Wrong alignment on UUGCLatentActionManager");
static_assert(sizeof(UUGCLatentActionManager) == 0x000218, "Wrong size on UUGCLatentActionManager");
static_assert(offsetof(UUGCLatentActionManager, LatestModioTermsAndConditions) == 0x000030, "Member 'UUGCLatentActionManager::LatestModioTermsAndConditions' has a wrong offset!");
static_assert(offsetof(UUGCLatentActionManager, ModioModMetaDatas) == 0x000088, "Member 'UUGCLatentActionManager::ModioModMetaDatas' has a wrong offset!");
static_assert(offsetof(UUGCLatentActionManager, ModioModThumbnails) == 0x000128, "Member 'UUGCLatentActionManager::ModioModThumbnails' has a wrong offset!");

// Class SimpleUGC.UGCPackage
// 0x0100 (0x0128 - 0x0028)
class UUGCPackage final : public UObject
{
public:
	uint8                                         Pad_14CC[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_UGCPackage;                                   // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Version;                                           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModURL;                                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Categories;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUGCApprovalStatus                            Status;                                            // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUGCDownloadVersion                           DownloadVersion;                                   // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14CD[0x6];                                     // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ModPath;                                           // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PakFileLocation;                                   // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PakFileAssets;                                     // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14CE[0x20];                                    // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Author;                                            // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthorURL;                                         // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14CF[0x4];                                     // 0x00F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsMounted;                                         // 0x00FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MountingToBeApplied;                               // 0x00FD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DeprecatedLocation;                                // 0x00FE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D0[0x1];                                     // 0x00FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowStatusForAudioCosmetic;                        // 0x0100(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D1[0x7];                                     // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 Dependencies;                                      // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DependencyRemoved;                                 // 0x0118(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PackagedForLatestVersion;                          // 0x0119(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverridePackedForLatestVersion;                    // 0x011A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D2[0x5];                                     // 0x011B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastUpdated;                                       // 0x0120(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int64 GetIdAsInt();
	class FString GetIdAsString();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCPackage">();
	}
	static class UUGCPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCPackage>();
	}
};
static_assert(alignof(UUGCPackage) == 0x000008, "Wrong alignment on UUGCPackage");
static_assert(sizeof(UUGCPackage) == 0x000128, "Wrong size on UUGCPackage");
static_assert(offsetof(UUGCPackage, Name_UGCPackage) == 0x000030, "Member 'UUGCPackage::Name_UGCPackage' has a wrong offset!");
static_assert(offsetof(UUGCPackage, Version) == 0x000040, "Member 'UUGCPackage::Version' has a wrong offset!");
static_assert(offsetof(UUGCPackage, ModURL) == 0x000050, "Member 'UUGCPackage::ModURL' has a wrong offset!");
static_assert(offsetof(UUGCPackage, Categories) == 0x000060, "Member 'UUGCPackage::Categories' has a wrong offset!");
static_assert(offsetof(UUGCPackage, Status) == 0x000070, "Member 'UUGCPackage::Status' has a wrong offset!");
static_assert(offsetof(UUGCPackage, DownloadVersion) == 0x000071, "Member 'UUGCPackage::DownloadVersion' has a wrong offset!");
static_assert(offsetof(UUGCPackage, ModPath) == 0x000078, "Member 'UUGCPackage::ModPath' has a wrong offset!");
static_assert(offsetof(UUGCPackage, PakFileLocation) == 0x000088, "Member 'UUGCPackage::PakFileLocation' has a wrong offset!");
static_assert(offsetof(UUGCPackage, PakFileAssets) == 0x000098, "Member 'UUGCPackage::PakFileAssets' has a wrong offset!");
static_assert(offsetof(UUGCPackage, Author) == 0x0000C8, "Member 'UUGCPackage::Author' has a wrong offset!");
static_assert(offsetof(UUGCPackage, AuthorURL) == 0x0000D8, "Member 'UUGCPackage::AuthorURL' has a wrong offset!");
static_assert(offsetof(UUGCPackage, Description) == 0x0000E8, "Member 'UUGCPackage::Description' has a wrong offset!");
static_assert(offsetof(UUGCPackage, IsMounted) == 0x0000FC, "Member 'UUGCPackage::IsMounted' has a wrong offset!");
static_assert(offsetof(UUGCPackage, MountingToBeApplied) == 0x0000FD, "Member 'UUGCPackage::MountingToBeApplied' has a wrong offset!");
static_assert(offsetof(UUGCPackage, DeprecatedLocation) == 0x0000FE, "Member 'UUGCPackage::DeprecatedLocation' has a wrong offset!");
static_assert(offsetof(UUGCPackage, ShowStatusForAudioCosmetic) == 0x000100, "Member 'UUGCPackage::ShowStatusForAudioCosmetic' has a wrong offset!");
static_assert(offsetof(UUGCPackage, Dependencies) == 0x000108, "Member 'UUGCPackage::Dependencies' has a wrong offset!");
static_assert(offsetof(UUGCPackage, DependencyRemoved) == 0x000118, "Member 'UUGCPackage::DependencyRemoved' has a wrong offset!");
static_assert(offsetof(UUGCPackage, PackagedForLatestVersion) == 0x000119, "Member 'UUGCPackage::PackagedForLatestVersion' has a wrong offset!");
static_assert(offsetof(UUGCPackage, OverridePackedForLatestVersion) == 0x00011A, "Member 'UUGCPackage::OverridePackedForLatestVersion' has a wrong offset!");
static_assert(offsetof(UUGCPackage, LastUpdated) == 0x000120, "Member 'UUGCPackage::LastUpdated' has a wrong offset!");

// Class SimpleUGC.UGCRegistry
// 0x00D0 (0x00F8 - 0x0028)
class UUGCRegistry final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnPackageMounted;                                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UUGCPackage*>                    UGCPackages;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class AActor>, TSubclassOf<class AActor>> RegisteredOverrides;                               // 0x0048(0x0050)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          PackageChange;                                     // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D3[0x7];                                     // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBlueprintsSpawned;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D4[0x10];                                    // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUGCPackage*>                    UGCPackagesInstalledDuringJoin;                    // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UUGCPackage*>                    UGCPackagesUnmountedDuringJoin;                    // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D5[0x18];                                    // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreDeprecatedModsInstalled();
	bool AreModsInstalled(EUGCApprovalStatus ApprovalStatus);
	bool GetAllClassesInPackage(class UUGCPackage* Package, TArray<class UClass*>* Classes);
	bool GetMapsInPackage(class UUGCPackage* Package, TArray<class FName>* Maps);
	TArray<class UUGCPackage*> GetPackagesWhichDependsOnPackage(class UUGCPackage* Package);
	bool MountUGCPackage(class UUGCPackage* Package, bool FromJoining);
	int32 NumberOfModsInstalled(EUGCApprovalStatus ApprovalStatus);
	void RegisterAssetFromPackage(class UUGCPackage* Package);
	void ResetUGCPackagesManipulatedDuringJoin();
	class UUGCPackage* TryGetPackageFromId(const class FString& ModId);
	void UGCBlueprintsSpawned__DelegateSignature(int32 Count);
	void UGCPackageMounted__DelegateSignature(bool Sandbox);
	void UnmountAllNonVerifiedUGCPackages();
	void UnmountSandboxUGCPackages();
	bool UnmountUGCPackage(class UUGCPackage* Package, bool RemoveFromUserSettings, bool RemoveFromDisk);
	void UnmountUGCPackages(const TArray<class FString>& ExcludingModIds);

	TArray<class UUGCPackage*> GetPackagesSorted(EPackageSortField ByField, bool Ascending) const;
	bool IsModEnabled(const class FString& ModId) const;
	bool IsModInstalled(const class FString& ModId) const;
	bool IsModInstalledByIdOrName(const class FString& ModIdOrName, bool IncludeDeprecatedLocation) const;
	bool IsModInstalledImprecise(const class FString& ModName, bool IncludeDeprecatedLocation) const;
	bool IsModToBeEnabled(int64 ModId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCRegistry">();
	}
	static class UUGCRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCRegistry>();
	}
};
static_assert(alignof(UUGCRegistry) == 0x000008, "Wrong alignment on UUGCRegistry");
static_assert(sizeof(UUGCRegistry) == 0x0000F8, "Wrong size on UUGCRegistry");
static_assert(offsetof(UUGCRegistry, OnPackageMounted) == 0x000028, "Member 'UUGCRegistry::OnPackageMounted' has a wrong offset!");
static_assert(offsetof(UUGCRegistry, UGCPackages) == 0x000038, "Member 'UUGCRegistry::UGCPackages' has a wrong offset!");
static_assert(offsetof(UUGCRegistry, RegisteredOverrides) == 0x000048, "Member 'UUGCRegistry::RegisteredOverrides' has a wrong offset!");
static_assert(offsetof(UUGCRegistry, PackageChange) == 0x000098, "Member 'UUGCRegistry::PackageChange' has a wrong offset!");
static_assert(offsetof(UUGCRegistry, OnBlueprintsSpawned) == 0x0000A0, "Member 'UUGCRegistry::OnBlueprintsSpawned' has a wrong offset!");
static_assert(offsetof(UUGCRegistry, UGCPackagesInstalledDuringJoin) == 0x0000C0, "Member 'UUGCRegistry::UGCPackagesInstalledDuringJoin' has a wrong offset!");
static_assert(offsetof(UUGCRegistry, UGCPackagesUnmountedDuringJoin) == 0x0000D0, "Member 'UUGCRegistry::UGCPackagesUnmountedDuringJoin' has a wrong offset!");

// Class SimpleUGC.UGCSettings
// 0x0088 (0x00B0 - 0x0028)
class UUGCSettings final : public UObject
{
public:
	uint8                                         Pad_14E1[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Slot1;                                             // 0x0038(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	int32                                         Slot1Icon;                                         // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14E2[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Slot2;                                             // 0x0050(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	int32                                         Slot2Icon;                                         // 0x0060(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14E3[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Slot3;                                             // 0x0068(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	int32                                         Slot3Icon;                                         // 0x0078(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14E4[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Slot4;                                             // 0x0080(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	int32                                         Slot4Icon;                                         // 0x0090(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectedSlot;                                      // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E5[0x8];                                     // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSettingsUpdated;                                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CleanupSlots();
	void ClearSlot(int32 SlotNumber);
	bool DoesSlotContainMods(int32 SlotNumber);
	int32 GetIconIndexOfSlot(int32 SlotNumber);
	TArray<class FString> GetModIdsOfSlot(int32 SlotNumber);
	TArray<class FString> GetModNamesOfSlot(int32 SlotNumber, int32* OutNumberOfUnknown);
	bool LoadSlot(int32 SlotNumber);
	bool ReadFromPlainText(const class FString& Filename, class FString* OutTextContent);
	void ResetSlot();
	void SaveToSelectedSlot();
	void SaveToSlot(int32 SlotNumber);
	void SetIconIndexOfSlot(int32 SlotNumber, int32 IconIndex);
	void UGCSettingsUpdated__DelegateSignature();
	bool WriteToPlainText(const class FString& Filename, const class FString& TextContent, class FText* OutError, bool Append);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCSettings">();
	}
	static class UUGCSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCSettings>();
	}
};
static_assert(alignof(UUGCSettings) == 0x000008, "Wrong alignment on UUGCSettings");
static_assert(sizeof(UUGCSettings) == 0x0000B0, "Wrong size on UUGCSettings");
static_assert(offsetof(UUGCSettings, Slot1) == 0x000038, "Member 'UUGCSettings::Slot1' has a wrong offset!");
static_assert(offsetof(UUGCSettings, Slot1Icon) == 0x000048, "Member 'UUGCSettings::Slot1Icon' has a wrong offset!");
static_assert(offsetof(UUGCSettings, Slot2) == 0x000050, "Member 'UUGCSettings::Slot2' has a wrong offset!");
static_assert(offsetof(UUGCSettings, Slot2Icon) == 0x000060, "Member 'UUGCSettings::Slot2Icon' has a wrong offset!");
static_assert(offsetof(UUGCSettings, Slot3) == 0x000068, "Member 'UUGCSettings::Slot3' has a wrong offset!");
static_assert(offsetof(UUGCSettings, Slot3Icon) == 0x000078, "Member 'UUGCSettings::Slot3Icon' has a wrong offset!");
static_assert(offsetof(UUGCSettings, Slot4) == 0x000080, "Member 'UUGCSettings::Slot4' has a wrong offset!");
static_assert(offsetof(UUGCSettings, Slot4Icon) == 0x000090, "Member 'UUGCSettings::Slot4Icon' has a wrong offset!");
static_assert(offsetof(UUGCSettings, SelectedSlot) == 0x000094, "Member 'UUGCSettings::SelectedSlot' has a wrong offset!");
static_assert(offsetof(UUGCSettings, OnSettingsUpdated) == 0x0000A0, "Member 'UUGCSettings::OnSettingsUpdated' has a wrong offset!");

// Class SimpleUGC.UGCSubsystem
// 0x0238 (0x0268 - 0x0030)
class UUGCSubsystem final : public UEngineSubsystem
{
public:
	bool                                          ForceNoMods;                                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoInternetAccess;                                  // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoModioUser;                                       // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14EB[0x1];                                     // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsJoining;                                         // 0x0034(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14EC[0x3];                                     // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUGCRegistry*                           UGCRegistry;                                       // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUGCSettings*                           UGCSettings;                                       // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUGCLatentActionManager*                UGCLatentActionManager;                            // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ModioTermsAndConditionsAccepted;                   // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14ED[0x17];                                    // 0x0051(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnModioUserAuthenticated;                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnErrorInstalling;                                 // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FString, EUGCPackageError>         ModsFailedInstall;                                 // 0x0088(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnModDownloadExtractProgress;                      // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnModDownloadExtractProgressFinished;              // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnModUninstallProgressFinished;                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnModManagementStateChanged;                       // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsModioModManagementEnabled;                       // 0x0118(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14EE[0x7];                                     // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnLocalUserModsInstalled;                          // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsLocalUserModsInstalled;                          // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14EF[0x7];                                     // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEscapeMenuOpened;                                // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnModioRequestHandled;                             // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FString>                         CrashingDisabledMods;                              // 0x0158(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F0[0x70];                                    // 0x0168(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUGCPackage*>                    ModsPendingUninstall;                              // 0x01D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UUGCPackage*>                    ModsPendingUpdate;                                 // 0x01E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F1[0x18];                                    // 0x01F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EModioRequestType>                     ModioRequests;                                     // 0x0210(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<int64>                                 ModioSubscribeRequestsIds;                         // 0x0220(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<int64>                                 ModioSubscribeDependecyRequestsIds;                // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<int64>                                 ModioAddDependecyRequestsIds;                      // 0x0240(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14F2[0x18];                                    // 0x0250(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPendingMods(bool FromJoining);
	void DisableModioModManagement();
	void EnableModioModManagement();
	bool FetchModsForSession(const TArray<class FString>& HostMods, TDelegate<void(TArray<class FString>& ModsToEnable, TArray<class FString>& ModsToInstall)> OnModsFetched);
	void UGRequiredModsFetched__DelegateSignature(const TArray<class FString>& ModsToEnable, const TArray<class FString>& ModsToInstall);
	bool GetCheckGameVersion();
	bool GetModdingSettingsMenuEnabled();
	TArray<class FString> GetNamesOfModsPendingInstall();
	TArray<class FString> GetNamesOfModsPendingUninstall();
	TArray<class FString> GetNamesOfModsPendingUpdate();
	TArray<EModioRequestType> GetQueuedModioRequests();
	bool HasOutstadingRequestOfType(EModioRequestType RequestType);
	void K2_RequestAuthentication();
	void K2_RequestFetchModUpdates();
	void K2_RequestModDependencyList(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, const class FString& ModId, class FString* OutParentId, TArray<class FString>* OutModIds);
	void K2_RequestModMetaData(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, const class FString& ModioStringID, int64* ModId);
	void K2_RequestModThumbnail(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, class UUGCPackage* Package);
	void K2_RequestModThumbnailById(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, const class FString& ModId);
	bool K2_RequestSubscribe(const class FString& ModId);
	void K2_RequestTermsOfUse(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo);
	void MarkRecentlyInstalledModsSuccesful();
	void RemoveRequestOfType(EModioRequestType RequestType);
	void SetCheckGameVersion(bool ShouldCheck);
	void SetModidngSettingsMenuEnabled(bool bEnabled);
	void SetModsAsRecentlyInstalled(const TArray<class FString>& RecentMods);
	void SetPackagesAsRecentlyInstalled(const TArray<class UUGCPackage*>& RecentMods);
	void UGCAuthenticatedModioUser__DelegateSignature(bool Authenticated);
	void UGCEscapeMenuOpened__DelegateSignature();
	void UGCHiddenMods__DelegateSignature();
	void UGCLocalUserModsInstalled__DelegateSignature();
	void UGCModManagementStateChanged__DelegateSignature(bool Enabled);
	void UGCModProgress__DelegateSignature(const class FString& Param_Name, const TArray<class FString>& ModsPendingDownload, bool Downloading, int32 Progress, int32 Total);
	void UGCRequestHandled__DelegateSignature(EModioRequestType RequestType);
	void UGInstallError__DelegateSignature(const class FString& ModName, EUGCPackageError ErrorType);
	void UGModProgressDone__DelegateSignature(const class FString& ModName, const class FString& ModId);

	bool IsModPendingUninstall(class UUGCPackage* InMod) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCSubsystem">();
	}
	static class UUGCSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCSubsystem>();
	}
};
static_assert(alignof(UUGCSubsystem) == 0x000008, "Wrong alignment on UUGCSubsystem");
static_assert(sizeof(UUGCSubsystem) == 0x000268, "Wrong size on UUGCSubsystem");
static_assert(offsetof(UUGCSubsystem, ForceNoMods) == 0x000030, "Member 'UUGCSubsystem::ForceNoMods' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, NoInternetAccess) == 0x000031, "Member 'UUGCSubsystem::NoInternetAccess' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, NoModioUser) == 0x000032, "Member 'UUGCSubsystem::NoModioUser' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, IsJoining) == 0x000034, "Member 'UUGCSubsystem::IsJoining' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, UGCRegistry) == 0x000038, "Member 'UUGCSubsystem::UGCRegistry' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, UGCSettings) == 0x000040, "Member 'UUGCSubsystem::UGCSettings' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, UGCLatentActionManager) == 0x000048, "Member 'UUGCSubsystem::UGCLatentActionManager' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModioTermsAndConditionsAccepted) == 0x000050, "Member 'UUGCSubsystem::ModioTermsAndConditionsAccepted' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnModioUserAuthenticated) == 0x000068, "Member 'UUGCSubsystem::OnModioUserAuthenticated' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnErrorInstalling) == 0x000078, "Member 'UUGCSubsystem::OnErrorInstalling' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModsFailedInstall) == 0x000088, "Member 'UUGCSubsystem::ModsFailedInstall' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnModDownloadExtractProgress) == 0x0000D8, "Member 'UUGCSubsystem::OnModDownloadExtractProgress' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnModDownloadExtractProgressFinished) == 0x0000E8, "Member 'UUGCSubsystem::OnModDownloadExtractProgressFinished' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnModUninstallProgressFinished) == 0x0000F8, "Member 'UUGCSubsystem::OnModUninstallProgressFinished' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnModManagementStateChanged) == 0x000108, "Member 'UUGCSubsystem::OnModManagementStateChanged' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, IsModioModManagementEnabled) == 0x000118, "Member 'UUGCSubsystem::IsModioModManagementEnabled' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnLocalUserModsInstalled) == 0x000120, "Member 'UUGCSubsystem::OnLocalUserModsInstalled' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, IsLocalUserModsInstalled) == 0x000130, "Member 'UUGCSubsystem::IsLocalUserModsInstalled' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnEscapeMenuOpened) == 0x000138, "Member 'UUGCSubsystem::OnEscapeMenuOpened' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, OnModioRequestHandled) == 0x000148, "Member 'UUGCSubsystem::OnModioRequestHandled' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, CrashingDisabledMods) == 0x000158, "Member 'UUGCSubsystem::CrashingDisabledMods' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModsPendingUninstall) == 0x0001D8, "Member 'UUGCSubsystem::ModsPendingUninstall' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModsPendingUpdate) == 0x0001E8, "Member 'UUGCSubsystem::ModsPendingUpdate' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModioRequests) == 0x000210, "Member 'UUGCSubsystem::ModioRequests' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModioSubscribeRequestsIds) == 0x000220, "Member 'UUGCSubsystem::ModioSubscribeRequestsIds' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModioSubscribeDependecyRequestsIds) == 0x000230, "Member 'UUGCSubsystem::ModioSubscribeDependecyRequestsIds' has a wrong offset!");
static_assert(offsetof(UUGCSubsystem, ModioAddDependecyRequestsIds) == 0x000240, "Member 'UUGCSubsystem::ModioAddDependecyRequestsIds' has a wrong offset!");

}

