#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ITM_OverClock_Icon

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "FSD_structs.hpp"
#include "ENUM_MenuColors_structs.hpp"
#include "SlateCore_structs.hpp"
#include "UMG_structs.hpp"


namespace CG::Params
{

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.ExecuteUbergraph_ITM_Overclock_Icon
// 0x0018 (0x0018 - 0x0000)
struct ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon final
{
public:
	int32                                         EntryPoint;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           CallFunc_MenuColors_OutputColor;                   // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_Event_IsDesignTime;                         // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon) == 0x000004, "Wrong alignment on ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon");
static_assert(sizeof(ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon) == 0x000018, "Wrong size on ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon");
static_assert(offsetof(ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon, EntryPoint) == 0x000000, "Member 'ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon::EntryPoint' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon, CallFunc_MenuColors_OutputColor) == 0x000004, "Member 'ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon::CallFunc_MenuColors_OutputColor' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon, K2Node_Event_IsDesignTime) == 0x000014, "Member 'ITM_Overclock_Icon_C_ExecuteUbergraph_ITM_Overclock_Icon::K2Node_Event_IsDesignTime' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.PreConstruct
// 0x0001 (0x0001 - 0x0000)
struct ITM_Overclock_Icon_C_PreConstruct final
{
public:
	bool                                          IsDesignTime;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(ITM_Overclock_Icon_C_PreConstruct) == 0x000001, "Wrong alignment on ITM_Overclock_Icon_C_PreConstruct");
static_assert(sizeof(ITM_Overclock_Icon_C_PreConstruct) == 0x000001, "Wrong size on ITM_Overclock_Icon_C_PreConstruct");
static_assert(offsetof(ITM_Overclock_Icon_C_PreConstruct, IsDesignTime) == 0x000000, "Member 'ITM_Overclock_Icon_C_PreConstruct::IsDesignTime' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetIconSize
// 0x000C (0x000C - 0x0000)
struct ITM_Overclock_Icon_C_SetIconSize final
{
public:
	int32                                         InSize;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue;              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_1;            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetIconSize) == 0x000004, "Wrong alignment on ITM_Overclock_Icon_C_SetIconSize");
static_assert(sizeof(ITM_Overclock_Icon_C_SetIconSize) == 0x00000C, "Wrong size on ITM_Overclock_Icon_C_SetIconSize");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIconSize, InSize) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetIconSize::InSize' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIconSize, CallFunc_Conv_IntToFloat_ReturnValue) == 0x000004, "Member 'ITM_Overclock_Icon_C_SetIconSize::CallFunc_Conv_IntToFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIconSize, CallFunc_Conv_IntToFloat_ReturnValue_1) == 0x000008, "Member 'ITM_Overclock_Icon_C_SetIconSize::CallFunc_Conv_IntToFloat_ReturnValue_1' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetFrameColor
// 0x0014 (0x0014 - 0x0000)
struct ITM_Overclock_Icon_C_SetFrameColor final
{
public:
	ENUM_MenuColors                               ColorSelector;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_357C[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CallFunc_MenuColors_OutputColor;                   // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetFrameColor) == 0x000004, "Wrong alignment on ITM_Overclock_Icon_C_SetFrameColor");
static_assert(sizeof(ITM_Overclock_Icon_C_SetFrameColor) == 0x000014, "Wrong size on ITM_Overclock_Icon_C_SetFrameColor");
static_assert(offsetof(ITM_Overclock_Icon_C_SetFrameColor, ColorSelector) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetFrameColor::ColorSelector' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetFrameColor, CallFunc_MenuColors_OutputColor) == 0x000004, "Member 'ITM_Overclock_Icon_C_SetFrameColor::CallFunc_MenuColors_OutputColor' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetFrame
// 0x0008 (0x0008 - 0x0000)
struct ITM_Overclock_Icon_C_SetFrame final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetFrame) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_SetFrame");
static_assert(sizeof(ITM_Overclock_Icon_C_SetFrame) == 0x000008, "Wrong size on ITM_Overclock_Icon_C_SetFrame");
static_assert(offsetof(ITM_Overclock_Icon_C_SetFrame, Texture) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetFrame::Texture' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetIcon
// 0x0010 (0x0010 - 0x0000)
struct ITM_Overclock_Icon_C_SetIcon final
{
public:
	class UTexture2D*                             Value;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SelectVisibility_IsVisible;               // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SelectVisibility_VisibilityChanged;       // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	ESlateVisibility                              CallFunc_SelectVisibility_New_Visibility;          // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetIcon) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_SetIcon");
static_assert(sizeof(ITM_Overclock_Icon_C_SetIcon) == 0x000010, "Wrong size on ITM_Overclock_Icon_C_SetIcon");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIcon, Value) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetIcon::Value' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIcon, CallFunc_IsValid_ReturnValue) == 0x000008, "Member 'ITM_Overclock_Icon_C_SetIcon::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIcon, CallFunc_SelectVisibility_IsVisible) == 0x000009, "Member 'ITM_Overclock_Icon_C_SetIcon::CallFunc_SelectVisibility_IsVisible' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIcon, CallFunc_SelectVisibility_VisibilityChanged) == 0x00000A, "Member 'ITM_Overclock_Icon_C_SetIcon::CallFunc_SelectVisibility_VisibilityChanged' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIcon, CallFunc_SelectVisibility_New_Visibility) == 0x00000B, "Member 'ITM_Overclock_Icon_C_SetIcon::CallFunc_SelectVisibility_New_Visibility' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetIconColor
// 0x0014 (0x0014 - 0x0000)
struct ITM_Overclock_Icon_C_SetIconColor final
{
public:
	ENUM_MenuColors                               Color;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_357D[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CallFunc_MenuColors_OutputColor;                   // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetIconColor) == 0x000004, "Wrong alignment on ITM_Overclock_Icon_C_SetIconColor");
static_assert(sizeof(ITM_Overclock_Icon_C_SetIconColor) == 0x000014, "Wrong size on ITM_Overclock_Icon_C_SetIconColor");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIconColor, Color) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetIconColor::Color' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetIconColor, CallFunc_MenuColors_OutputColor) == 0x000004, "Member 'ITM_Overclock_Icon_C_SetIconColor::CallFunc_MenuColors_OutputColor' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.FromSchematic
// 0x00F0 (0x00F0 - 0x0000)
struct ITM_Overclock_Icon_C_FromSchematic final
{
public:
	class USchematic*                             InSchematic;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ShowState;                                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_CanAffordSchematic_ReturnValue;           // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_2;                    // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_357E[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               CallFunc_GetIcon_ReturnValue;                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FSlateBrush                            K2Node_MakeStruct_SlateBrush;                      // 0x0018(0x0088)()
	struct FColor                                 CallFunc_GetIconTint_ReturnValue;                  // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           CallFunc_Conv_ColorToLinearColor_ReturnValue;      // 0x00A4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_357F[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            K2Node_MakeStruct_SlateColor;                      // 0x00B8(0x0028)()
	class USkinSchematicItem*                     K2Node_DynamicCast_AsSkin_Schematic_Item;          // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(ITM_Overclock_Icon_C_FromSchematic) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_FromSchematic");
static_assert(sizeof(ITM_Overclock_Icon_C_FromSchematic) == 0x0000F0, "Wrong size on ITM_Overclock_Icon_C_FromSchematic");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, InSchematic) == 0x000000, "Member 'ITM_Overclock_Icon_C_FromSchematic::InSchematic' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, ShowState) == 0x000008, "Member 'ITM_Overclock_Icon_C_FromSchematic::ShowState' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_IsValid_ReturnValue) == 0x000009, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_IsValid_ReturnValue_1) == 0x00000A, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_CanAffordSchematic_ReturnValue) == 0x00000B, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_CanAffordSchematic_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_IsValid_ReturnValue_2) == 0x00000C, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_IsValid_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_Not_PreBool_ReturnValue) == 0x00000D, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_GetIcon_ReturnValue) == 0x000010, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_GetIcon_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, K2Node_MakeStruct_SlateBrush) == 0x000018, "Member 'ITM_Overclock_Icon_C_FromSchematic::K2Node_MakeStruct_SlateBrush' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_GetIconTint_ReturnValue) == 0x0000A0, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_GetIconTint_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, CallFunc_Conv_ColorToLinearColor_ReturnValue) == 0x0000A4, "Member 'ITM_Overclock_Icon_C_FromSchematic::CallFunc_Conv_ColorToLinearColor_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, K2Node_MakeStruct_SlateColor) == 0x0000B8, "Member 'ITM_Overclock_Icon_C_FromSchematic::K2Node_MakeStruct_SlateColor' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, K2Node_DynamicCast_AsSkin_Schematic_Item) == 0x0000E0, "Member 'ITM_Overclock_Icon_C_FromSchematic::K2Node_DynamicCast_AsSkin_Schematic_Item' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematic, K2Node_DynamicCast_bSuccess) == 0x0000E8, "Member 'ITM_Overclock_Icon_C_FromSchematic::K2Node_DynamicCast_bSuccess' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.FromUpgrade
// 0x0028 (0x0028 - 0x0000)
struct ITM_Overclock_Icon_C_FromUpgrade final
{
public:
	class UItemUpgrade*                           InUpgrade;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USchematicCategory*                     OutSchematicCategory;                              // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USchematicCategory*                     Category;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USchematicCategory*                     CallFunc_FindItemUpgradeSchematicCategory_ReturnValue; // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SelectVisibility_IsVisible;               // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SelectVisibility_VisibilityChanged;       // 0x0023(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	ESlateVisibility                              CallFunc_SelectVisibility_New_Visibility;          // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_FromUpgrade) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_FromUpgrade");
static_assert(sizeof(ITM_Overclock_Icon_C_FromUpgrade) == 0x000028, "Wrong size on ITM_Overclock_Icon_C_FromUpgrade");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, InUpgrade) == 0x000000, "Member 'ITM_Overclock_Icon_C_FromUpgrade::InUpgrade' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, OutSchematicCategory) == 0x000008, "Member 'ITM_Overclock_Icon_C_FromUpgrade::OutSchematicCategory' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, Category) == 0x000010, "Member 'ITM_Overclock_Icon_C_FromUpgrade::Category' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, CallFunc_FindItemUpgradeSchematicCategory_ReturnValue) == 0x000018, "Member 'ITM_Overclock_Icon_C_FromUpgrade::CallFunc_FindItemUpgradeSchematicCategory_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, CallFunc_IsValid_ReturnValue) == 0x000020, "Member 'ITM_Overclock_Icon_C_FromUpgrade::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, CallFunc_IsValid_ReturnValue_1) == 0x000021, "Member 'ITM_Overclock_Icon_C_FromUpgrade::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, CallFunc_SelectVisibility_IsVisible) == 0x000022, "Member 'ITM_Overclock_Icon_C_FromUpgrade::CallFunc_SelectVisibility_IsVisible' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, CallFunc_SelectVisibility_VisibilityChanged) == 0x000023, "Member 'ITM_Overclock_Icon_C_FromUpgrade::CallFunc_SelectVisibility_VisibilityChanged' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromUpgrade, CallFunc_SelectVisibility_New_Visibility) == 0x000024, "Member 'ITM_Overclock_Icon_C_FromUpgrade::CallFunc_SelectVisibility_New_Visibility' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetFrameLinearColor
// 0x0010 (0x0010 - 0x0000)
struct ITM_Overclock_Icon_C_SetFrameLinearColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetFrameLinearColor) == 0x000004, "Wrong alignment on ITM_Overclock_Icon_C_SetFrameLinearColor");
static_assert(sizeof(ITM_Overclock_Icon_C_SetFrameLinearColor) == 0x000010, "Wrong size on ITM_Overclock_Icon_C_SetFrameLinearColor");
static_assert(offsetof(ITM_Overclock_Icon_C_SetFrameLinearColor, Color) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetFrameLinearColor::Color' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetCategory
// 0x0028 (0x0028 - 0x0000)
struct ITM_Overclock_Icon_C_SetCategory final
{
public:
	class USchematicCategory*                     InCategory;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3580[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallFunc_LoadAsset_Blocking_ReturnValue;           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UTexture2D*                             K2Node_DynamicCast_AsTexture_2D;                   // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetCategory) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_SetCategory");
static_assert(sizeof(ITM_Overclock_Icon_C_SetCategory) == 0x000028, "Wrong size on ITM_Overclock_Icon_C_SetCategory");
static_assert(offsetof(ITM_Overclock_Icon_C_SetCategory, InCategory) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetCategory::InCategory' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetCategory, CallFunc_IsValid_ReturnValue) == 0x000008, "Member 'ITM_Overclock_Icon_C_SetCategory::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetCategory, CallFunc_LoadAsset_Blocking_ReturnValue) == 0x000010, "Member 'ITM_Overclock_Icon_C_SetCategory::CallFunc_LoadAsset_Blocking_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetCategory, K2Node_DynamicCast_AsTexture_2D) == 0x000018, "Member 'ITM_Overclock_Icon_C_SetCategory::K2Node_DynamicCast_AsTexture_2D' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_SetCategory, K2Node_DynamicCast_bSuccess) == 0x000020, "Member 'ITM_Overclock_Icon_C_SetCategory::K2Node_DynamicCast_bSuccess' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.FromSchematicType
// 0x00F0 (0x00F0 - 0x0000)
struct ITM_Overclock_Icon_C_FromSchematicType final
{
public:
	ESchematicType                                InType;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3581[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSchematicType                         Data;                                              // 0x0008(0x0070)(Edit, BlueprintVisible)
	class UGameData*                              CallFunc_GetFSDGameData_ReturnValue;               // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FSchematicType                         CallFunc_GetSchematicTypeData_ReturnValue;         // 0x0080(0x0070)()
};
static_assert(alignof(ITM_Overclock_Icon_C_FromSchematicType) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_FromSchematicType");
static_assert(sizeof(ITM_Overclock_Icon_C_FromSchematicType) == 0x0000F0, "Wrong size on ITM_Overclock_Icon_C_FromSchematicType");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematicType, InType) == 0x000000, "Member 'ITM_Overclock_Icon_C_FromSchematicType::InType' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematicType, Data) == 0x000008, "Member 'ITM_Overclock_Icon_C_FromSchematicType::Data' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematicType, CallFunc_GetFSDGameData_ReturnValue) == 0x000078, "Member 'ITM_Overclock_Icon_C_FromSchematicType::CallFunc_GetFSDGameData_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_FromSchematicType, CallFunc_GetSchematicTypeData_ReturnValue) == 0x000080, "Member 'ITM_Overclock_Icon_C_FromSchematicType::CallFunc_GetSchematicTypeData_ReturnValue' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.GetFrameLinearColor
// 0x0010 (0x0010 - 0x0000)
struct ITM_Overclock_Icon_C_GetFrameLinearColor final
{
public:
	struct FLinearColor                           Param_ColorAndOpacity;                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_GetFrameLinearColor) == 0x000004, "Wrong alignment on ITM_Overclock_Icon_C_GetFrameLinearColor");
static_assert(sizeof(ITM_Overclock_Icon_C_GetFrameLinearColor) == 0x000010, "Wrong size on ITM_Overclock_Icon_C_GetFrameLinearColor");
static_assert(offsetof(ITM_Overclock_Icon_C_GetFrameLinearColor, Param_ColorAndOpacity) == 0x000000, "Member 'ITM_Overclock_Icon_C_GetFrameLinearColor::Param_ColorAndOpacity' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.GetOverclockTooltip
// 0x0030 (0x0030 - 0x0000)
struct ITM_Overclock_Icon_C_GetOverclockTooltip final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UTOOLTIP_Overclock_Item_C*              ToolTip;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3582[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWindowManager*                         CallFunc_GetWindowManager_ReturnValue;             // 0x0018(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_GetOrCreateSingletonWidget_WidgetCreated; // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3583[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTOOLTIP_Overclock_Item_C*              CallFunc_GetOrCreateSingletonWidget_ReturnValue;   // 0x0028(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_GetOverclockTooltip) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_GetOverclockTooltip");
static_assert(sizeof(ITM_Overclock_Icon_C_GetOverclockTooltip) == 0x000030, "Wrong size on ITM_Overclock_Icon_C_GetOverclockTooltip");
static_assert(offsetof(ITM_Overclock_Icon_C_GetOverclockTooltip, ReturnValue) == 0x000000, "Member 'ITM_Overclock_Icon_C_GetOverclockTooltip::ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_GetOverclockTooltip, ToolTip) == 0x000008, "Member 'ITM_Overclock_Icon_C_GetOverclockTooltip::ToolTip' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_GetOverclockTooltip, CallFunc_IsValid_ReturnValue) == 0x000010, "Member 'ITM_Overclock_Icon_C_GetOverclockTooltip::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_GetOverclockTooltip, CallFunc_GetWindowManager_ReturnValue) == 0x000018, "Member 'ITM_Overclock_Icon_C_GetOverclockTooltip::CallFunc_GetWindowManager_ReturnValue' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_GetOverclockTooltip, CallFunc_GetOrCreateSingletonWidget_WidgetCreated) == 0x000020, "Member 'ITM_Overclock_Icon_C_GetOverclockTooltip::CallFunc_GetOrCreateSingletonWidget_WidgetCreated' has a wrong offset!");
static_assert(offsetof(ITM_Overclock_Icon_C_GetOverclockTooltip, CallFunc_GetOrCreateSingletonWidget_ReturnValue) == 0x000028, "Member 'ITM_Overclock_Icon_C_GetOverclockTooltip::CallFunc_GetOrCreateSingletonWidget_ReturnValue' has a wrong offset!");

// Function ITM_OverClock_Icon.ITM_Overclock_Icon_C.SetOverclockTooltip
// 0x0008 (0x0008 - 0x0000)
struct ITM_Overclock_Icon_C_SetOverclockTooltip final
{
public:
	class UItemUpgrade*                           Param_Overclock;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(ITM_Overclock_Icon_C_SetOverclockTooltip) == 0x000008, "Wrong alignment on ITM_Overclock_Icon_C_SetOverclockTooltip");
static_assert(sizeof(ITM_Overclock_Icon_C_SetOverclockTooltip) == 0x000008, "Wrong size on ITM_Overclock_Icon_C_SetOverclockTooltip");
static_assert(offsetof(ITM_Overclock_Icon_C_SetOverclockTooltip, Param_Overclock) == 0x000000, "Member 'ITM_Overclock_Icon_C_SetOverclockTooltip::Param_Overclock' has a wrong offset!");

}

