#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FSD

#include "Basic.hpp"

#include "AnimGraphRuntime_structs.hpp"
#include "FSDEngine_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "UMG_structs.hpp"
#include "SlateCore_structs.hpp"
#include "DLSSBlueprint_structs.hpp"
#include "InputCore_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace CG
{

// Enum FSD.EDrinkableAlcoholStrength
// NumValues: 0x0007
enum class EDrinkableAlcoholStrength : uint8
{
	NonAlcoholic                             = 0,
	Light                                    = 1,
	Regular                                  = 2,
	Strong                                   = 3,
	VeryStrong                               = 4,
	InstantPassout                           = 5,
	EDrinkableAlcoholStrength_MAX            = 6,
};

// Enum FSD.EIntoxicationState
// NumValues: 0x0004
enum class EIntoxicationState : uint8
{
	NotIntoxicated                           = 0,
	Intoxicated                              = 1,
	PassOut                                  = 2,
	EIntoxicationState_MAX                   = 3,
};

// Enum FSD.EOutline
// NumValues: 0x0006
enum class EOutline : uint8
{
	OL_NONE                                  = 0,
	OL_FRIENDLY                              = 251,
	OL_NEUTRAL                               = 252,
	OL_ENEMY                                 = 253,
	OL_ITEM                                  = 254,
	EOutline_MAX                             = 255,
};

// Enum FSD.ELaserPointerTargetType
// NumValues: 0x0007
enum class ELaserPointerTargetType : uint8
{
	Chunkable                                = 0,
	Dirt                                     = 1,
	Player                                   = 2,
	Enemy                                    = 3,
	EmbeddedGem                              = 4,
	Other                                    = 5,
	ELaserPointerTargetType_MAX              = 6,
};

// Enum FSD.ECharacterState
// NumValues: 0x0015
enum class ECharacterState : uint8
{
	Walking                                  = 0,
	Downed                                   = 1,
	Dead                                     = 2,
	Falling                                  = 3,
	Paralyzed                                = 4,
	Using                                    = 5,
	ZipLine                                  = 6,
	NoMovement                               = 7,
	Grabbed                                  = 8,
	Flying                                   = 9,
	Frozen                                   = 10,
	PassedOut                                = 11,
	Photography                              = 12,
	Piloting                                 = 13,
	Attached                                 = 14,
	Pushing                                  = 15,
	TrackMovement                            = 16,
	EnemyControl                             = 17,
	Infected                                 = 18,
	Invalid                                  = 19,
	ECharacterState_MAX                      = 20,
};

// Enum FSD.ECharacterCameraMode
// NumValues: 0x0008
enum class ECharacterCameraMode : uint8
{
	FirstPerson                              = 0,
	ThirdPerson                              = 1,
	Follow                                   = 2,
	DownCamera                               = 3,
	TerrainScanner                           = 4,
	PhotographyMode                          = 5,
	FirstPersonHeadOnly                      = 6,
	ECharacterCameraMode_MAX                 = 7,
};

// Enum FSD.EInputKeys
// NumValues: 0x0004
enum class EInputKeys : uint8
{
	Use                                      = 0,
	Fire                                     = 1,
	Mine                                     = 2,
	EInputKeys_MAX                           = 255,
};

// Enum FSD.EPlatformComponentCriteria
// NumValues: 0x0005
enum class EPlatformComponentCriteria : uint8
{
	All                                      = 0,
	ServerOnly                               = 1,
	ClientOnly                               = 2,
	OwningClientOnly                         = 3,
	EPlatformComponentCriteria_MAX           = 4,
};

// Enum FSD.EPlayerTemperatureState
// NumValues: 0x0004
enum class EPlayerTemperatureState : uint8
{
	Normal                                   = 0,
	Frozen                                   = 1,
	Overheated                               = 2,
	EPlayerTemperatureState_MAX              = 3,
};

// Enum FSD.EThawInputDirection
// NumValues: 0x0006
enum class EThawInputDirection : uint8
{
	EForward                                 = 0,
	ERight                                   = 1,
	EBack                                    = 2,
	ELeft                                    = 3,
	ENA                                      = 4,
	EThawInputDirection_MAX                  = 5,
};

// Enum FSD.EDeepMovementState
// NumValues: 0x0007
enum class EDeepMovementState : uint8
{
	Stationary                               = 0,
	Controlled                               = 1,
	Moving                                   = 2,
	WaitingForPath                           = 3,
	AttackStance                             = 4,
	FakePhysics                              = 5,
	EDeepMovementState_MAX                   = 6,
};

// Enum FSD.ECharselectionCameraLocation
// NumValues: 0x0008
enum class ECharselectionCameraLocation : uint8
{
	Selection                                = 0,
	Customization                            = 1,
	Crafting                                 = 2,
	ViewWeapon                               = 3,
	EndScreen                                = 4,
	Forge                                    = 5,
	Pickaxe                                  = 6,
	ECharselectionCameraLocation_MAX         = 7,
};

// Enum FSD.EMinersManualSection
// NumValues: 0x0008
enum class EMinersManualSection : uint8
{
	FrontPage                                = 0,
	Hints                                    = 1,
	Combat                                   = 2,
	Creatures                                = 3,
	Biomes                                   = 4,
	Missions                                 = 5,
	Resources                                = 6,
	EMinersManualSection_MAX                 = 7,
};

// Enum FSD.ECharacterSelectorItemStatus
// NumValues: 0x0004
enum class ECharacterSelectorItemStatus : uint8
{
	LeaveAsIs                                = 0,
	SwitchToDefault                          = 1,
	NoItemEquipped                           = 2,
	ECharacterSelectorItemStatus_MAX         = 3,
};

// Enum FSD.EGameType
// NumValues: 0x0005
enum class EGameType : uint8
{
	Fully                                    = 0,
	Progression                              = 1,
	Sandbox                                  = 2,
	Vanilla                                  = 99,
	EGameType_MAX                            = 100,
};

// Enum FSD.ESteamSearchRegion
// NumValues: 0x0005
enum class ESteamSearchRegion : uint8
{
	Close                                    = 0,
	Medium                                   = 1,
	Far                                      = 2,
	World                                    = 3,
	ESteamSearchRegion_MAX                   = 4,
};

// Enum FSD.ESteamServerJoinStatus
// NumValues: 0x0003
enum class ESteamServerJoinStatus : uint8
{
	Open                                     = 0,
	PasswordRequired                         = 1,
	ESteamServerJoinStatus_MAX               = 2,
};

// Enum FSD.EAlwaysLoadedWorlds
// NumValues: 0x0004
enum class EAlwaysLoadedWorlds : uint8
{
	CharacterViewer                          = 0,
	LoaderNormal                             = 1,
	LoaderDeepDive                           = 2,
	EAlwaysLoadedWorlds_MAX                  = 3,
};

// Enum FSD.EDisconnectReason
// NumValues: 0x0014
enum class EDisconnectReason : uint8
{
	None                                     = 0,
	Kicked_HaveMyReasons                     = 1,
	Kicked_ShouldBePrivate                   = 2,
	Kicked_AFK                               = 3,
	Banned                                   = 4,
	ServerQuit                               = 5,
	Disconnected                             = 6,
	SignInChange                             = 7,
	JoinSessionFail_SessionIsFull            = 8,
	JoinSessionFail_SessionDoesNotExist      = 9,
	JoinSessionFail_Other                    = 10,
	JoinSessionFail_Privilege                = 11,
	NetworkError                             = 12,
	SignOutComplete                          = 13,
	WrongPassword                            = 14,
	DeepDiveLateJoin                         = 15,
	MissionStarting                          = 16,
	LatejoinNotAllowed                       = 17,
	OutdatedClient                           = 18,
	EDisconnectReason_MAX                    = 19,
};

// Enum FSD.EChatSenderType
// NumValues: 0x0006
enum class EChatSenderType : uint8
{
	NormalUser                               = 0,
	DeluxUser                                = 1,
	Developer                                = 2,
	Streamer                                 = 3,
	Modder                                   = 4,
	EChatSenderType_MAX                      = 5,
};

// Enum FSD.EChatMessageType
// NumValues: 0x0003
enum class EChatMessageType : uint8
{
	ES_Chat                                  = 0,
	ES_Game                                  = 1,
	ES_MAX                                   = 2,
};

// Enum FSD.EFSDInputSource
// NumValues: 0x0004
enum class EFSDInputSource : uint8
{
	None                                     = 0,
	MouseAndKeyboard                         = 1,
	Controller                               = 2,
	EFSDInputSource_MAX                      = 3,
};

// Enum FSD.EKeyboardLayout
// NumValues: 0x0004
enum class EKeyboardLayout : uint8
{
	QWERTY                                   = 0,
	AZERTY                                   = 1,
	QWERTZ                                   = 2,
	EKeyboardLayout_MAX                      = 3,
};

// Enum FSD.EHUDVisibilityReason
// NumValues: 0x0006
enum class EHUDVisibilityReason : uint8
{
	Invalid                                  = 0,
	UserChoice                               = 1,
	StandDown                                = 2,
	MenuActive                               = 4,
	Photography                              = 8,
	EHUDVisibilityReason_MAX                 = 9,
};

// Enum FSD.EMinersManualSinglePage
// NumValues: 0x000F
enum class EMinersManualSinglePage : uint8
{
	Mutators                                 = 0,
	Warnings                                 = 1,
	DamageTypes                              = 2,
	Weakpoints                               = 3,
	Armor                                    = 4,
	Light                                    = 5,
	Ammo                                     = 6,
	Traversal                                = 7,
	Spacerig                                 = 8,
	Upgrades                                 = 9,
	Perks                                    = 10,
	Bosco                                    = 11,
	Assignments                              = 12,
	Navigation                               = 13,
	EMinersManualSinglePage_MAX              = 14,
};

// Enum FSD.EArmorDamageType
// NumValues: 0x0004
enum class EArmorDamageType : uint8
{
	Normal                                   = 0,
	Dissolve                                 = 1,
	Beam                                     = 2,
	EArmorDamageType_MAX                     = 3,
};

// Enum FSD.ESpacerigStartType
// NumValues: 0x0003
enum class ESpacerigStartType : uint8
{
	PlayerHub                                = 0,
	Medbay                                   = 1,
	ESpacerigStartType_MAX                   = 2,
};

// Enum FSD.EItemCategory
// NumValues: 0x0009
enum class EItemCategory : uint8
{
	PrimaryWeapon                            = 0,
	SecondaryWeapon                          = 1,
	TraversalTool                            = 2,
	ClassTool                                = 3,
	Grenade                                  = 4,
	Flare                                    = 5,
	MiningTool                               = 6,
	Armor                                    = 7,
	EItemCategory_MAX                        = 8,
};

// Enum FSD.EFSDFaction
// NumValues: 0x0005
enum class EFSDFaction : uint8
{
	NoFaction                                = 0,
	CaveCrawlers                             = 1,
	MightyMiners                             = 2,
	DirtDiggers                              = 3,
	EFSDFaction_MAX                          = 4,
};

// Enum FSD.ESonyInputSettingsBools
// NumValues: 0x000C
enum class ESonyInputSettingsBools : uint8
{
	MotionControlEnabled                     = 0,
	MotionControlFlight                      = 1,
	MotionControlSalute                      = 2,
	MotionControlPrecisionMode               = 3,
	AdaptiveTriggersEnabled                  = 4,
	TouchPadTerrainScannerEnabled            = 5,
	TouchPadGesturesEnabled                  = 6,
	ControllerSpeakerMissionControl          = 7,
	ControllerSpeakerSalute                  = 8,
	ControllerSpeakerFlare                   = 9,
	ControllerSpeakerMineralCollection       = 10,
	ESonyInputSettingsBools_MAX              = 11,
};

// Enum FSD.ESonyInputSettingsFloats
// NumValues: 0x0007
enum class ESonyInputSettingsFloats : uint8
{
	MotionControlXSensitivity                = 0,
	MotionControlYSensitivity                = 1,
	ControllerSpeakerVolume                  = 2,
	TouchPadTerrainScannerXSensitivity       = 3,
	TouchPadTerrainScannerYSensitivity       = 4,
	TouchPadTerrainScannerZoomSensitivity    = 5,
	ESonyInputSettingsFloats_MAX             = 6,
};

// Enum FSD.ESonyControllerLightMode
// NumValues: 0x0004
enum class ESonyControllerLightMode : uint8
{
	Disabled                                 = 0,
	Simple                                   = 1,
	Default                                  = 2,
	ESonyControllerLightMode_MAX             = 3,
};

// Enum FSD.ESonyControllerMotionMapping
// NumValues: 0x0003
enum class ESonyControllerMotionMapping : uint8
{
	Yaw                                      = 0,
	Roll                                     = 1,
	ESonyControllerMotionMapping_MAX         = 2,
};

// Enum FSD.EConsoleGraphicsMode
// NumValues: 0x0004
enum class EConsoleGraphicsMode : uint8
{
	Fidelity                                 = 0,
	Performance                              = 1,
	Performance120                           = 2,
	EConsoleGraphicsMode_MAX                 = 3,
};

// Enum FSD.EHUDVisibilityMode
// NumValues: 0x0004
enum class EHUDVisibilityMode : uint8
{
	Visible                                  = 0,
	Dynamic                                  = 1,
	Hidden                                   = 2,
	EHUDVisibilityMode_MAX                   = 3,
};

// Enum FSD.ETurn180Mode
// NumValues: 0x0004
enum class ETurn180Mode : uint8
{
	PressRun                                 = 0,
	PressFlare                               = 1,
	Off                                      = 2,
	ETurn180Mode_MAX                         = 3,
};

// Enum FSD.EVanitySlot
// NumValues: 0x000B
enum class EVanitySlot : uint8
{
	Head                                     = 0,
	Beard                                    = 1,
	Armor                                    = 2,
	BeardColor                               = 3,
	SkinColor                                = 4,
	Moustache                                = 5,
	Eyebrows                                 = 6,
	Sideburns                                = 7,
	ArmorMaterial                            = 8,
	Count                                    = 9,
	EVanitySlot_MAX                          = 10,
};

// Enum FSD.EVacuumState
// NumValues: 0x0005
enum class EVacuumState : uint8
{
	EPuddle                                  = 0,
	EVacuuming                               = 1,
	EFalling                                 = 2,
	EDead                                    = 3,
	EVacuumState_MAX                         = 4,
};

// Enum FSD.EHolidayType
// NumValues: 0x000A
enum class EHolidayType : uint8
{
	None                                     = 0,
	LunarFestival                            = 1,
	Anniversary                              = 2,
	Easter                                   = 3,
	BeachParty                               = 4,
	Oktoberfest                              = 5,
	Halloween                                = 6,
	Xmas                                     = 7,
	OneOffEvent                              = 8,
	EHolidayType_MAX                         = 9,
};

// Enum FSD.ECampaignType
// NumValues: 0x0005
enum class ECampaignType : uint8
{
	Normal                                   = 0,
	Weekly                                   = 1,
	MatrixCoreHunt                           = 2,
	SeededRandom                             = 3,
	ECampaignType_MAX                        = 4,
};

// Enum FSD.EItemPreviewStatus
// NumValues: 0x0006
enum class EItemPreviewStatus : uint8
{
	Normal                                   = 0,
	Upgraded                                 = 1,
	Previewed                                = 2,
	PreviewReduced                           = 3,
	UpgradedAndPreviewReduced                = 4,
	EItemPreviewStatus_MAX                   = 5,
};

// Enum FSD.EUpgradeCalucationType
// NumValues: 0x0003
enum class EUpgradeCalucationType : uint8
{
	Additive                                 = 0,
	Multiplicative                           = 1,
	EUpgradeCalucationType_MAX               = 2,
};

// Enum FSD.EUpgradeClass
// NumValues: 0x0008
enum class EUpgradeClass : uint8
{
	Class_A                                  = 0,
	Class_B                                  = 1,
	Gear_A                                   = 2,
	Gear_B                                   = 3,
	Armor                                    = 4,
	Pickaxe                                  = 5,
	Class_Bosco                              = 10,
	EUpgradeClass_MAX                        = 11,
};

// Enum FSD.EUpgradeTiers
// NumValues: 0x0006
enum class EUpgradeTiers : uint8
{
	Tier_1                                   = 0,
	Tier_2                                   = 1,
	Tier_3                                   = 2,
	Tier_4                                   = 3,
	Tier_5                                   = 4,
	Tier_MAX                                 = 5,
};

// Enum FSD.EDroneAIState
// NumValues: 0x000C
enum class EDroneAIState : uint8
{
	Follow                                   = 0,
	Mine                                     = 1,
	Fight                                    = 2,
	Revive                                   = 3,
	Light                                    = 4,
	GoToPlayer                               = 5,
	Salute                                   = 6,
	CarryGem                                 = 7,
	UseAbillity                              = 8,
	Repairing                                = 9,
	Cleaning                                 = 10,
	EDroneAIState_MAX                        = 11,
};

// Enum FSD.EDroneState
// NumValues: 0x0005
enum class EDroneState : uint8
{
	EFollow                                  = 0,
	EMining                                  = 1,
	ELight                                   = 2,
	EMax                                     = 3,
	EDroneState_MAX                          = 4,
};

// Enum FSD.ERessuplyPodState
// NumValues: 0x0005
enum class ERessuplyPodState : uint8
{
	ReadyToDrop                              = 0,
	Dropping                                 = 1,
	Landed                                   = 2,
	Idle                                     = 3,
	ERessuplyPodState_MAX                    = 4,
};

// Enum FSD.EHackingPodState
// NumValues: 0x0007
enum class EHackingPodState : uint8
{
	EClosed                                  = 0,
	EShowDispenser                           = 1,
	EShowButton                              = 2,
	EHacking                                 = 3,
	EDestroyed                               = 4,
	EDone                                    = 5,
	EHackingPodState_MAX                     = 6,
};

// Enum FSD.ERockCrackerstate
// NumValues: 0x0007
enum class ERockCrackerstate : uint8
{
	Init                                     = 0,
	EFalling                                 = 1,
	EConnect                                 = 2,
	EDrilling                                = 3,
	EBroke                                   = 4,
	EDone                                    = 5,
	ERockCrackerstate_MAX                    = 6,
};

// Enum FSD.ERivalBombNodeState
// NumValues: 0x0006
enum class ERivalBombNodeState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Hackable                                 = 2,
	Completed                                = 3,
	Failed                                   = 4,
	ERivalBombNodeState_MAX                  = 5,
};

// Enum FSD.EEnemyHealthScaling
// NumValues: 0x0008
enum class EEnemyHealthScaling : uint8
{
	SmallEnemy                               = 0,
	LargeEnemy                               = 1,
	ExtraLargeEnemy                          = 2,
	ExtraLargeEnemyB                         = 4,
	ExtraLargeEnemyC                         = 5,
	ExtraLargeEnemyD                         = 6,
	NoScaling                                = 3,
	EEnemyHealthScaling_MAX                  = 7,
};

// Enum FSD.EHealthbarType
// NumValues: 0x0004
enum class EHealthbarType : uint8
{
	None                                     = 0,
	MainLife                                 = 1,
	Shield                                   = 2,
	EHealthbarType_MAX                       = 3,
};

// Enum FSD.EMissionStatType
// NumValues: 0x0005
enum class EMissionStatType : uint8
{
	Float                                    = 0,
	Integer                                  = 1,
	Time                                     = 2,
	Distance                                 = 3,
	EMissionStatType_MAX                     = 4,
};

// Enum FSD.EPawnAttitude
// NumValues: 0x0004
enum class EPawnAttitude : uint8
{
	Friendly                                 = 0,
	Neutral                                  = 1,
	Hostile                                  = 2,
	EPawnAttitude_MAX                        = 3,
};

// Enum FSD.EInfectionState
// NumValues: 0x0004
enum class EInfectionState : uint8
{
	Normal                                   = 0,
	PartlyInfected                           = 1,
	FullyInfected                            = 2,
	EInfectionState_MAX                      = 3,
};

// Enum FSD.ERefineryState
// NumValues: 0x0008
enum class ERefineryState : uint8
{
	Landing                                  = 0,
	ConnectingPipes                          = 1,
	PipesConnected                           = 2,
	Refining                                 = 3,
	RefiningStalled                          = 4,
	RefiningComplete                         = 5,
	RocketLaunched                           = 6,
	ERefineryState_MAX                       = 7,
};

// Enum FSD.EFrozenBitsSize
// NumValues: 0x0006
enum class EFrozenBitsSize : uint8
{
	Tiny                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Large                                    = 3,
	Huge                                     = 4,
	EFrozenBitsSize_MAX                      = 5,
};

// Enum FSD.EPropHuntEndScreen
// NumValues: 0x0003
enum class EPropHuntEndScreen : uint8
{
	HuntersWin                               = 0,
	PropsWin                                 = 1,
	EPropHuntEndScreen_MAX                   = 2,
};

// Enum FSD.EPropHuntRole
// NumValues: 0x0004
enum class EPropHuntRole : uint8
{
	PendingRole                              = 0,
	Hunter                                   = 1,
	Prop                                     = 2,
	EPropHuntRole_MAX                        = 3,
};

// Enum FSD.EDroppableOutpostState
// NumValues: 0x0006
enum class EDroppableOutpostState : uint8
{
	WaitingToDrop                            = 0,
	Drilling                                 = 1,
	Landed                                   = 2,
	PrepTakeoff                              = 3,
	Departing                                = 4,
	EDroppableOutpostState_MAX               = 5,
};

// Enum FSD.EPipelineBuildState
// NumValues: 0x0005
enum class EPipelineBuildState : uint8
{
	NotStarted                               = 0,
	BeginBuilt                               = 1,
	Completed                                = 2,
	Broken                                   = 3,
	EPipelineBuildState_MAX                  = 4,
};

// Enum FSD.ETrackBuildPlacementState
// NumValues: 0x0004
enum class ETrackBuildPlacementState : uint8
{
	NotBeingPlaced                           = 0,
	BeingPlaced                              = 1,
	Finished                                 = 2,
	ETrackBuildPlacementState_MAX            = 3,
};

// Enum FSD.ESchematicState
// NumValues: 0x0004
enum class ESchematicState : uint8
{
	NotOwned                                 = 0,
	Owned                                    = 1,
	OwnedBuilt                               = 2,
	ESchematicState_MAX                      = 3,
};

// Enum FSD.EShoutType
// NumValues: 0x001C
enum class EShoutType : uint8
{
	Attention                                = 0,
	Follow                                   = 1,
	StandingDown                             = 2,
	Downed                                   = 3,
	RequestRevive                            = 4,
	Revived                                  = 5,
	Resupply                                 = 6,
	FriendlyFire                             = 7,
	KillCry                                  = 8,
	Dead                                     = 9,
	Cheating                                 = 10,
	ResourceFull                             = 11,
	ResourceFullNoDonkey                     = 12,
	CallDonkey                               = 13,
	CallDonkey_NotInMission                  = 14,
	Depositing                               = 15,
	DepositingNoDonkey                       = 16,
	OutOfAmmo                                = 17,
	Reloading                                = 18,
	CharacterSelected                        = 19,
	UpgradeBought                            = 20,
	WaitingInDropPod                         = 21,
	Carrying                                 = 22,
	WaitingInEscapePod                       = 23,
	Salute                                   = 24,
	Salute_Spacerig                          = 25,
	Drink                                    = 26,
	EShoutType_MAX                           = 27,
};

// Enum FSD.EAsyncLoadPriority
// NumValues: 0x0004
enum class EAsyncLoadPriority : uint8
{
	Normal                                   = 0,
	High                                     = 100,
	Low                                      = 255,
	EAsyncLoadPriority_MAX                   = 256,
};

// Enum FSD.EHUDVisibilityPresets
// NumValues: 0x0005
enum class EHUDVisibilityPresets : uint8
{
	AllVisible                               = 0,
	Recommended                              = 1,
	Minimal                                  = 2,
	AllHidden                                = 3,
	EHUDVisibilityPresets_MAX                = 4,
};

// Enum FSD.EHUDVisibilityGroups
// NumValues: 0x0011
enum class EHUDVisibilityGroups : uint8
{
	OnScreenHelp                             = 0,
	EnemyHealth                              = 1,
	RadarAndDepth                            = 2,
	PlayerHealthShield                       = 3,
	PlayerNameClassIcon                      = 4,
	PlayerItems                              = 5,
	PlayerResources                          = 6,
	WeaponInfo                               = 7,
	Grenades                                 = 8,
	FlashLight                               = 9,
	Flares                                   = 10,
	Crosshair                                = 11,
	Objectives                               = 12,
	TeamDisplay                              = 13,
	SentryGunDisplay                         = 14,
	VersionNumber                            = 15,
	EHUDVisibilityGroups_MAX                 = 16,
};

// Enum FSD.EMediaPlayerState
// NumValues: 0x0005
enum class EMediaPlayerState : uint8
{
	NotLoaded                                = 0,
	Opening                                  = 1,
	Playing                                  = 2,
	Stopped                                  = 3,
	EMediaPlayerState_MAX                    = 4,
};

// Enum FSD.EAmmoWeaponState
// NumValues: 0x0006
enum class EAmmoWeaponState : uint8
{
	Equipping                                = 0,
	Ready                                    = 1,
	Cycling                                  = 2,
	Reloading                                = 3,
	BurstCycling                             = 4,
	EAmmoWeaponState_MAX                     = 5,
};

// Enum FSD.ECrossbowSwitchState
// NumValues: 0x0004
enum class ECrossbowSwitchState : uint32
{
	Normal                                   = 0,
	Cancelled                                = 1,
	DuringReload                             = 2,
	ECrossbowSwitchState_MAX                 = 3,
};

// Enum FSD.EProjectileSwitchCriteria
// NumValues: 0x0006
enum class EProjectileSwitchCriteria : uint8
{
	None                                     = 0,
	CharagedProjectile                       = 1,
	HeatAbove                                = 2,
	HeatBelow                                = 3,
	CycleButtonSecondsHeld                   = 4,
	EProjectileSwitchCriteria_MAX            = 5,
};

// Enum FSD.EGooGunFireMode
// NumValues: 0x0004
enum class EGooGunFireMode : uint8
{
	Normal                                   = 0,
	Charge                                   = 1,
	Burst                                    = 2,
	EGooGunFireMode_MAX                      = 3,
};

// Enum FSD.EThrownGrenadeItemState
// NumValues: 0x0004
enum class EThrownGrenadeItemState : uint32
{
	NotEquipped                              = 0,
	Cooking                                  = 1,
	Throwing                                 = 2,
	EThrownGrenadeItemState_MAX              = 3,
};

// Enum FSD.EMicroMissileLauncherFireMode
// NumValues: 0x0004
enum class EMicroMissileLauncherFireMode : uint8
{
	Normal                                   = 0,
	Charge                                   = 1,
	Buck                                     = 2,
	EMicroMissileLauncherFireMode_MAX        = 3,
};

// Enum FSD.EOnProjectileImpactBehaviourEnum
// NumValues: 0x0005
enum class EOnProjectileImpactBehaviourEnum : uint32
{
	CallOnPredict                            = 0,
	CallOnConfirmed                          = 1,
	CallOnPredictAndConfirmed                = 2,
	ClientAuthoritative                      = 3,
	EOnProjectileImpactBehaviourEnum_MAX     = 4,
};

// Enum FSD.ELineRotation
// NumValues: 0x0005
enum class ELineRotation : uint8
{
	None                                     = 0,
	Yaw                                      = 1,
	Pitch                                    = 2,
	Roll                                     = 3,
	ELineRotation_MAX                        = 4,
};

// Enum FSD.EImpactDecalSize
// NumValues: 0x0005
enum class EImpactDecalSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	None                                     = 3,
	EImpactDecalSize_MAX                     = 4,
};

// Enum FSD.ERecallableActorState
// NumValues: 0x0007
enum class ERecallableActorState : uint8
{
	Idle                                     = 0,
	RelocateRequested                        = 1,
	Relocating                               = 2,
	ReturnRequested                          = 3,
	Returning                                = 4,
	Home                                     = 5,
	ERecallableActorState_MAX                = 6,
};

// Enum FSD.ERedeployableSentryGunState
// NumValues: 0x0005
enum class ERedeployableSentryGunState : uint8
{
	Deploying                                = 0,
	Deployed                                 = 1,
	Dismantling                              = 2,
	Dismantled                               = 3,
	ERedeployableSentryGunState_MAX          = 4,
};

// Enum FSD.EItemSkinType
// NumValues: 0x0003
enum class EItemSkinType : uint8
{
	PaintJob                                 = 0,
	Framework                                = 1,
	EItemSkinType_MAX                        = 2,
};

// Enum FSD.EFriendOnlineStatusEnum
// NumValues: 0x0004
enum class EFriendOnlineStatusEnum : uint8
{
	Online                                   = 0,
	Offline                                  = 1,
	Away                                     = 2,
	EFriendOnlineStatusEnum_MAX              = 3,
};

// Enum FSD.EBlueprintablePrivilegeResults
// NumValues: 0x000D
enum class EBlueprintablePrivilegeResults : uint8
{
	NoFailures                               = 0,
	RequiredPatchAvailable                   = 1,
	RequiredSystemUpdate                     = 2,
	AgeRestrictionFailure                    = 3,
	AccountTypeFailure                       = 4,
	UserNotFound                             = 5,
	UserNotLoggedIn                          = 6,
	ChatRestriction                          = 7,
	UGCRestriction                           = 8,
	GenericFailure                           = 9,
	OnlinePlayRestricted                     = 10,
	NetworkConnectionUnavailable             = 11,
	EBlueprintablePrivilegeResults_MAX       = 12,
};

// Enum FSD.EBlueprintableUserPrivileges
// NumValues: 0x0006
enum class EBlueprintableUserPrivileges : uint8
{
	CanPlay                                  = 0,
	CanPlayOnline                            = 1,
	CanCommunicateOnline                     = 2,
	CanUseUserGeneratedContent               = 3,
	CanUserCrossPlay                         = 4,
	EBlueprintableUserPrivileges_MAX         = 5,
};

// Enum FSD.EActivityType
// NumValues: 0x0005
enum class EActivityType : uint8
{
	Mission                                  = 0,
	Assignment                               = 1,
	Tutorial                                 = 2,
	None                                     = 3,
	EActivityType_MAX                        = 4,
};

// Enum FSD.EMeshAttachType
// NumValues: 0x0003
enum class EMeshAttachType : uint8
{
	ECharacterMesh                           = 0,
	ECamera                                  = 1,
	EMeshAttachType_MAX                      = 2,
};

// Enum FSD.EAfflictionSocket
// NumValues: 0x0004
enum class EAfflictionSocket : uint8
{
	CenterMass                               = 0,
	Feet                                     = 1,
	Camera                                   = 2,
	EAfflictionSocket_MAX                    = 3,
};

// Enum FSD.ECreatureSize
// NumValues: 0x0006
enum class ECreatureSize : uint32
{
	Tiny                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Large                                    = 3,
	Huge                                     = 4,
	ECreatureSize_MAX                        = 5,
};

// Enum FSD.EFrozenAfflictionType
// NumValues: 0x0003
enum class EFrozenAfflictionType : uint8
{
	Frozen                                   = 0,
	Infected                                 = 1,
	EFrozenAfflictionType_MAX                = 2,
};

// Enum FSD.EFlyingBugDeathAnimationCategory
// NumValues: 0x0003
enum class EFlyingBugDeathAnimationCategory : uint8
{
	NoAnimation                              = 0,
	IdleOnDeath                              = 1,
	EFlyingBugDeathAnimationCategory_MAX     = 2,
};

// Enum FSD.EAsyncPersistence
// NumValues: 0x0004
enum class EAsyncPersistence : uint8
{
	Manual                                   = 0,
	Level                                    = 1,
	Permanent                                = 2,
	EAsyncPersistence_MAX                    = 3,
};

// Enum FSD.EAbilityIndex
// NumValues: 0x0004
enum class EAbilityIndex : uint8
{
	ENone                                    = 0,
	EPrimary                                 = 1,
	ESecondary                               = 2,
	EAbilityIndex_MAX                        = 3,
};

// Enum FSD.EBoomerangState
// NumValues: 0x0005
enum class EBoomerangState : uint8
{
	None                                     = 0,
	Curving                                  = 1,
	GoingBack                                = 2,
	Targeting                                = 3,
	EBoomerangState_MAX                      = 4,
};

// Enum FSD.EPlatformRestriction
// NumValues: 0x0007
enum class EPlatformRestriction : uint8
{
	Editor                                   = 0,
	Steam                                    = 1,
	Oddish                                   = 2,
	UniversalWindowsPlatform                 = 3,
	XBoxOne                                  = 4,
	PS4                                      = 5,
	EPlatformRestriction_MAX                 = 6,
};

// Enum FSD.EBuildTypeRestriction
// NumValues: 0x0003
enum class EBuildTypeRestriction : uint8
{
	Development                              = 0,
	Shipping                                 = 1,
	EBuildTypeRestriction_MAX                = 2,
};

// Enum FSD.ECampaignMutators
// NumValues: 0x0004
enum class ECampaignMutators : uint32
{
	NotAllowed                               = 0,
	Allowed                                  = 1,
	Preffered                                = 2,
	ECampaignMutators_MAX                    = 3,
};

// Enum FSD.ECaretakerSpawnType
// NumValues: 0x0006
enum class ECaretakerSpawnType : uint8
{
	None                                     = 0,
	Drones                                   = 1,
	Bombs                                    = 2,
	Shredders                                = 3,
	Turrets                                  = 4,
	ECaretakerSpawnType_MAX                  = 5,
};

// Enum FSD.EFacilityEye
// NumValues: 0x0005
enum class EFacilityEye : uint8
{
	EForward                                 = 0,
	EBack                                    = 1,
	ELeft                                    = 2,
	ERight                                   = 3,
	EFacilityEye_MAX                         = 4,
};

// Enum FSD.ECellCategory
// NumValues: 0x0003
enum class ECellCategory : uint8
{
	Cave                                     = 0,
	Tunnel                                   = 1,
	ECellCategory_MAX                        = 255,
};

// Enum FSD.ECaveLeechState
// NumValues: 0x0008
enum class ECaveLeechState : uint8
{
	Idle                                     = 0,
	Tracking                                 = 1,
	Pulling                                  = 2,
	Retracting                               = 3,
	Dying                                    = 4,
	Dead                                     = 5,
	Frozen                                   = 6,
	ECaveLeechState_MAX                      = 7,
};

// Enum FSD.ECustomUsableType
// NumValues: 0x0004
enum class ECustomUsableType : uint8
{
	ClearOnFrameEnd                          = 0,
	ClearOnUseReleased                       = 1,
	ClearManually                            = 2,
	ECustomUsableType_MAX                    = 3,
};

// Enum FSD.EExampleEnum
// NumValues: 0x0003
enum class EExampleEnum : uint8
{
	FirstName                                = 0,
	SecondName                               = 1,
	EExampleEnum_MAX                         = 2,
};

// Enum FSD.ECoilgunTraceEffect
// NumValues: 0x0004
enum class ECoilgunTraceEffect : uint8
{
	EPrimary                                 = 0,
	EDamage                                  = 1,
	EFear                                    = 2,
	ECoilgunTraceEffect_MAX                  = 3,
};

// Enum FSD.ECommunityGoalIndex
// NumValues: 0x000F
enum class ECommunityGoalIndex : uint8
{
	KillBroodNexus                           = 0,
	KillBulkDetonators                       = 1,
	KillCaveLeeches                          = 2,
	KillJellyBreeders                        = 3,
	KillPretorians                           = 4,
	KillShellbacks                           = 5,
	KillSpitballers                          = 6,
	CollectBittergem                         = 7,
	CollectCompressedGold                    = 8,
	CollectGold                              = 9,
	CollectCraftingMaterials                 = 10,
	GainXP                                   = 11,
	TestGoal                                 = 12,
	Count                                    = 13,
	ECommunityGoalIndex_MAX                  = 14,
};

// Enum FSD.ECommunityGoalTier
// NumValues: 0x0004
enum class ECommunityGoalTier : uint8
{
	Bronze                                   = 0,
	Silver                                   = 1,
	Gold                                     = 2,
	ECommunityGoalTier_MAX                   = 3,
};

// Enum FSD.ECommunityGoalType
// NumValues: 0x0005
enum class ECommunityGoalType : uint8
{
	Float                                    = 0,
	Integer                                  = 1,
	Time                                     = 2,
	Distance                                 = 3,
	ECommunityGoalType_MAX                   = 4,
};

// Enum FSD.ECommunityUIState
// NumValues: 0x0007
enum class ECommunityUIState : uint8
{
	Loading                                  = 0,
	SelectFaction                            = 1,
	Progress                                 = 2,
	Recruitment                              = 3,
	Reward                                   = 4,
	Invalid                                  = 5,
	ECommunityUIState_MAX                    = 6,
};

// Enum FSD.ERobotState
// NumValues: 0x0004
enum class ERobotState : uint8
{
	Enemy                                    = 0,
	Friendly                                 = 1,
	PoweredDown                              = 2,
	ERobotState_MAX                          = 3,
};

// Enum FSD.ECrossbowStuckType
// NumValues: 0x0005
enum class ECrossbowStuckType : uint8
{
	Default                                  = 0,
	Electric                                 = 1,
	Chemical                                 = 2,
	Banshee                                  = 3,
	ECrossbowStuckType_MAX                   = 4,
};

// Enum FSD.EKeyBindingAxis
// NumValues: 0x0004
enum class EKeyBindingAxis : uint8
{
	None                                     = 0,
	Positive                                 = 1,
	Negative                                 = 2,
	EKeyBindingAxis_MAX                      = 3,
};

// Enum FSD.EDealType
// NumValues: 0x0003
enum class EDealType : uint8
{
	Buy                                      = 0,
	Sell                                     = 1,
	EDealType_MAX                            = 2,
};

// Enum FSD.EPlasmaCarbineConditions
// NumValues: 0x0002
enum class EPlasmaCarbineConditions : uint8
{
	ShieldRemovedOnReload                    = 0,
	EPlasmaCarbineConditions_MAX             = 1,
};

// Enum FSD.EBoltActionWeaponConditions
// NumValues: 0x0003
enum class EBoltActionWeaponConditions : uint8
{
	WasAimedShot                             = 0,
	WasNormalShot                            = 1,
	EBoltActionWeaponConditions_MAX          = 2,
};

// Enum FSD.EDirectDamageConditionEnum
// NumValues: 0x0003
enum class EDirectDamageConditionEnum : uint8
{
	Direct                                   = 0,
	Radial                                   = 1,
	EDirectDamageConditionEnum_MAX           = 2,
};

// Enum FSD.EImpulseDirectionSource
// NumValues: 0x0006
enum class EImpulseDirectionSource : uint8
{
	SourceForward                            = 0,
	SourceToTarget                           = 1,
	PlayerToTarget                           = 2,
	TargetUp                                 = 3,
	TargetRandomOnPlane                      = 4,
	EImpulseDirectionSource_MAX              = 5,
};

// Enum FSD.EDamageUpgrade
// NumValues: 0x000E
enum class EDamageUpgrade : uint8
{
	Damage                                   = 0,
	WeakpointDamageMultiplier                = 1,
	StaggerChance                            = 2,
	StaggerDuration                          = 3,
	RadialDamage                             = 4,
	RadialRange                              = 5,
	ArmorDamageMultiplier                    = 6,
	FearFactor                               = 7,
	RadialRangeMultiplier                    = 8,
	StaggerOnWeakpointOnly                   = 9,
	FriendlyFireModifier                     = 10,
	ShattersArmor                            = 11,
	ArmorPenetration                         = 12,
	EDamageUpgrade_MAX                       = 13,
};

// Enum FSD.EDamageComponentType
// NumValues: 0x0007
enum class EDamageComponentType : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	Tertiary                                 = 2,
	Quaternary                               = 3,
	Quinary                                  = 4,
	Any                                      = 5,
	EDamageComponentType_MAX                 = 6,
};

// Enum FSD.EDashPointsGenerationMode
// NumValues: 0x0003
enum class EDashPointsGenerationMode : uint8
{
	Surround                                 = 0,
	Forward                                  = 1,
	EDashPointsGenerationMode_MAX            = 2,
};

// Enum FSD.EDebrisOrientation
// NumValues: 0x0005
enum class EDebrisOrientation : uint8
{
	Random                                   = 0,
	RandomXY                                 = 1,
	AlignToSurfaceNormal                     = 2,
	Fixed                                    = 3,
	EDebrisOrientation_MAX                   = 4,
};

// Enum FSD.ESpecialDebrisType
// NumValues: 0x0004
enum class ESpecialDebrisType : uint8
{
	None                                     = 0,
	Plague                                   = 1,
	LitPlague                                = 2,
	ESpecialDebrisType_MAX                   = 3,
};

// Enum FSD.EDebrisMeshShadows
// NumValues: 0x0004
enum class EDebrisMeshShadows : uint8
{
	Never                                    = 0,
	High                                     = 1,
	Always                                   = 2,
	EDebrisMeshShadows_MAX                   = 3,
};

// Enum FSD.EDebrisMeshCollisionProfile
// NumValues: 0x0004
enum class EDebrisMeshCollisionProfile : uint8
{
	NoCollision                              = 0,
	HitOnly                                  = 1,
	HitAndCollide                            = 2,
	EDebrisMeshCollisionProfile_MAX          = 3,
};

// Enum FSD.EDebrisColliderType
// NumValues: 0x0005
enum class EDebrisColliderType : uint8
{
	Object                                   = 0,
	AirParticles                             = 1,
	ObjectB                                  = 2,
	ObjectC                                  = 3,
	EDebrisColliderType_MAX                  = 4,
};

// Enum FSD.EDebrisCarvedType
// NumValues: 0x0005
enum class EDebrisCarvedType : uint8
{
	Large                                    = 0,
	Small                                    = 1,
	LevelGeneration                          = 2,
	Resources                                = 3,
	EDebrisCarvedType_MAX                    = 4,
};

// Enum FSD.EDebrisItemPass
// NumValues: 0x0004
enum class EDebrisItemPass : uint8
{
	PrePlacement                             = 0,
	Plague                                   = 1,
	Main                                     = 2,
	EDebrisItemPass_MAX                      = 3,
};

// Enum FSD.EDecalImportance
// NumValues: 0x0004
enum class EDecalImportance : uint8
{
	High                                     = 0,
	Normal                                   = 1,
	Low                                      = 2,
	EDecalImportance_MAX                     = 3,
};

// Enum FSD.ELandscapeCellFilter
// NumValues: 0x000A
enum class ELandscapeCellFilter : uint8
{
	Any                                      = 0,
	Empty                                    = 1,
	Filled                                   = 2,
	Diggable                                 = 3,
	NotDiggable                              = 4,
	Collidable                               = 5,
	NotCollidable                            = 6,
	Rubble                                   = 7,
	NotRubble                                = 8,
	ELandscapeCellFilter_MAX                 = 9,
};

// Enum FSD.EOffsetFrom
// NumValues: 0x0004
enum class EOffsetFrom : uint8
{
	None                                     = 0,
	Floor                                    = 1,
	Ceiling                                  = 2,
	EOffsetFrom_MAX                          = 3,
};

// Enum FSD.EDeepMovementMode
// NumValues: 0x0005
enum class EDeepMovementMode : uint8
{
	Normal                                   = 0,
	Flee                                     = 1,
	Fly                                      = 2,
	BackOff                                  = 3,
	EDeepMovementMode_MAX                    = 4,
};

// Enum FSD.EDefendPointState
// NumValues: 0x0005
enum class EDefendPointState : uint8
{
	Idle                                     = 0,
	Started                                  = 1,
	Completed                                = 2,
	Failed                                   = 3,
	EDefendPointState_MAX                    = 4,
};

// Enum FSD.EDialogRestriction
// NumValues: 0x0004
enum class EDialogRestriction : uint8
{
	None                                     = 0,
	SinglePlayerOnly                         = 1,
	MultiPlayerOnly                          = 2,
	EDialogRestriction_MAX                   = 3,
};

// Enum FSD.EVeteranScaling
// NumValues: 0x0003
enum class EVeteranScaling : uint8
{
	NormalEnemy                              = 0,
	LargeEnemy                               = 1,
	EVeteranScaling_MAX                      = 2,
};

// Enum FSD.EEnemySignificance
// NumValues: 0x0005
enum class EEnemySignificance : uint8
{
	Swarmer                                  = 0,
	Normal                                   = 1,
	Critical                                 = 2,
	Critter                                  = 3,
	EEnemySignificance_MAX                   = 4,
};

// Enum FSD.EDiscordBiomeType
// NumValues: 0x000D
enum class EDiscordBiomeType : uint8
{
	CrystallineCaverns                       = 0,
	FungusBogs                               = 1,
	GlacialStrata                            = 2,
	DenseBiozone                             = 3,
	MagmaCore                                = 4,
	Radioactive                              = 5,
	SaltPits                                 = 6,
	Sandblasted                              = 7,
	CausticMire                              = 8,
	AzureWeald                               = 9,
	HollowBough                              = 10,
	Spacerig                                 = 11,
	EDiscordBiomeType_MAX                    = 12,
};

// Enum FSD.EDiscordMissionType
// NumValues: 0x0009
enum class EDiscordMissionType : uint8
{
	MiningExpedition                         = 0,
	EggHunt                                  = 1,
	Escort                                   = 2,
	Elimination                              = 3,
	PointExtraction                          = 4,
	Salvage                                  = 5,
	Refinery                                 = 6,
	None                                     = 7,
	EDiscordMissionType_MAX                  = 8,
};

// Enum FSD.EDoubleDrillState
// NumValues: 0x0006
enum class EDoubleDrillState : uint8
{
	Equipping                                = 0,
	Idle                                     = 1,
	Mining                                   = 2,
	Overheated                               = 3,
	OutOfFuel                                = 4,
	EDoubleDrillState_MAX                    = 5,
};

// Enum FSD.EBoscoAbillityTargetPreference
// NumValues: 0x0006
enum class EBoscoAbillityTargetPreference : uint8
{
	Self                                     = 0,
	SelectedTarget                           = 1,
	ClosestPlayer                            = 2,
	ClosestEnemy                             = 3,
	TargetLocation                           = 4,
	EBoscoAbillityTargetPreference_MAX       = 5,
};

// Enum FSD.EDroneActions
// NumValues: 0x0006
enum class EDroneActions : uint8
{
	Wandering                                = 0,
	Mining                                   = 1,
	Fighting                                 = 2,
	Lighting                                 = 3,
	Reviving                                 = 4,
	EDroneActions_MAX                        = 5,
};

// Enum FSD.EDynamicReverbSetting
// NumValues: 0x0005
enum class EDynamicReverbSetting : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Large                                    = 3,
	EDynamicReverbSetting_MAX                = 4,
};

// Enum FSD.EEnemyControlState
// NumValues: 0x0006
enum class EEnemyControlState : uint8
{
	Connecting                               = 0,
	Connected                                = 1,
	ThrowingOff                              = 2,
	Disconnecting                            = 3,
	Disconneced                              = 4,
	EEnemyControlState_MAX                   = 5,
};

// Enum FSD.EEnemyDescriptorCheatClass
// NumValues: 0x0007
enum class EEnemyDescriptorCheatClass : uint8
{
	Hidden                                   = 0,
	Basic                                    = 1,
	Advanced                                 = 2,
	Mactera                                  = 3,
	Specials                                 = 4,
	Boss                                     = 5,
	EEnemyDescriptorCheatClass_MAX           = 6,
};

// Enum FSD.EEnemyType
// NumValues: 0x0005
enum class EEnemyType : uint8
{
	Ground                                   = 0,
	Flying                                   = 1,
	GroundAndFlying                          = 2,
	Stationary                               = 3,
	EEnemyType_MAX                           = 4,
};

// Enum FSD.EEnemyFamily
// NumValues: 0x000D
enum class EEnemyFamily : uint8
{
	Glyphid                                  = 0,
	Mactera                                  = 1,
	Naedocyte                                = 2,
	Qronar                                   = 3,
	Xynarch                                  = 4,
	Nayaka                                   = 5,
	Deeptora                                 = 6,
	Korlok                                   = 7,
	Automaton                                = 8,
	Unknown                                  = 9,
	RivalTech                                = 10,
	Lithophage                               = 11,
	EEnemyFamily_MAX                         = 12,
};

// Enum FSD.EEscortExtractorState
// NumValues: 0x0004
enum class EEscortExtractorState : uint8
{
	ReadyToGrab                              = 0,
	Taken                                    = 1,
	Full                                     = 2,
	EEscortExtractorState_MAX                = 3,
};

// Enum FSD.EEscortMissionState
// NumValues: 0x0009
enum class EEscortMissionState : uint8
{
	Stationary                               = 0,
	Moving                                   = 1,
	WaitingForFuel                           = 2,
	FinalEvent                               = 3,
	Finished                                 = 4,
	ShellCracked                             = 5,
	VehicleDead                              = 6,
	InGarage                                 = 7,
	EEscortMissionState_MAX                  = 8,
};

// Enum FSD.EExtractorState
// NumValues: 0x0006
enum class EExtractorState : uint8
{
	Attached                                 = 0,
	OnGround                                 = 1,
	Equipping                                = 2,
	Idle                                     = 3,
	Mining                                   = 4,
	EExtractorState_MAX                      = 5,
};

// Enum FSD.EFacilityTentacleState
// NumValues: 0x0005
enum class EFacilityTentacleState : uint8
{
	Idle                                     = 0,
	HasTarget                                = 1,
	Melee                                    = 2,
	Ranged                                   = 3,
	EFacilityTentacleState_MAX               = 4,
};

// Enum FSD.EIndicatorMode
// NumValues: 0x0004
enum class EIndicatorMode : uint8
{
	EConstant                                = 0,
	EFlashing                                = 1,
	EOff                                     = 2,
	EIndicatorMode_MAX                       = 3,
};

// Enum FSD.EFSDAchievementType
// NumValues: 0x0005
enum class EFSDAchievementType : uint8
{
	NoStatUsed                               = 0,
	IncrementStatPerCall                     = 1,
	SetStatIfHighscore                       = 2,
	ForceNewStatEachCall                     = 3,
	EFSDAchievementType_MAX                  = 4,
};

// Enum FSD.ETargetStateDamageBonusType
// NumValues: 0x0005
enum class ETargetStateDamageBonusType : uint8
{
	Frozen                                   = 0,
	OnFire                                   = 1,
	Fleeing                                  = 2,
	Staggered                                = 3,
	ETargetStateDamageBonusType_MAX          = 4,
};

// Enum FSD.EPauseReason
// NumValues: 0x0004
enum class EPauseReason : uint8
{
	Invalid                                  = 0,
	MenuActive                               = 1,
	ReconnectController                      = 2,
	EPauseReason_MAX                         = 3,
};

// Enum FSD.ESaveSlotChangeProcedure
// NumValues: 0x0005
enum class ESaveSlotChangeProcedure : uint8
{
	NewSave                                  = 0,
	Load                                     = 1,
	Save                                     = 2,
	NewModdedSave                            = 3,
	ESaveSlotChangeProcedure_MAX             = 4,
};

// Enum FSD.ENVidiaReflexMode
// NumValues: 0x0004
enum class ENVidiaReflexMode : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	EnabledWithBoost                         = 2,
	ENVidiaReflexMode_MAX                    = 3,
};

// Enum FSD.EVolumeType
// NumValues: 0x0007
enum class EVolumeType : uint8
{
	CharacterVoices                          = 0,
	Master                                   = 1,
	SFX                                      = 2,
	Music                                    = 3,
	VoiceChat                                = 4,
	MissionControl                           = 5,
	EVolumeType_MAX                          = 6,
};

// Enum FSD.EInviteBlockReason
// NumValues: 0x0007
enum class EInviteBlockReason : uint8
{
	SoloSession                              = 0,
	ActiveDeepDive                           = 1,
	Tutorial                                 = 2,
	OnlinePlayBlocked                        = 3,
	IsClient                                 = 4,
	None                                     = 5,
	EInviteBlockReason_MAX                   = 6,
};

// Enum FSD.EPostProcessingType
// NumValues: 0x0003
enum class EPostProcessingType : uint8
{
	GameWorld                                = 0,
	CharacterSelector                        = 1,
	EPostProcessingType_MAX                  = 2,
};

// Enum FSD.EItemNotificationType
// NumValues: 0x0002
enum class EItemNotificationType : uint8
{
	NewOverclock                             = 0,
	EItemNotificationType_MAX                = 1,
};

// Enum FSD.ESteamBranch
// NumValues: 0x0005
enum class ESteamBranch : uint8
{
	Main                                     = 0,
	Experimental                             = 1,
	Internal_Testing                         = 2,
	Other                                    = 3,
	ESteamBranch_MAX                         = 4,
};

// Enum FSD.EFSDTargetPlatform
// NumValues: 0x0006
enum class EFSDTargetPlatform : uint8
{
	Steam                                    = 0,
	XboxOne                                  = 1,
	Win10                                    = 2,
	PS4                                      = 3,
	PS5                                      = 4,
	EFSDTargetPlatform_MAX                   = 5,
};

// Enum FSD.EMoveType
// NumValues: 0x0003
enum class EMoveType : uint8
{
	EaseIn                                   = 0,
	EaseOut                                  = 1,
	EMoveType_MAX                            = 2,
};

// Enum FSD.EPingType
// NumValues: 0x0003
enum class EPingType : uint8
{
	EaseOut                                  = 0,
	Bounce                                   = 1,
	EPingType_MAX                            = 2,
};

// Enum FSD.EFSDGoogleAnalyticsProperties
// NumValues: 0x0007
enum class EFSDGoogleAnalyticsProperties : uint8
{
	DRG                                      = 0,
	Discord                                  = 1,
	CommunityGoals                           = 2,
	DRG_Discord                              = 3,
	All                                      = 4,
	Other                                    = 5,
	EFSDGoogleAnalyticsProperties_MAX        = 6,
};

// Enum FSD.EGrabberState
// NumValues: 0x0005
enum class EGrabberState : uint8
{
	StandBy                                  = 0,
	Chase                                    = 1,
	Carry                                    = 2,
	Flee                                     = 3,
	EGrabberState_MAX                        = 4,
};

// Enum FSD.EGrabbedStateCameraMode
// NumValues: 0x0003
enum class EGrabbedStateCameraMode : uint8
{
	FirstPerson                              = 0,
	ThirdPerson                              = 1,
	EGrabbedStateCameraMode_MAX              = 2,
};

// Enum FSD.EGuntowerModuleState
// NumValues: 0x0005
enum class EGuntowerModuleState : uint8
{
	EDormant                                 = 0,
	EActive                                  = 1,
	EVulnerable                              = 2,
	EDestoyed                                = 3,
	EGuntowerModuleState_MAX                 = 4,
};

// Enum FSD.ERicochetBehavior
// NumValues: 0x0004
enum class ERicochetBehavior : uint8
{
	All                                      = 0,
	PawnsOnly                                = 1,
	NotPawns                                 = 2,
	ERicochetBehavior_MAX                    = 3,
};

// Enum FSD.EGeneratorIconType
// NumValues: 0x0005
enum class EGeneratorIconType : uint8
{
	Vanity                                   = 0,
	PickaxePart                              = 1,
	PickaxeSet                               = 2,
	WeaponSkin                               = 3,
	EGeneratorIconType_MAX                   = 4,
};

// Enum FSD.EKeyBindingSlot
// NumValues: 0x0003
enum class EKeyBindingSlot : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	EKeyBindingSlot_MAX                      = 2,
};

// Enum FSD.EInputInteraction
// NumValues: 0x0003
enum class EInputInteraction : uint8
{
	Press                                    = 0,
	Hold                                     = 1,
	EInputInteraction_MAX                    = 2,
};

// Enum FSD.EWeaponMaintenanceState
// NumValues: 0x0005
enum class EWeaponMaintenanceState : uint8
{
	Locked                                   = 0,
	Maintaining                              = 1,
	LevelUp                                  = 2,
	Finished                                 = 3,
	EWeaponMaintenanceState_MAX              = 4,
};

// Enum FSD.EItemSkinCollectionType
// NumValues: 0x0003
enum class EItemSkinCollectionType : uint8
{
	PerCharacter                             = 0,
	PerItem                                  = 1,
	EItemSkinCollectionType_MAX              = 2,
};

// Enum FSD.EMicrowaveGunUpgrade
// NumValues: 0x000C
enum class EMicrowaveGunUpgrade : uint8
{
	ESlowOnHit                               = 0,
	EFocusLense                              = 1,
	EWideLense                               = 2,
	ESpreadFire                              = 3,
	ESpreadNeuro                             = 4,
	EKilledTargetsExplodeChance              = 5,
	ERadiantSuperheater                      = 6,
	EHeatsink                                = 7,
	BlisteringNecrosis                       = 8,
	EGammaContaminationZone                  = 9,
	ETemperatureAmplifier                    = 10,
	EMicrowaveGunUpgrade_MAX                 = 11,
};

// Enum FSD.ECapsuleHitscanUpgradeType
// NumValues: 0x0003
enum class ECapsuleHitscanUpgradeType : uint8
{
	ShotWidth                                = 0,
	PenetrateEnemies                         = 1,
	ECapsuleHitscanUpgradeType_MAX           = 2,
};

// Enum FSD.EHeavyParticleCannonUpgrade
// NumValues: 0x0009
enum class EHeavyParticleCannonUpgrade : uint8
{
	ReloadOnButtonRelease                    = 0,
	BoosterModule                            = 1,
	KillAddsAmmo                             = 2,
	RadialDamageIncPerSecond                 = 3,
	RadialRangeIncPerSecond                  = 4,
	BulkyBeam                                = 5,
	ProjectionModule                         = 6,
	PlatformExplosions                       = 7,
	EHeavyParticleCannonUpgrade_MAX          = 8,
};

// Enum FSD.ECrossbowUpgrades
// NumValues: 0x0017
enum class ECrossbowUpgrades : uint8
{
	SpecialArrowPheramone                    = 0,
	SpecialArrowTaser                        = 1,
	SpecialArrowChemical                     = 2,
	BansheeModule                            = 3,
	Magnetic                                 = 4,
	RadioModule                              = 5,
	Ricochet                                 = 6,
	VelocityChange                           = 7,
	DamageDefault                            = 8,
	RadialDamageDefault                      = 9,
	Trifork                                  = 10,
	Pentafork                                = 11,
	BattleFrenzy                             = 12,
	IncreaseSpecialAmmo                      = 13,
	IncreaseSpecialAmmoPercent               = 14,
	SuperFast                                = 15,
	IncreaseSpecialEffectDuration            = 16,
	FasterSwitch                             = 17,
	CryoArrow                                = 18,
	FireArrow                                = 19,
	ReloadTimeDefaultArrow                   = 20,
	RateOfFireDefaultArrow                   = 21,
	ECrossbowUpgrades_MAX                    = 22,
};

// Enum FSD.EPlasmaCarbineUpgrades
// NumValues: 0x0004
enum class EPlasmaCarbineUpgrades : uint8
{
	RateOfFireBoostOnFullShield              = 0,
	RemoveShieldOnOverheat                   = 1,
	RemoveShieldOnReload                     = 2,
	EPlasmaCarbineUpgrades_MAX               = 3,
};

// Enum FSD.ELockOnWeaponUpgrades
// NumValues: 0x000F
enum class ELockOnWeaponUpgrades : uint8
{
	MaxLockOnDegree                          = 0,
	TimeBetweenLockedShots                   = 1,
	LockOnTime                               = 2,
	MaxTargets                               = 3,
	LoseLockOnDegree                         = 4,
	MaxLockOnRange                           = 5,
	PrioritizeLowHitpoint                    = 6,
	AlwaysHitTarget                          = 7,
	MaxLockOnDuration                        = 8,
	LockOnControlsSentryGun                  = 9,
	AoeHitCountThreshhold                    = 10,
	SentryGunShootsOnLockedShot              = 11,
	UseLockOnTargetStatusEffect              = 12,
	FearEnabled                              = 13,
	ELockOnWeaponUpgrades_MAX                = 14,
};

// Enum FSD.EGooGunProjectileUpgrades
// NumValues: 0x0003
enum class EGooGunProjectileUpgrades : uint8
{
	PuddleLifeSpan                           = 0,
	FragmentCount                            = 1,
	EGooGunProjectileUpgrades_MAX            = 2,
};

// Enum FSD.EGooGunUpgrades
// NumValues: 0x0006
enum class EGooGunUpgrades : uint8
{
	ChargeFire                               = 0,
	BurstFire                                = 1,
	ShotCostCharged                          = 2,
	ChargeTime                               = 3,
	ChargeShotCount                          = 4,
	EGooGunUpgrades_MAX                      = 5,
};

// Enum FSD.EMicroMissileLauncherUpgrades
// NumValues: 0x0006
enum class EMicroMissileLauncherUpgrades : uint8
{
	ChargeFire                               = 0,
	BuckFire                                 = 1,
	DisableHomingOnRelease                   = 2,
	ShotDirectionHorizontalDegreeOffset      = 3,
	ShotDirectionVerticleDegreeOffset        = 4,
	EMicroMissileLauncherUpgrades_MAX        = 5,
};

// Enum FSD.EProjectileLauncherBaseUpgradeType
// NumValues: 0x0005
enum class EProjectileLauncherBaseUpgradeType : uint8
{
	VerticalSpread                           = 0,
	HorizontalSpread                         = 1,
	TransferVelocityFromCharacter            = 2,
	ArcStartAngle                            = 3,
	EProjectileLauncherBaseUpgradeType_MAX   = 4,
};

// Enum FSD.EDetPackUpgrades
// NumValues: 0x0006
enum class EDetPackUpgrades : uint8
{
	CanPickUp                                = 0,
	CarveDiameter                            = 1,
	ExplodeOnDeath                           = 2,
	ExtraFearRadius                          = 3,
	ExtraStaggerRadius                       = 4,
	EDetPackUpgrades_MAX                     = 5,
};

// Enum FSD.EPlatformGunUpgrades
// NumValues: 0x0005
enum class EPlatformGunUpgrades : uint8
{
	BiggerPlatform                           = 0,
	LessFallDamage                           = 1,
	BugRepellant                             = 2,
	CubePlatform                             = 3,
	EPlatformGunUpgrades_MAX                 = 4,
};

// Enum FSD.EBoscoUpgrades
// NumValues: 0x0008
enum class EBoscoUpgrades : uint8
{
	MiningSpeedUpgrade                       = 0,
	ExtraRevive                              = 1,
	ActiveLightRadius                        = 2,
	Missile                                  = 3,
	CryoGrenade                              = 4,
	SACooldownReduction                      = 5,
	ExtraAbillityCharge                      = 6,
	EBoscoUpgrades_MAX                       = 7,
};

// Enum FSD.EArmorUpgradeType
// NumValues: 0x0004
enum class EArmorUpgradeType : uint8
{
	RegenDelay                               = 0,
	RegenRate                                = 1,
	ReviveInvulnerability                    = 2,
	EArmorUpgradeType_MAX                    = 3,
};

// Enum FSD.ETriggeredStatusEffectType
// NumValues: 0x0004
enum class ETriggeredStatusEffectType : uint8
{
	ShieldDestroyed                          = 0,
	GrapplingHookReleased                    = 1,
	NONE                                     = 2,
	ETriggeredStatusEffectType_MAX           = 3,
};

// Enum FSD.EShieldGeneratorUpgrades
// NumValues: 0x0007
enum class EShieldGeneratorUpgrades : uint8
{
	Radius                                   = 0,
	Duration                                 = 1,
	DeployTime                               = 2,
	RechargeTime                             = 3,
	RechargeCount                            = 4,
	PushStatusEffect                         = 5,
	EShieldGeneratorUpgrades_MAX             = 6,
};

// Enum FSD.ESentryGunUpgradeType
// NumValues: 0x0009
enum class ESentryGunUpgradeType : uint8
{
	MaxAmmo                                  = 0,
	ReloadSpeed                              = 1,
	ExtraSentry                              = 2,
	AngleRestriction                         = 3,
	ManualTargeting                          = 4,
	MaxRange                                 = 5,
	RotationSpeed                            = 6,
	BurstCooldown                            = 7,
	ESentryGunUpgradeType_MAX                = 8,
};

// Enum FSD.EGrapplingHookUpgrade
// NumValues: 0x0004
enum class EGrapplingHookUpgrade : uint8
{
	MaxDistance                              = 0,
	MaxSpeed                                 = 1,
	WindUpTime                               = 2,
	EGrapplingHookUpgrade_MAX                = 3,
};

// Enum FSD.EZiplineGunUpgrades
// NumValues: 0x0005
enum class EZiplineGunUpgrades : uint8
{
	MaxAngle                                 = 0,
	MaxDistance                              = 1,
	MovementSpeed                            = 2,
	FallDamageReduction                      = 3,
	EZiplineGunUpgrades_MAX                  = 4,
};

// Enum FSD.EElectricalSMGUpgrades
// NumValues: 0x0004
enum class EElectricalSMGUpgrades : uint8
{
	AoEChance                                = 0,
	PlasmaBeam                               = 1,
	TurretEMPDischarge                       = 2,
	EElectricalSMGUpgrades_MAX               = 3,
};

// Enum FSD.EChargedProjectileUpgrades
// NumValues: 0x0004
enum class EChargedProjectileUpgrades : uint8
{
	ExplodesOnDamage                         = 0,
	AoEDamageInFlight                        = 1,
	PersistentExplosion                      = 2,
	EChargedProjectileUpgrades_MAX           = 3,
};

// Enum FSD.EFlaregunProjectileUpgrades
// NumValues: 0x0002
enum class EFlaregunProjectileUpgrades : uint8
{
	Duration                                 = 0,
	EFlaregunProjectileUpgrades_MAX          = 1,
};

// Enum FSD.EFlaregunUpgrades
// NumValues: 0x0002
enum class EFlaregunUpgrades : uint8
{
	AutoReload                               = 0,
	EFlaregunUpgrades_MAX                    = 1,
};

// Enum FSD.EProjectileUpgrade
// NumValues: 0x000F
enum class EProjectileUpgrade : uint8
{
	Velocity                                 = 0,
	MaxVelocity                              = 1,
	Bouncy                                   = 2,
	Lifetime                                 = 3,
	DoOnImpact                               = 4,
	DoOnImpact2                              = 5,
	DoOnImpact3                              = 6,
	DoOnSpawn                                = 7,
	HomingStrength                           = 8,
	SetInitialSpeedToMaxSpeed                = 9,
	AccelerationMultiplier                   = 10,
	MaxPropulsionTime                        = 11,
	GravityScale                             = 12,
	CustomEvent                              = 13,
	EProjectileUpgrade_MAX                   = 14,
};

// Enum FSD.ELineCutterProjectileUpgradeType
// NumValues: 0x000E
enum class ELineCutterProjectileUpgradeType : uint8
{
	LineSize                                 = 0,
	LineSizeMultiplier                       = 1,
	ExplosiveRound                           = 2,
	SetDeployDelay                           = 3,
	AddDeployTime                            = 4,
	ExplodeOnNextProjectile                  = 5,
	DoubleLine                               = 6,
	LineSizeAdd                              = 7,
	SetDeployTime                            = 8,
	RollUntilStop                            = 9,
	Yawing                                   = 10,
	PlasmaTrail                              = 11,
	Homing                                   = 12,
	ELineCutterProjectileUpgradeType_MAX     = 13,
};

// Enum FSD.ELineCutterUpgradeType
// NumValues: 0x0003
enum class ELineCutterUpgradeType : uint8
{
	ReverseDirection                         = 0,
	ExplodeLastProjectile                    = 1,
	ELineCutterUpgradeType_MAX               = 2,
};

// Enum FSD.EGrenadeUpgradeType
// NumValues: 0x0003
enum class EGrenadeUpgradeType : uint8
{
	MaxGrenades                              = 0,
	FuseTime                                 = 1,
	EGrenadeUpgradeType_MAX                  = 2,
};

// Enum FSD.EFlareUpgradeType
// NumValues: 0x0004
enum class EFlareUpgradeType : uint8
{
	Duration                                 = 0,
	MaxFlares                                = 1,
	ProductionTime                           = 2,
	EFlareUpgradeType_MAX                    = 3,
};

// Enum FSD.ESingleUsableUpgradeType
// NumValues: 0x0002
enum class ESingleUsableUpgradeType : uint8
{
	UseDuration                              = 0,
	ESingleUsableUpgradeType_MAX             = 1,
};

// Enum FSD.EModifyStatusEffectDamageUpgrade
// NumValues: 0x0002
enum class EModifyStatusEffectDamageUpgrade : uint8
{
	Duration                                 = 0,
	EModifyStatusEffectDamageUpgrade_MAX     = 1,
};

// Enum FSD.EHitScanBaseUpgradeType
// NumValues: 0x000F
enum class EHitScanBaseUpgradeType : uint8
{
	MaxVerticalSpread                        = 0,
	MaxHorizontalSpread                      = 1,
	MaxPenetrations                          = 2,
	WeaponAccuracySpreadMultiplier           = 3,
	SpreadPerShot                            = 4,
	MinSpreadWhileMoving                     = 5,
	SpreadRecoveryMultiplier                 = 6,
	MinSpreadWhileSprinting                  = 7,
	MaxSpread                                = 8,
	RicochetChance                           = 9,
	RicochetOnWeakspotOnly                   = 10,
	RicochetBehaviourAll                     = 11,
	RicochetBehaviourPawnsOnly               = 12,
	RicochetBehaviourNotPawns                = 13,
	EHitScanBaseUpgradeType_MAX              = 14,
};

// Enum FSD.EReflectionHitscanUpgradeType
// NumValues: 0x0002
enum class EReflectionHitscanUpgradeType : uint8
{
	ReflectionCount                          = 0,
	EReflectionHitscanUpgradeType_MAX        = 1,
};

// Enum FSD.EMultiHitscanUpgradeType
// NumValues: 0x0002
enum class EMultiHitscanUpgradeType : uint8
{
	BulletsPerShot                           = 0,
	EMultiHitscanUpgradeType_MAX             = 1,
};

// Enum FSD.EInventoryItemUpgradeType
// NumValues: 0x0006
enum class EInventoryItemUpgradeType : uint8
{
	MovementSpeedWhileUsing                  = 0,
	CooldownRate                             = 1,
	UnJamDuration                            = 2,
	ManualCooldownDelay                      = 3,
	ManualHeatPerUse                         = 4,
	EInventoryItemUpgradeType_MAX            = 5,
};

// Enum FSD.EDoubleDrillUpgradeType
// NumValues: 0x0006
enum class EDoubleDrillUpgradeType : uint8
{
	MiningRate                               = 0,
	MaxFuel                                  = 1,
	HeatRemovalOnKill                        = 2,
	HeatRemovalOnDamage                      = 3,
	MovementPenalty                          = 4,
	EDoubleDrillUpgradeType_MAX              = 5,
};

// Enum FSD.EFlameThrowerUpgradeType
// NumValues: 0x0005
enum class EFlameThrowerUpgradeType : uint8
{
	StickyFlameDuration                      = 0,
	LongReach                                = 1,
	AoEHeat                                  = 2,
	KilledTargetsExplodeChance               = 3,
	EFlameThrowerUpgradeType_MAX             = 4,
};

// Enum FSD.EPickaxeUpgradeType
// NumValues: 0x0007
enum class EPickaxeUpgradeType : uint8
{
	RockMining                               = 0,
	OneHitMineralMining                      = 1,
	ReceiveBonusMineralNitra                 = 2,
	ReceiveBonusMineralGold                  = 3,
	EnablePowerAttack                        = 4,
	PowerAttackCoolDown                      = 5,
	EPickaxeUpgradeType_MAX                  = 6,
};

// Enum FSD.ECryoSprayUpgrades
// NumValues: 0x0009
enum class ECryoSprayUpgrades : uint8
{
	PressureDropMultiplier                   = 0,
	PressureGainMultiplier                   = 1,
	ChargeupTime                             = 2,
	RePressurisationTime                     = 3,
	FrozenTargetsCanShatter                  = 4,
	AoECold                                  = 5,
	LongReach                                = 6,
	SprayWidth                               = 7,
	ECryoSprayUpgrades_MAX                   = 8,
};

// Enum FSD.ERevolerUpgrades
// NumValues: 0x0002
enum class ERevolerUpgrades : uint8
{
	OnKillFearFactor                         = 0,
	ERevolerUpgrades_MAX                     = 1,
};

// Enum FSD.EBasicPistol
// NumValues: 0x0002
enum class EBasicPistol : uint8
{
	ConsecutiveHitsDamageBonus               = 0,
	EBasicPistol_MAX                         = 1,
};

// Enum FSD.EAutoShotgunUpgrades
// NumValues: 0x0004
enum class EAutoShotgunUpgrades : uint8
{
	TurretSpecialAttackEnabled               = 0,
	RateOfFireAndAutoMatic                   = 1,
	CQCBuffOnKill                            = 2,
	EAutoShotgunUpgrades_MAX                 = 3,
};

// Enum FSD.EBurstWeaponUpgrades
// NumValues: 0x0003
enum class EBurstWeaponUpgrades : uint8
{
	FullBurstHitBonusDamage                  = 0,
	FullBurstStaggerDuraion                  = 1,
	EBurstWeaponUpgrades_MAX                 = 2,
};

// Enum FSD.ESawedOffShotgunUpgrades
// NumValues: 0x0004
enum class ESawedOffShotgunUpgrades : uint8
{
	FearOnShoot                              = 0,
	ShockWave                                = 2,
	ShotgunJump                              = 3,
	ESawedOffShotgunUpgrades_MAX             = 4,
};

// Enum FSD.EAutoCannonUpgrades
// NumValues: 0x0006
enum class EAutoCannonUpgrades : uint8
{
	FireTimeIncreaseScaleMultiplier          = 0,
	DamageBonusAtFullROF                     = 1,
	StatusEffectAtFullROF                    = 2,
	StartingFireRate                         = 3,
	MaxFireRate                              = 4,
	EAutoCannonUpgrades_MAX                  = 5,
};

// Enum FSD.ECoilgunUpgrades
// NumValues: 0x0019
enum class ECoilgunUpgrades : uint8
{
	EResistanceWhileCharging                 = 0,
	ETransferAilment                         = 1,
	EFlamekills                              = 2,
	EOvercharge                              = 3,
	EUnderCharge                             = 4,
	EWeaponBlast                             = 5,
	EShotwaveRange                           = 6,
	EImpactFearFactor                        = 7,
	EDamageOnShotWave                        = 8,
	EImpactFearRadius                        = 9,
	EEffectTrailDuration                     = 10,
	EEffectTrailBonusRadius                  = 11,
	EBrokenShieldBonus                       = 12,
	EPostChargeBurst                         = 13,
	EOwnerShieldCapacity                     = 14,
	EBlockShieldWhileCharing                 = 15,
	EWeaknessWhileCharging                   = 16,
	EPierceDepthDamage                       = 17,
	EBurnGround                              = 18,
	EElectricTrail                           = 19,
	EFireTrail                               = 20,
	EPenetrationDepth                        = 21,
	EPrimaryBonusShotWidth                   = 22,
	EShieldDelay                             = 23,
	ECoilgunUpgrades_MAX                     = 24,
};

// Enum FSD.EChargedWeaponUpgrades
// NumValues: 0x0008
enum class EChargedWeaponUpgrades : uint8
{
	ShotCostAtFullCharge                     = 0,
	ChargeSpeed                              = 1,
	CoolingRate                              = 2,
	HeatPerSecondCharging                    = 3,
	HeatPerSecondCharged                     = 4,
	HeatPerChargedShot                       = 5,
	HeatPerNormalShot                        = 6,
	EChargedWeaponUpgrades_MAX               = 7,
};

// Enum FSD.EDualMachinePistolsUpgrades
// NumValues: 0x0002
enum class EDualMachinePistolsUpgrades : uint8
{
	TriggerStatusEffectOnEmptyClip           = 0,
	EDualMachinePistolsUpgrades_MAX          = 1,
};

// Enum FSD.EBoltActionRifleUpgrades
// NumValues: 0x000B
enum class EBoltActionRifleUpgrades : uint8
{
	FocusSpeed                               = 0,
	AimedShotStagger                         = 1,
	AimedWeakShotKillFearFactor              = 2,
	FocusDamageBonus                         = 3,
	UnZoomedAccuracySpread                   = 4,
	FocusedWeakspotHitStatusEffect           = 5,
	NoGravityOnFocus                         = 6,
	KillReloadTimeBoost                      = 7,
	AimedShotWeakpointDamageBonusMultiplier  = 8,
	AimedShotAmmoCost                        = 9,
	EBoltActionRifleUpgrades_MAX             = 10,
};

// Enum FSD.EAssaultRifleUpgrade
// NumValues: 0x0003
enum class EAssaultRifleUpgrade : uint8
{
	KillResetsSpread                         = 0,
	KillTriggerStatusEffect                  = 1,
	EAssaultRifleUpgrade_MAX                 = 2,
};

// Enum FSD.EGatlingGunUpgrade
// NumValues: 0x0005
enum class EGatlingGunUpgrade : uint8
{
	DamageMultiplierAtMaxStabilization       = 0,
	HeatRemovedOnKill                        = 1,
	CriticalOverheat                         = 2,
	BarrelProximityDamage                    = 3,
	EGatlingGunUpgrade_MAX                   = 4,
};

// Enum FSD.EBeltDrivenWeaponUpgrade
// NumValues: 0x0003
enum class EBeltDrivenWeaponUpgrade : uint8
{
	BarrelSpinupTime                         = 0,
	BarrelSpinDownTime                       = 1,
	EBeltDrivenWeaponUpgrade_MAX             = 2,
};

// Enum FSD.EAmmoDrivenWeapnUpgradeType
// NumValues: 0x0013
enum class EAmmoDrivenWeapnUpgradeType : uint8
{
	MaxAmmo                                  = 0,
	ClipSize                                 = 1,
	RateOfFire                               = 2,
	ReloadSpeed                              = 3,
	RecoilMultiplier                         = 4,
	RecoilMultiplierV                        = 5,
	RecoilMultiplierH                        = 6,
	BurstCount                               = 7,
	BurstRateOfFire                          = 8,
	ActivateBurstFireMode                    = 9,
	ActivateAutomaticFireMode                = 10,
	HeatUpRateModifier                       = 11,
	AutoReloadDuration                       = 12,
	RecoilMass                               = 13,
	OverheatOnReload                         = 14,
	ShotCost                                 = 15,
	CustomEvent1                             = 16,
	HeatReductionOnReload                    = 17,
	EAmmoDrivenWeapnUpgradeType_MAX          = 18,
};

// Enum FSD.ELaserPointerMarkerType
// NumValues: 0x0004
enum class ELaserPointerMarkerType : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	Count                                    = 2,
	ELaserPointerMarkerType_MAX              = 3,
};

// Enum FSD.EStrobingMode
// NumValues: 0x0003
enum class EStrobingMode : uint8
{
	Intensity                                = 0,
	AttenuationRadius                        = 1,
	EStrobingMode_MAX                        = 2,
};

// Enum FSD.EStrobeMaterialMode
// NumValues: 0x0003
enum class EStrobeMaterialMode : uint8
{
	Material                                 = 0,
	Mesh                                     = 1,
	EStrobeMaterialMode_MAX                  = 2,
};

// Enum FSD.EArmorType
// NumValues: 0x0004
enum class EArmorType : uint8
{
	Light                                    = 0,
	Heavy                                    = 1,
	Unbreakable                              = 2,
	EArmorType_MAX                           = 3,
};

// Enum FSD.EDamageType
// NumValues: 0x0016
enum class EDamageType : uint8
{
	Fire                                     = 0,
	Cold                                     = 1,
	Melee                                    = 2,
	Kinetic                                  = 3,
	Explosive                                = 4,
	Stun                                     = 5,
	Electrocution                            = 6,
	Fear                                     = 7,
	Radiation                                = 8,
	Pheromone                                = 9,
	Poison                                   = 10,
	ArmorBreaking                            = 11,
	Push                                     = 12,
	Grab                                     = 13,
	None                                     = 14,
	Slow                                     = 15,
	Defense                                  = 16,
	TemperatureShock                         = 17,
	Corrosive                                = 18,
	Piercing                                 = 19,
	RockPox                                  = 20,
	EDamageType_MAX                          = 21,
};

// Enum FSD.EEnemyAttackType
// NumValues: 0x0006
enum class EEnemyAttackType : uint8
{
	Melee                                    = 0,
	Ranged                                   = 1,
	Grab                                     = 2,
	Area                                     = 3,
	Move                                     = 4,
	EEnemyAttackType_MAX                     = 5,
};

// Enum FSD.EMissionStructure
// NumValues: 0x0004
enum class EMissionStructure : uint8
{
	SingleMission                            = 0,
	DeepDive_Normal                          = 1,
	DeepDive_Elite                           = 2,
	EMissionStructure_MAX                    = 3,
};

// Enum FSD.ENisseState
// NumValues: 0x0005
enum class ENisseState : uint8
{
	Idle                                     = 0,
	Walking                                  = 1,
	Running                                  = 2,
	Frozen                                   = 3,
	ENisseState_MAX                          = 4,
};

// Enum FSD.EPatrolBotControlState
// NumValues: 0x0004
enum class EPatrolBotControlState : uint8
{
	Hostile                                  = 0,
	Disabled                                 = 1,
	Hacked                                   = 2,
	EPatrolBotControlState_MAX               = 3,
};

// Enum FSD.EPatrolBotState
// NumValues: 0x0004
enum class EPatrolBotState : uint8
{
	Rolling                                  = 0,
	Flying                                   = 1,
	Disabled                                 = 2,
	EPatrolBotState_MAX                      = 3,
};

// Enum FSD.EPawnStatType
// NumValues: 0x0003
enum class EPawnStatType : uint8
{
	Multiplicative                           = 0,
	Additive                                 = 1,
	EPawnStatType_MAX                        = 2,
};

// Enum FSD.EPerkSlotType
// NumValues: 0x0004
enum class EPerkSlotType : uint8
{
	Available                                = 0,
	LockedByPerk                             = 1,
	LockedByPromotion                        = 2,
	EPerkSlotType_MAX                        = 3,
};

// Enum FSD.EPerkUsageType
// NumValues: 0x0003
enum class EPerkUsageType : uint8
{
	Passive                                  = 0,
	Active                                   = 1,
	EPerkUsageType_MAX                       = 2,
};

// Enum FSD.EPerkHUDActivationLocation
// NumValues: 0x0003
enum class EPerkHUDActivationLocation : uint8
{
	Main                                     = 0,
	Down                                     = 1,
	EPerkHUDActivationLocation_MAX           = 2,
};

// Enum FSD.EPerkTierState
// NumValues: 0x0006
enum class EPerkTierState : uint8
{
	Claimable                                = 0,
	Claimed                                  = 1,
	Locked                                   = 2,
	Unaffordable                             = 3,
	NotAvailable                             = 4,
	EPerkTierState_MAX                       = 5,
};

// Enum FSD.EPickaxeState
// NumValues: 0x0005
enum class EPickaxeState : uint8
{
	Equipping                                = 0,
	Mining                                   = 1,
	PowerAttack                              = 2,
	End                                      = 3,
	EPickaxeState_MAX                        = 4,
};

// Enum FSD.EPickaxePartLocation
// NumValues: 0x0009
enum class EPickaxePartLocation : uint8
{
	Head                                     = 0,
	FrontBlade                               = 1,
	BackBlade                                = 2,
	Shaft                                    = 3,
	Handle                                   = 4,
	Pommel                                   = 5,
	Material                                 = 6,
	Count                                    = 7,
	EPickaxePartLocation_MAX                 = 8,
};

// Enum FSD.EPickaxePart
// NumValues: 0x0007
enum class EPickaxePart : uint8
{
	Head                                     = 0,
	Blade                                    = 1,
	Shaft                                    = 2,
	Handle                                   = 3,
	Pommel                                   = 4,
	Material                                 = 5,
	EPickaxePart_MAX                         = 6,
};

// Enum FSD.EPipelineExtractorPodAnimState
// NumValues: 0x0005
enum class EPipelineExtractorPodAnimState : uint8
{
	Folded                                   = 0,
	Idle                                     = 1,
	Running                                  = 2,
	Broken                                   = 3,
	EPipelineExtractorPodAnimState_MAX       = 4,
};

// Enum FSD.EPlaceableObstructionType
// NumValues: 0x000B
enum class EPlaceableObstructionType : uint8
{
	Valid                                    = 0,
	GroundTooSteep                           = 1,
	TooShort                                 = 2,
	TooLong                                  = 3,
	TurnTooSharp                             = 4,
	Blocked                                  = 5,
	NotEnoughRoom                            = 6,
	TooSteep                                 = 7,
	TooClose                                 = 8,
	Other                                    = 9,
	EPlaceableObstructionType_MAX            = 10,
};

// Enum FSD.ECharacterMoveDirection
// NumValues: 0x0006
enum class ECharacterMoveDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Left                                     = 2,
	Right                                    = 3,
	Back                                     = 4,
	ECharacterMoveDirection_MAX              = 5,
};

// Enum FSD.EGameOwnerStatus
// NumValues: 0x0005
enum class EGameOwnerStatus : uint8
{
	Supporter                                = 0,
	ContentCreator                           = 1,
	Developer                                = 2,
	Modder                                   = 3,
	EGameOwnerStatus_Max                     = 255,
};

// Enum FSD.EMovementCustomMode
// NumValues: 0x0006
enum class EMovementCustomMode : uint8
{
	MOVE_Custom_None                         = 0,
	MOVE_Custom_Track                        = 1,
	MOVE_Custom_CharacterStateControlled     = 2,
	MOVE_Custom_TraversalTool                = 3,
	MOVE_Custom_JetBoots                     = 4,
	MOVE_Custom_MAX                          = 5,
};

// Enum FSD.ERoomMirror
// NumValues: 0x0004
enum class ERoomMirror : uint8
{
	None                                     = 0,
	MirrorX                                  = 1,
	MirrorY                                  = 2,
	ERoomMirror_MAX                          = 3,
};

// Enum FSD.ERoomMirroringSupport
// NumValues: 0x0005
enum class ERoomMirroringSupport : uint8
{
	NotAllowed                               = 0,
	MirrorAroundX                            = 1,
	MirrorAroundY                            = 2,
	MirrorBoth                               = 3,
	ERoomMirroringSupport_MAX                = 4,
};

// Enum FSD.EItemAdjustmentType
// NumValues: 0x0005
enum class EItemAdjustmentType : uint8
{
	None                                     = 0,
	Cieling                                  = 1,
	Wall                                     = 2,
	Floor                                    = 3,
	EItemAdjustmentType_MAX                  = 4,
};

// Enum FSD.ECaveEntrancePriority
// NumValues: 0x0003
enum class ECaveEntrancePriority : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	ECaveEntrancePriority_MAX                = 2,
};

// Enum FSD.ECaveEntranceType
// NumValues: 0x0005
enum class ECaveEntranceType : uint8
{
	EntranceAndExit                          = 0,
	Entrance                                 = 1,
	Exit                                     = 2,
	TreassureRoom                            = 3,
	ECaveEntranceType_MAX                    = 4,
};

// Enum FSD.ESpawnSettings
// NumValues: 0x0004
enum class ESpawnSettings : uint8
{
	Normal                                   = 0,
	NoSpawning                               = 1,
	SpawnAll                                 = 2,
	ESpawnSettings_MAX                       = 3,
};

// Enum FSD.ECriticalItemPass
// NumValues: 0x0003
enum class ECriticalItemPass : uint8
{
	LargePass                                = 0,
	SmallPass                                = 1,
	ECriticalItemPass_MAX                    = 2,
};

// Enum FSD.ETerrainPlacementBoxType
// NumValues: 0x0003
enum class ETerrainPlacementBoxType : uint8
{
	NoTerrain                                = 0,
	Terrain                                  = 1,
	ETerrainPlacementBoxType_MAX             = 2,
};

// Enum FSD.EProjectileAttackRotationType
// NumValues: 0x0004
enum class EProjectileAttackRotationType : uint32
{
	NoTarget_ActorForward                    = 0,
	NoTarget_Socket                          = 1,
	Always_Socket                            = 2,
	EProjectileAttackRotationType_MAX        = 3,
};

// Enum FSD.ECrossbowEffectApplication
// NumValues: 0x0004
enum class ECrossbowEffectApplication : uint8
{
	ToDefault                                = 0,
	ToSpecial                                = 1,
	ToAll                                    = 2,
	ECrossbowEffectApplication_MAX           = 3,
};

// Enum FSD.ECrossbowHit
// NumValues: 0x0004
enum class ECrossbowHit : uint8
{
	InvalidHit                               = 0,
	OldHit                                   = 1,
	NewHit                                   = 2,
	ECrossbowHit_MAX                         = 3,
};

// Enum FSD.EPropHuntEvent
// NumValues: 0x0008
enum class EPropHuntEvent : uint8
{
	HunterBegin                              = 0,
	HunterMiss                               = 1,
	HunterHit                                = 2,
	PropBegin                                = 3,
	PropEnd                                  = 4,
	GameWon                                  = 5,
	GameLost                                 = 6,
	EPropHuntEvent_MAX                       = 7,
};

// Enum FSD.EProspectorRobotState
// NumValues: 0x0005
enum class EProspectorRobotState : uint8
{
	Searching                                = 0,
	Scanning                                 = 1,
	Sampling                                 = 2,
	Fleeing                                  = 3,
	EProspectorRobotState_MAX                = 4,
};

// Enum FSD.ESchematicType
// NumValues: 0x0005
enum class ESchematicType : uint8
{
	Overclock                                = 0,
	Vanity                                   = 1,
	Resource                                 = 2,
	Blank                                    = 3,
	ESchematicType_MAX                       = 4,
};

// Enum FSD.ESeasonVisibilityState
// NumValues: 0x0004
enum class ESeasonVisibilityState : uint8
{
	Bought                                   = 0,
	CanBuy                                   = 1,
	Locked                                   = 2,
	ESeasonVisibilityState_MAX               = 3,
};

// Enum FSD.EServerSortOrder
// NumValues: 0x0008
enum class EServerSortOrder : uint8
{
	Mission                                  = 0,
	Players                                  = 1,
	Length                                   = 2,
	Complexity                               = 3,
	Distance                                 = 4,
	Time                                     = 5,
	Difficulty                               = 6,
	EServerSortOrder_MAX                     = 7,
};

// Enum FSD.EServerDistance
// NumValues: 0x0005
enum class EServerDistance : uint8
{
	Close                                    = 0,
	Medium                                   = 1,
	Far                                      = 2,
	World                                    = 3,
	EServerDistance_MAX                      = 4,
};

// Enum FSD.EFSDNATType
// NumValues: 0x0005
enum class EFSDNATType : uint8
{
	Open                                     = 0,
	Moderate                                 = 1,
	Strict                                   = 2,
	Unknown                                  = 3,
	EFSDNATType_MAX                          = 4,
};

// Enum FSD.EFSDMissionStatus
// NumValues: 0x0006
enum class EFSDMissionStatus : uint8
{
	SpaceRig                                 = 0,
	InGame                                   = 1,
	Starting                                 = 2,
	EscapeSequence                           = 3,
	FinalBattle                              = 4,
	EFSDMissionStatus_MAX                    = 5,
};

// Enum FSD.ESharkEnemyState
// NumValues: 0x0006
enum class ESharkEnemyState : uint8
{
	Idle                                     = 0,
	Circling                                 = 1,
	Attacking                                = 2,
	Vulnerable                               = 3,
	Dive                                     = 4,
	ESharkEnemyState_MAX                     = 5,
};

// Enum FSD.EShowroomScaling
// NumValues: 0x0006
enum class EShowroomScaling : uint8
{
	NoScaling                                = 0,
	EnemySmall                               = 1,
	EnemyMedium                              = 2,
	EnemyBig                                 = 3,
	EnemyHuge                                = 4,
	EShowroomScaling_MAX                     = 5,
};

// Enum FSD.EPiplelineConnectorAnimationState
// NumValues: 0x0004
enum class EPiplelineConnectorAnimationState : uint8
{
	Unassembled                              = 0,
	Assembling                               = 1,
	Assembled                                = 2,
	EPiplelineConnectorAnimationState_MAX    = 3,
};

// Enum FSD.EMaggotAnimationState
// NumValues: 0x0003
enum class EMaggotAnimationState : uint8
{
	Idle                                     = 0,
	Moving                                   = 1,
	EMaggotAnimationState_MAX                = 2,
};

// Enum FSD.ESpiderDeathAnimationCategory
// NumValues: 0x0005
enum class ESpiderDeathAnimationCategory : uint8
{
	NoAnimation                              = 0,
	Melt                                     = 1,
	Cook                                     = 2,
	Burn                                     = 3,
	ESpiderDeathAnimationCategory_MAX        = 4,
};

// Enum FSD.EMoveDirection
// NumValues: 0x0006
enum class EMoveDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Left                                     = 2,
	Right                                    = 3,
	Back                                     = 4,
	EMoveDirection_MAX                       = 5,
};

// Enum FSD.EMiningPodMission
// NumValues: 0x0004
enum class EMiningPodMission : uint8
{
	DropAndReturn                            = 0,
	Extraction                               = 1,
	DropFromSpacerig                         = 2,
	EMiningPodMission_MAX                    = 3,
};

// Enum FSD.EMiningPodRampState
// NumValues: 0x0005
enum class EMiningPodRampState : uint8
{
	Closed                                   = 0,
	Opening                                  = 1,
	Open                                     = 2,
	Closing                                  = 3,
	EMiningPodRampState_MAX                  = 4,
};

// Enum FSD.EMiningPodState
// NumValues: 0x000F
enum class EMiningPodState : uint8
{
	Dropping                                 = 0,
	Drilling                                 = 1,
	Landed                                   = 2,
	PrepTakeoff                              = 3,
	Departing                                = 4,
	WaitingForGameStart                      = 5,
	InSpace                                  = 6,
	Destroy                                  = 7,
	WaitOnSpacerig                           = 8,
	ExitSpacerig                             = 9,
	Damaged                                  = 10,
	PoweringUp                               = 11,
	PoweredUp                                = 12,
	DeepDiveDeparture                        = 13,
	EMiningPodState_MAX                      = 14,
};

// Enum FSD.ETemperatureIntensity
// NumValues: 0x0007
enum class ETemperatureIntensity : uint8
{
	Cold3                                    = 0,
	Cold2                                    = 1,
	Cold1                                    = 2,
	Heat1                                    = 3,
	Heat2                                    = 4,
	Heat3                                    = 5,
	ETemperatureIntensity_MAX                = 6,
};

// Enum FSD.ETerminatorTentacleState
// NumValues: 0x0005
enum class ETerminatorTentacleState : uint8
{
	Idle                                     = 0,
	Grabbing                                 = 1,
	Grabbed                                  = 2,
	Dead                                     = 3,
	ETerminatorTentacleState_MAX             = 4,
};

// Enum FSD.ETerminatorShoutState
// NumValues: 0x0005
enum class ETerminatorShoutState : uint8
{
	EIdle                                    = 0,
	EGrabbing                                = 1,
	EDeath                                   = 2,
	EAttacking                               = 3,
	ETerminatorShoutState_MAX                = 4,
};

// Enum FSD.EBulletMode
// NumValues: 0x0003
enum class EBulletMode : uint8
{
	EMultiTrace                              = 0,
	ECapsule                                 = 1,
	EBulletMode_MAX                          = 2,
};

// Enum FSD.ETetherMessageDirection
// NumValues: 0x0004
enum class ETetherMessageDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Both                                     = 2,
	ETetherMessageDirection_MAX              = 3,
};

// Enum FSD.ETetherConnectionMode
// NumValues: 0x0005
enum class ETetherConnectionMode : uint32
{
	Both                                     = 0,
	FrontOnly                                = 1,
	BackOnly                                 = 2,
	None                                     = 3,
	ETetherConnectionMode_MAX                = 4,
};

// Enum FSD.EThrowableInput
// NumValues: 0x0003
enum class EThrowableInput : uint8
{
	LeftButton                               = 0,
	RightButton                              = 1,
	EThrowableInput_MAX                      = 2,
};

// Enum FSD.EExitTrackMode
// NumValues: 0x0006
enum class EExitTrackMode : uint8
{
	None                                     = 0,
	StopInPlace                              = 1,
	JumpInPlace                              = 2,
	JumpInCamDir                             = 3,
	JumpInTrackDir                           = 4,
	EExitTrackMode_MAX                       = 5,
};

// Enum FSD.ETreasureType
// NumValues: 0x0005
enum class ETreasureType : uint8
{
	WeaponSkin                               = 0,
	VictoryPose                              = 1,
	PickaxePart                              = 2,
	VanityItem                               = 3,
	ETreasureType_MAX                        = 4,
};

// Enum FSD.ECleanedStatus
// NumValues: 0x0003
enum class ECleanedStatus : uint8
{
	EInfected                                = 0,
	EVacuumed                                = 1,
	ECleanedStatus_MAX                       = 2,
};

// Enum FSD.EItemUpgradeStatus
// NumValues: 0x0006
enum class EItemUpgradeStatus : uint8
{
	Locked                                   = 0,
	AvailableCannotAfford                    = 1,
	AvailableCanAfford                       = 2,
	Owned                                    = 3,
	Equipped                                 = 4,
	EItemUpgradeStatus_MAX                   = 5,
};

// Enum FSD.EHeadVanityType
// NumValues: 0x0006
enum class EHeadVanityType : uint8
{
	HairOnly                                 = 0,
	HeadGearOnly                             = 1,
	HeadGearOnly_UseArmorMaterial            = 2,
	HairAndHeadGear                          = 3,
	HairAndHeadGear_UseArmorMaterial         = 4,
	EHeadVanityType_MAX                      = 5,
};

// Enum FSD.EArmorSetLegs
// NumValues: 0x000A
enum class EArmorSetLegs : uint8
{
	Invalid                                  = 0,
	LeftUpperLeg                             = 1,
	LeftLowerLeg                             = 2,
	LeftFoot                                 = 3,
	LeftToe                                  = 4,
	RightUpperLeg                            = 5,
	RightLowerLeg                            = 6,
	RightFoot                                = 7,
	RightToe                                 = 8,
	EArmorSetLegs_MAX                        = 9,
};

// Enum FSD.EArmorSetTorso
// NumValues: 0x0013
enum class EArmorSetTorso : uint8
{
	Invalid                                  = 0,
	UpperTorso                               = 1,
	MiddleTorso                              = 2,
	LowerTorso                               = 3,
	UpperBack                                = 4,
	MiddleBack                               = 5,
	LowerBack                                = 6,
	LeftHip                                  = 7,
	RightHip                                 = 8,
	FrontHip                                 = 9,
	LeftUpperLeg                             = 10,
	LeftLowerLeg                             = 11,
	LeftFoot                                 = 12,
	LeftToe                                  = 13,
	RightUpperLeg                            = 14,
	RightLowerLeg                            = 15,
	RightFoot                                = 16,
	RightToe                                 = 17,
	EArmorSetTorso_MAX                       = 18,
};

// Enum FSD.EArmorSetArms
// NumValues: 0x000E
enum class EArmorSetArms : uint8
{
	Invalid                                  = 0,
	LeftShoulder                             = 1,
	RightShoulder                            = 2,
	LeftUpperArm                             = 3,
	LeftLowerArm1                            = 4,
	LeftLowerArm2                            = 5,
	LeftHand                                 = 6,
	LeftHandAttach                           = 7,
	RightUpperArm                            = 8,
	RightLowerArm1                           = 9,
	RightLowerArm2                           = 10,
	RightHand                                = 11,
	RightHandAttach                          = 12,
	EArmorSetArms_MAX                        = 13,
};

// Enum FSD.ECharacterHeadMesh
// NumValues: 0x0009
enum class ECharacterHeadMesh : uint8
{
	Full                                     = 0,
	ThichNeckOnly                            = 1,
	ThinNeckOnly                             = 2,
	None                                     = 3,
	FlatEars                                 = 4,
	FaceOnly                                 = 5,
	EyesOnly                                 = 6,
	Masks                                    = 7,
	ECharacterHeadMesh_MAX                   = 8,
};

// Enum FSD.EArmorMeshType
// NumValues: 0x0006
enum class EArmorMeshType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	DefaultBeardCompatible                   = 2,
	Sleeveless                               = 4,
	SleevelessBeardCompatible                = 8,
	EArmorMeshType_MAX                       = 9,
};

// Enum FSD.EVanityAquisitionType
// NumValues: 0x0005
enum class EVanityAquisitionType : uint8
{
	UnlockedFromStart                        = 0,
	Purchased                                = 1,
	Schematic                                = 2,
	Treasure                                 = 3,
	EVanityAquisitionType_MAX                = 4,
};

// Enum FSD.EWeakpointGlowMode
// NumValues: 0x0003
enum class EWeakpointGlowMode : uint8
{
	Set                                      = 0,
	Additive                                 = 1,
	EWeakpointGlowMode_MAX                   = 2,
};

// Enum FSD.EWoodLouseState
// NumValues: 0x0004
enum class EWoodLouseState : uint8
{
	Unfolded                                 = 0,
	Folded                                   = 1,
	Size                                     = 2,
	EWoodLouseState_MAX                      = 3,
};

// ScriptStruct FSD.HeatSource
// 0x0008 (0x0008 - 0x0000)
struct FHeatSource final
{
public:
	float                                         Temperature;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Intensity;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeatSource) == 0x000004, "Wrong alignment on FHeatSource");
static_assert(sizeof(FHeatSource) == 0x000008, "Wrong size on FHeatSource");
static_assert(offsetof(FHeatSource, Temperature) == 0x000000, "Member 'FHeatSource::Temperature' has a wrong offset!");
static_assert(offsetof(FHeatSource, Intensity) == 0x000004, "Member 'FHeatSource::Intensity' has a wrong offset!");

// ScriptStruct FSD.HeroInfo
// 0x0088 (0x0088 - 0x0000)
struct FHeroInfo final
{
public:
	class FText                                   HeroName;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             HeroIcon;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SmallHeroIcon;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             HeroFullSizeImage;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeroColor;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HeroShortDescription;                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   HeroLongDescription;                               // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SwitchToMessage;                                   // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeroInfo) == 0x000008, "Wrong alignment on FHeroInfo");
static_assert(sizeof(FHeroInfo) == 0x000088, "Wrong size on FHeroInfo");
static_assert(offsetof(FHeroInfo, HeroName) == 0x000000, "Member 'FHeroInfo::HeroName' has a wrong offset!");
static_assert(offsetof(FHeroInfo, HeroIcon) == 0x000018, "Member 'FHeroInfo::HeroIcon' has a wrong offset!");
static_assert(offsetof(FHeroInfo, SmallHeroIcon) == 0x000020, "Member 'FHeroInfo::SmallHeroIcon' has a wrong offset!");
static_assert(offsetof(FHeroInfo, HeroFullSizeImage) == 0x000028, "Member 'FHeroInfo::HeroFullSizeImage' has a wrong offset!");
static_assert(offsetof(FHeroInfo, HeroColor) == 0x000030, "Member 'FHeroInfo::HeroColor' has a wrong offset!");
static_assert(offsetof(FHeroInfo, HeroShortDescription) == 0x000040, "Member 'FHeroInfo::HeroShortDescription' has a wrong offset!");
static_assert(offsetof(FHeroInfo, HeroLongDescription) == 0x000058, "Member 'FHeroInfo::HeroLongDescription' has a wrong offset!");
static_assert(offsetof(FHeroInfo, SwitchToMessage) == 0x000070, "Member 'FHeroInfo::SwitchToMessage' has a wrong offset!");

// ScriptStruct FSD.EnhancedTrace
// 0x0034 (0x0034 - 0x0000)
struct FEnhancedTrace final
{
public:
	TWeakObjectPtr<class UHitscanBaseComponent>   Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerCharacter>        Instigator;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitPoint;                                          // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnhancedTrace) == 0x000004, "Wrong alignment on FEnhancedTrace");
static_assert(sizeof(FEnhancedTrace) == 0x000034, "Wrong size on FEnhancedTrace");
static_assert(offsetof(FEnhancedTrace, Component) == 0x000000, "Member 'FEnhancedTrace::Component' has a wrong offset!");
static_assert(offsetof(FEnhancedTrace, Instigator) == 0x000008, "Member 'FEnhancedTrace::Instigator' has a wrong offset!");
static_assert(offsetof(FEnhancedTrace, Origin) == 0x000010, "Member 'FEnhancedTrace::Origin' has a wrong offset!");
static_assert(offsetof(FEnhancedTrace, Direction) == 0x00001C, "Member 'FEnhancedTrace::Direction' has a wrong offset!");
static_assert(offsetof(FEnhancedTrace, HitPoint) == 0x000028, "Member 'FEnhancedTrace::HitPoint' has a wrong offset!");

// ScriptStruct FSD.MissionShoutQueueItem
// 0x0048 (0x0048 - 0x0000)
struct FMissionShoutQueueItem final
{
public:
	TSoftObjectPtr<class USoundBase>              AudioPtr;                                          // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0028(0x0018)(NativeAccessSpecifierPublic)
	class USoundBase*                             LoadedAudio;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionShoutQueueItem) == 0x000008, "Wrong alignment on FMissionShoutQueueItem");
static_assert(sizeof(FMissionShoutQueueItem) == 0x000048, "Wrong size on FMissionShoutQueueItem");
static_assert(offsetof(FMissionShoutQueueItem, AudioPtr) == 0x000000, "Member 'FMissionShoutQueueItem::AudioPtr' has a wrong offset!");
static_assert(offsetof(FMissionShoutQueueItem, Text) == 0x000028, "Member 'FMissionShoutQueueItem::Text' has a wrong offset!");
static_assert(offsetof(FMissionShoutQueueItem, LoadedAudio) == 0x000040, "Member 'FMissionShoutQueueItem::LoadedAudio' has a wrong offset!");

// ScriptStruct FSD.PostProcessingBlendable
// 0x0020 (0x0020 - 0x0000)
struct FPostProcessingBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   Blendable;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A8[0x10];                                    // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessingBlendable) == 0x000008, "Wrong alignment on FPostProcessingBlendable");
static_assert(sizeof(FPostProcessingBlendable) == 0x000020, "Wrong size on FPostProcessingBlendable");
static_assert(offsetof(FPostProcessingBlendable, Blendable) == 0x000000, "Member 'FPostProcessingBlendable::Blendable' has a wrong offset!");

// ScriptStruct FSD.CustomKeyBinding
// 0x0028 (0x0028 - 0x0000)
struct FCustomKeyBinding final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A9[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0010(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomKeyBinding) == 0x000008, "Wrong alignment on FCustomKeyBinding");
static_assert(sizeof(FCustomKeyBinding) == 0x000028, "Wrong size on FCustomKeyBinding");
static_assert(offsetof(FCustomKeyBinding, ActionName) == 0x000000, "Member 'FCustomKeyBinding::ActionName' has a wrong offset!");
static_assert(offsetof(FCustomKeyBinding, Index) == 0x000008, "Member 'FCustomKeyBinding::Index' has a wrong offset!");
static_assert(offsetof(FCustomKeyBinding, Key) == 0x000010, "Member 'FCustomKeyBinding::Key' has a wrong offset!");

// ScriptStruct FSD.CountDownFloat
// 0x000C (0x000C - 0x0000)
struct FCountDownFloat final
{
public:
	float                                         CountDownDuration;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16AA[0x8];                                     // 0x0004(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCountDownFloat) == 0x000004, "Wrong alignment on FCountDownFloat");
static_assert(sizeof(FCountDownFloat) == 0x00000C, "Wrong size on FCountDownFloat");
static_assert(offsetof(FCountDownFloat, CountDownDuration) == 0x000000, "Member 'FCountDownFloat::CountDownDuration' has a wrong offset!");

// ScriptStruct FSD.EliteEnemyBan
// 0x0010 (0x0010 - 0x0000)
struct FEliteEnemyBan final
{
public:
	struct FInt32Interval                         AffectedPlayerCount;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionTemplate*                       Template;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEliteEnemyBan) == 0x000008, "Wrong alignment on FEliteEnemyBan");
static_assert(sizeof(FEliteEnemyBan) == 0x000010, "Wrong size on FEliteEnemyBan");
static_assert(offsetof(FEliteEnemyBan, AffectedPlayerCount) == 0x000000, "Member 'FEliteEnemyBan::AffectedPlayerCount' has a wrong offset!");
static_assert(offsetof(FEliteEnemyBan, Template) == 0x000008, "Member 'FEliteEnemyBan::Template' has a wrong offset!");

// ScriptStruct FSD.ItemLoadout
// 0x0084 (0x0084 - 0x0000)
struct FItemLoadout final
{
public:
	struct FGuid                                  PrimaryWeapon;                                     // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  SecondaryWeapon;                                   // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  TraversalTool;                                     // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ClassTool;                                         // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Armor;                                             // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Flare;                                             // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MiningTool;                                        // 0x0060(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Grenade;                                           // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IconIndex;                                         // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemLoadout) == 0x000004, "Wrong alignment on FItemLoadout");
static_assert(sizeof(FItemLoadout) == 0x000084, "Wrong size on FItemLoadout");
static_assert(offsetof(FItemLoadout, PrimaryWeapon) == 0x000000, "Member 'FItemLoadout::PrimaryWeapon' has a wrong offset!");
static_assert(offsetof(FItemLoadout, SecondaryWeapon) == 0x000010, "Member 'FItemLoadout::SecondaryWeapon' has a wrong offset!");
static_assert(offsetof(FItemLoadout, TraversalTool) == 0x000020, "Member 'FItemLoadout::TraversalTool' has a wrong offset!");
static_assert(offsetof(FItemLoadout, ClassTool) == 0x000030, "Member 'FItemLoadout::ClassTool' has a wrong offset!");
static_assert(offsetof(FItemLoadout, Armor) == 0x000040, "Member 'FItemLoadout::Armor' has a wrong offset!");
static_assert(offsetof(FItemLoadout, Flare) == 0x000050, "Member 'FItemLoadout::Flare' has a wrong offset!");
static_assert(offsetof(FItemLoadout, MiningTool) == 0x000060, "Member 'FItemLoadout::MiningTool' has a wrong offset!");
static_assert(offsetof(FItemLoadout, Grenade) == 0x000070, "Member 'FItemLoadout::Grenade' has a wrong offset!");
static_assert(offsetof(FItemLoadout, IconIndex) == 0x000080, "Member 'FItemLoadout::IconIndex' has a wrong offset!");

// ScriptStruct FSD.LerpingPercent
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FLerpingPercent final
{
public:
	uint8                                         TargetPercent;                                     // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16AB[0x7];                                     // 0x0001(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLerpingPercent) == 0x000004, "Wrong alignment on FLerpingPercent");
static_assert(sizeof(FLerpingPercent) == 0x000008, "Wrong size on FLerpingPercent");
static_assert(offsetof(FLerpingPercent, TargetPercent) == 0x000000, "Member 'FLerpingPercent::TargetPercent' has a wrong offset!");

// ScriptStruct FSD.PawnStatEntry
// 0x0024 (0x0030 - 0x000C)
struct FPawnStatEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_16AC[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPawnStat*                              PawnStat;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16AD[0x10];                                    // 0x0018(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16AE[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnStatEntry) == 0x000008, "Wrong alignment on FPawnStatEntry");
static_assert(sizeof(FPawnStatEntry) == 0x000030, "Wrong size on FPawnStatEntry");
static_assert(offsetof(FPawnStatEntry, PawnStat) == 0x000010, "Member 'FPawnStatEntry::PawnStat' has a wrong offset!");
static_assert(offsetof(FPawnStatEntry, Value) == 0x000028, "Member 'FPawnStatEntry::Value' has a wrong offset!");

// ScriptStruct FSD.PawnStatEntriesArray
// 0x0018 (0x0120 - 0x0108)
struct FPawnStatEntriesArray final : public FFastArraySerializer
{
public:
	TArray<struct FPawnStatEntry>                 Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UPawnStatsComponent*                    Owner;                                             // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnStatEntriesArray) == 0x000008, "Wrong alignment on FPawnStatEntriesArray");
static_assert(sizeof(FPawnStatEntriesArray) == 0x000120, "Wrong size on FPawnStatEntriesArray");
static_assert(offsetof(FPawnStatEntriesArray, Items) == 0x000108, "Member 'FPawnStatEntriesArray::Items' has a wrong offset!");
static_assert(offsetof(FPawnStatEntriesArray, Owner) == 0x000118, "Member 'FPawnStatEntriesArray::Owner' has a wrong offset!");

// ScriptStruct FSD.CharacterLoadoutAnalyticInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCharacterLoadoutAnalyticInfo final
{
public:
	uint8                                         Pad_16AF[0x30];                                    // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterLoadoutAnalyticInfo) == 0x000008, "Wrong alignment on FCharacterLoadoutAnalyticInfo");
static_assert(sizeof(FCharacterLoadoutAnalyticInfo) == 0x000030, "Wrong size on FCharacterLoadoutAnalyticInfo");

// ScriptStruct FSD.ReplicatedCharacterData
// 0x0018 (0x0018 - 0x0000)
struct FReplicatedCharacterData final
{
public:
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemperatureEffect;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTakeDamage;                                    // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B0[0xB];                                     // 0x000D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedCharacterData) == 0x000004, "Wrong alignment on FReplicatedCharacterData");
static_assert(sizeof(FReplicatedCharacterData) == 0x000018, "Wrong size on FReplicatedCharacterData");
static_assert(offsetof(FReplicatedCharacterData, Target) == 0x000000, "Member 'FReplicatedCharacterData::Target' has a wrong offset!");
static_assert(offsetof(FReplicatedCharacterData, TemperatureEffect) == 0x000008, "Member 'FReplicatedCharacterData::TemperatureEffect' has a wrong offset!");
static_assert(offsetof(FReplicatedCharacterData, bCanTakeDamage) == 0x00000C, "Member 'FReplicatedCharacterData::bCanTakeDamage' has a wrong offset!");

// ScriptStruct FSD.CameraSpringSettings
// 0x003C (0x003C - 0x0000)
struct FCameraSpringSettings final
{
public:
	bool                                          SpringEnabled;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B1[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepThreshold;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpringExtend;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetractStrength;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetractDownReduction;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDebug;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B2[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSpeedZ;                                        // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastLocation;                                      // 0x0020(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartSpringLocation;                               // 0x002C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpringInitialized;                                // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B3[0x3];                                     // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraSpringSettings) == 0x000004, "Wrong alignment on FCameraSpringSettings");
static_assert(sizeof(FCameraSpringSettings) == 0x00003C, "Wrong size on FCameraSpringSettings");
static_assert(offsetof(FCameraSpringSettings, SpringEnabled) == 0x000000, "Member 'FCameraSpringSettings::SpringEnabled' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, StepThreshold) == 0x000004, "Member 'FCameraSpringSettings::StepThreshold' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, SpringExtend) == 0x000008, "Member 'FCameraSpringSettings::SpringExtend' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, RetractStrength) == 0x000010, "Member 'FCameraSpringSettings::RetractStrength' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, RetractDownReduction) == 0x000014, "Member 'FCameraSpringSettings::RetractDownReduction' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, ShowDebug) == 0x000018, "Member 'FCameraSpringSettings::ShowDebug' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, LastSpeedZ) == 0x00001C, "Member 'FCameraSpringSettings::LastSpeedZ' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, LastLocation) == 0x000020, "Member 'FCameraSpringSettings::LastLocation' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, StartSpringLocation) == 0x00002C, "Member 'FCameraSpringSettings::StartSpringLocation' has a wrong offset!");
static_assert(offsetof(FCameraSpringSettings, bSpringInitialized) == 0x000038, "Member 'FCameraSpringSettings::bSpringInitialized' has a wrong offset!");

// ScriptStruct FSD.RandRange
// 0x0008 (0x0008 - 0x0000)
struct FRandRange final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandRange) == 0x000004, "Wrong alignment on FRandRange");
static_assert(sizeof(FRandRange) == 0x000008, "Wrong size on FRandRange");
static_assert(offsetof(FRandRange, Min) == 0x000000, "Member 'FRandRange::Min' has a wrong offset!");
static_assert(offsetof(FRandRange, Max) == 0x000004, "Member 'FRandRange::Max' has a wrong offset!");

// ScriptStruct FSD.RecoilSettings
// 0x0028 (0x0028 - 0x0000)
struct FRecoilSettings final
{
public:
	struct FRandRange                             RecoilRoll;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRandRange                             RecoilPitch;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRandRange                             RecoilYaw;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CanRecoilDown;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B4[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringStiffness;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDampening;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecoilSettings) == 0x000004, "Wrong alignment on FRecoilSettings");
static_assert(sizeof(FRecoilSettings) == 0x000028, "Wrong size on FRecoilSettings");
static_assert(offsetof(FRecoilSettings, RecoilRoll) == 0x000000, "Member 'FRecoilSettings::RecoilRoll' has a wrong offset!");
static_assert(offsetof(FRecoilSettings, RecoilPitch) == 0x000008, "Member 'FRecoilSettings::RecoilPitch' has a wrong offset!");
static_assert(offsetof(FRecoilSettings, RecoilYaw) == 0x000010, "Member 'FRecoilSettings::RecoilYaw' has a wrong offset!");
static_assert(offsetof(FRecoilSettings, CanRecoilDown) == 0x000018, "Member 'FRecoilSettings::CanRecoilDown' has a wrong offset!");
static_assert(offsetof(FRecoilSettings, SpringStiffness) == 0x00001C, "Member 'FRecoilSettings::SpringStiffness' has a wrong offset!");
static_assert(offsetof(FRecoilSettings, CriticalDampening) == 0x000020, "Member 'FRecoilSettings::CriticalDampening' has a wrong offset!");
static_assert(offsetof(FRecoilSettings, Mass) == 0x000024, "Member 'FRecoilSettings::Mass' has a wrong offset!");

// ScriptStruct FSD.SpawnRarityModifierItem
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSpawnRarityModifierItem final
{
public:
	uint8                                         Pad_16B5[0x8];                                     // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnRarityModifierItem) == 0x000004, "Wrong alignment on FSpawnRarityModifierItem");
static_assert(sizeof(FSpawnRarityModifierItem) == 0x000008, "Wrong size on FSpawnRarityModifierItem");

// ScriptStruct FSD.DeepDiveSaveRewardItem
// 0x0014 (0x0014 - 0x0000)
struct FDeepDiveSaveRewardItem final
{
public:
	struct FGuid                                  RewardID;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeepDiveSaveRewardItem) == 0x000004, "Wrong alignment on FDeepDiveSaveRewardItem");
static_assert(sizeof(FDeepDiveSaveRewardItem) == 0x000014, "Wrong size on FDeepDiveSaveRewardItem");
static_assert(offsetof(FDeepDiveSaveRewardItem, RewardID) == 0x000000, "Member 'FDeepDiveSaveRewardItem::RewardID' has a wrong offset!");
static_assert(offsetof(FDeepDiveSaveRewardItem, Stage) == 0x000010, "Member 'FDeepDiveSaveRewardItem::Stage' has a wrong offset!");

// ScriptStruct FSD.DeepDiveItem
// 0x0038 (0x0038 - 0x0000)
struct FDeepDiveItem final
{
public:
	int32                                         Progress;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BestTime;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B6[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDeepDiveSaveRewardItem>        Rewards;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HasEverCompleted;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B7[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          RewardsGiven;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDeepDiveItem) == 0x000008, "Wrong alignment on FDeepDiveItem");
static_assert(sizeof(FDeepDiveItem) == 0x000038, "Wrong size on FDeepDiveItem");
static_assert(offsetof(FDeepDiveItem, Progress) == 0x000000, "Member 'FDeepDiveItem::Progress' has a wrong offset!");
static_assert(offsetof(FDeepDiveItem, Seed) == 0x000004, "Member 'FDeepDiveItem::Seed' has a wrong offset!");
static_assert(offsetof(FDeepDiveItem, BestTime) == 0x000008, "Member 'FDeepDiveItem::BestTime' has a wrong offset!");
static_assert(offsetof(FDeepDiveItem, Rewards) == 0x000010, "Member 'FDeepDiveItem::Rewards' has a wrong offset!");
static_assert(offsetof(FDeepDiveItem, HasEverCompleted) == 0x000020, "Member 'FDeepDiveItem::HasEverCompleted' has a wrong offset!");
static_assert(offsetof(FDeepDiveItem, RewardsGiven) == 0x000028, "Member 'FDeepDiveItem::RewardsGiven' has a wrong offset!");

// ScriptStruct FSD.DeepDiveSave
// 0x0070 (0x0070 - 0x0000)
struct FDeepDiveSave final
{
public:
	struct FDeepDiveItem                          NormalSave;                                        // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FDeepDiveItem                          EliteSave;                                         // 0x0038(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeepDiveSave) == 0x000008, "Wrong alignment on FDeepDiveSave");
static_assert(sizeof(FDeepDiveSave) == 0x000070, "Wrong size on FDeepDiveSave");
static_assert(offsetof(FDeepDiveSave, NormalSave) == 0x000000, "Member 'FDeepDiveSave::NormalSave' has a wrong offset!");
static_assert(offsetof(FDeepDiveSave, EliteSave) == 0x000038, "Member 'FDeepDiveSave::EliteSave' has a wrong offset!");

// ScriptStruct FSD.WidgetTextCounter
// 0x001C (0x001C - 0x0000)
struct FWidgetTextCounter final
{
public:
	TWeakObjectPtr<class UTextBlock>              Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B8[0x14];                                    // 0x0008(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetTextCounter) == 0x000004, "Wrong alignment on FWidgetTextCounter");
static_assert(sizeof(FWidgetTextCounter) == 0x00001C, "Wrong size on FWidgetTextCounter");
static_assert(offsetof(FWidgetTextCounter, Widget) == 0x000000, "Member 'FWidgetTextCounter::Widget' has a wrong offset!");

// ScriptStruct FSD.LaserPointerTarget
// 0x00B0 (0x00B0 - 0x0000)
struct FLaserPointerTarget final
{
public:
	struct FHitResult                             HitInfo;                                           // 0x0000(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B9[0x10];                                    // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ExtraTarget;                                       // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16BA[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLaserPointerTarget) == 0x000008, "Wrong alignment on FLaserPointerTarget");
static_assert(sizeof(FLaserPointerTarget) == 0x0000B0, "Wrong size on FLaserPointerTarget");
static_assert(offsetof(FLaserPointerTarget, HitInfo) == 0x000000, "Member 'FLaserPointerTarget::HitInfo' has a wrong offset!");
static_assert(offsetof(FLaserPointerTarget, Target) == 0x000098, "Member 'FLaserPointerTarget::Target' has a wrong offset!");
static_assert(offsetof(FLaserPointerTarget, ExtraTarget) == 0x0000A0, "Member 'FLaserPointerTarget::ExtraTarget' has a wrong offset!");

// ScriptStruct FSD.DroneLightSetting
// 0x000C (0x000C - 0x0000)
struct FDroneLightSetting final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDroneLightSetting) == 0x000004, "Wrong alignment on FDroneLightSetting");
static_assert(sizeof(FDroneLightSetting) == 0x00000C, "Wrong size on FDroneLightSetting");
static_assert(offsetof(FDroneLightSetting, Color) == 0x000000, "Member 'FDroneLightSetting::Color' has a wrong offset!");
static_assert(offsetof(FDroneLightSetting, Intensity) == 0x000004, "Member 'FDroneLightSetting::Intensity' has a wrong offset!");
static_assert(offsetof(FDroneLightSetting, Radius) == 0x000008, "Member 'FDroneLightSetting::Radius' has a wrong offset!");

// ScriptStruct FSD.CoolDownProgressStyle
// 0x0040 (0x0040 - 0x0000)
struct FCoolDownProgressStyle final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconTint;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UCoolDownProgressWidget>    WidgetOverride;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AudioCoolDownFinished;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoolDownProgressStyle) == 0x000008, "Wrong alignment on FCoolDownProgressStyle");
static_assert(sizeof(FCoolDownProgressStyle) == 0x000040, "Wrong size on FCoolDownProgressStyle");
static_assert(offsetof(FCoolDownProgressStyle, Icon) == 0x000000, "Member 'FCoolDownProgressStyle::Icon' has a wrong offset!");
static_assert(offsetof(FCoolDownProgressStyle, IconTint) == 0x000008, "Member 'FCoolDownProgressStyle::IconTint' has a wrong offset!");
static_assert(offsetof(FCoolDownProgressStyle, Name) == 0x000018, "Member 'FCoolDownProgressStyle::Name' has a wrong offset!");
static_assert(offsetof(FCoolDownProgressStyle, WidgetOverride) == 0x000030, "Member 'FCoolDownProgressStyle::WidgetOverride' has a wrong offset!");
static_assert(offsetof(FCoolDownProgressStyle, AudioCoolDownFinished) == 0x000038, "Member 'FCoolDownProgressStyle::AudioCoolDownFinished' has a wrong offset!");

// ScriptStruct FSD.RoomEntrance
// 0x0020 (0x0020 - 0x0000)
struct FRoomEntrance final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBLocked;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveEntranceType                             EntranceType;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveEntrancePriority                         Priority;                                          // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16BB[0x1];                                     // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PathObstacleID;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomEntrance) == 0x000004, "Wrong alignment on FRoomEntrance");
static_assert(sizeof(FRoomEntrance) == 0x000020, "Wrong size on FRoomEntrance");
static_assert(offsetof(FRoomEntrance, Location) == 0x000000, "Member 'FRoomEntrance::Location' has a wrong offset!");
static_assert(offsetof(FRoomEntrance, Direction) == 0x00000C, "Member 'FRoomEntrance::Direction' has a wrong offset!");
static_assert(offsetof(FRoomEntrance, IsBLocked) == 0x000018, "Member 'FRoomEntrance::IsBLocked' has a wrong offset!");
static_assert(offsetof(FRoomEntrance, EntranceType) == 0x000019, "Member 'FRoomEntrance::EntranceType' has a wrong offset!");
static_assert(offsetof(FRoomEntrance, Priority) == 0x00001A, "Member 'FRoomEntrance::Priority' has a wrong offset!");
static_assert(offsetof(FRoomEntrance, PathObstacleID) == 0x00001C, "Member 'FRoomEntrance::PathObstacleID' has a wrong offset!");

// ScriptStruct FSD.TunnelPath
// 0x0010 (0x0010 - 0x0000)
struct FTunnelPath final
{
public:
	TArray<struct FVector>                        Path;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTunnelPath) == 0x000008, "Wrong alignment on FTunnelPath");
static_assert(sizeof(FTunnelPath) == 0x000010, "Wrong size on FTunnelPath");
static_assert(offsetof(FTunnelPath, Path) == 0x000000, "Member 'FTunnelPath::Path' has a wrong offset!");

// ScriptStruct FSD.RoomNodeBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FRoomNodeBase
{
};
#pragma pack(pop)
static_assert(alignof(FRoomNodeBase) == 0x000001, "Wrong alignment on FRoomNodeBase");
static_assert(sizeof(FRoomNodeBase) == 0x000001, "Wrong size on FRoomNodeBase");

// ScriptStruct FSD.TunnelNode
// 0x00D8 (0x00D8 - 0x0000)
struct FTunnelNode final : public FRoomNodeBase
{
public:
	int32                                         EntranceRoomID;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExitRoomID;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoomEntrance                          Entrance;                                          // 0x0008(0x0020)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoomEntrance                          Exit;                                              // 0x0028(0x0020)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	class UTunnelParameters*                      ParametersOverride;                                // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTunnelPath                            Path;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DirtStartLocation;                                 // 0x0064(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddDirt;                                           // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16BC[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightedResourceAmount;                            // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16BD[0x60];                                    // 0x0078(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTunnelNode) == 0x000008, "Wrong alignment on FTunnelNode");
static_assert(sizeof(FTunnelNode) == 0x0000D8, "Wrong size on FTunnelNode");
static_assert(offsetof(FTunnelNode, EntranceRoomID) == 0x000000, "Member 'FTunnelNode::EntranceRoomID' has a wrong offset!");
static_assert(offsetof(FTunnelNode, ExitRoomID) == 0x000004, "Member 'FTunnelNode::ExitRoomID' has a wrong offset!");
static_assert(offsetof(FTunnelNode, Entrance) == 0x000008, "Member 'FTunnelNode::Entrance' has a wrong offset!");
static_assert(offsetof(FTunnelNode, Exit) == 0x000028, "Member 'FTunnelNode::Exit' has a wrong offset!");
static_assert(offsetof(FTunnelNode, ParametersOverride) == 0x000048, "Member 'FTunnelNode::ParametersOverride' has a wrong offset!");
static_assert(offsetof(FTunnelNode, Path) == 0x000050, "Member 'FTunnelNode::Path' has a wrong offset!");
static_assert(offsetof(FTunnelNode, ID) == 0x000060, "Member 'FTunnelNode::ID' has a wrong offset!");
static_assert(offsetof(FTunnelNode, DirtStartLocation) == 0x000064, "Member 'FTunnelNode::DirtStartLocation' has a wrong offset!");
static_assert(offsetof(FTunnelNode, AddDirt) == 0x000070, "Member 'FTunnelNode::AddDirt' has a wrong offset!");
static_assert(offsetof(FTunnelNode, WeightedResourceAmount) == 0x000074, "Member 'FTunnelNode::WeightedResourceAmount' has a wrong offset!");

// ScriptStruct FSD.AnalogAimSettings
// 0x0048 (0x0048 - 0x0000)
struct FAnalogAimSettings final
{
public:
	uint8                                         Pad_16BE[0x20];                                    // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AimRate;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SensitivityCurve;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtStickyness;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StickynessRecoverySpeed;                           // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StickynessMaxSensitivity;                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ThirdPersonLookRate;                               // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16BF[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnalogAimSettings) == 0x000008, "Wrong alignment on FAnalogAimSettings");
static_assert(sizeof(FAnalogAimSettings) == 0x000048, "Wrong size on FAnalogAimSettings");
static_assert(offsetof(FAnalogAimSettings, AimRate) == 0x000020, "Member 'FAnalogAimSettings::AimRate' has a wrong offset!");
static_assert(offsetof(FAnalogAimSettings, SensitivityCurve) == 0x000028, "Member 'FAnalogAimSettings::SensitivityCurve' has a wrong offset!");
static_assert(offsetof(FAnalogAimSettings, LookAtStickyness) == 0x000030, "Member 'FAnalogAimSettings::LookAtStickyness' has a wrong offset!");
static_assert(offsetof(FAnalogAimSettings, StickynessRecoverySpeed) == 0x000034, "Member 'FAnalogAimSettings::StickynessRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FAnalogAimSettings, StickynessMaxSensitivity) == 0x000038, "Member 'FAnalogAimSettings::StickynessMaxSensitivity' has a wrong offset!");
static_assert(offsetof(FAnalogAimSettings, ThirdPersonLookRate) == 0x00003C, "Member 'FAnalogAimSettings::ThirdPersonLookRate' has a wrong offset!");

// ScriptStruct FSD.GMMutatorItem
// 0x0010 (0x0010 - 0x0000)
struct FGMMutatorItem final
{
public:
	TArray<class UMutator*>                       Mutators;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGMMutatorItem) == 0x000008, "Wrong alignment on FGMMutatorItem");
static_assert(sizeof(FGMMutatorItem) == 0x000010, "Wrong size on FGMMutatorItem");
static_assert(offsetof(FGMMutatorItem, Mutators) == 0x000000, "Member 'FGMMutatorItem::Mutators' has a wrong offset!");

// ScriptStruct FSD.OptionsInSaveGame
// 0x0008 (0x0008 - 0x0000)
struct FOptionsInSaveGame final
{
public:
	bool                                          SaveGameOptionsValid;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C0[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenMode;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionsInSaveGame) == 0x000004, "Wrong alignment on FOptionsInSaveGame");
static_assert(sizeof(FOptionsInSaveGame) == 0x000008, "Wrong size on FOptionsInSaveGame");
static_assert(offsetof(FOptionsInSaveGame, SaveGameOptionsValid) == 0x000000, "Member 'FOptionsInSaveGame::SaveGameOptionsValid' has a wrong offset!");
static_assert(offsetof(FOptionsInSaveGame, ScreenMode) == 0x000004, "Member 'FOptionsInSaveGame::ScreenMode' has a wrong offset!");

// ScriptStruct FSD.HoldButton
// 0x0028 (0x0028 - 0x0000)
struct FHoldButton final
{
public:
	class FText                                   HoldingText;                                       // 0x0000(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         HoldStartTime;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldDuration;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C1[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoldButton) == 0x000008, "Wrong alignment on FHoldButton");
static_assert(sizeof(FHoldButton) == 0x000028, "Wrong size on FHoldButton");
static_assert(offsetof(FHoldButton, HoldingText) == 0x000000, "Member 'FHoldButton::HoldingText' has a wrong offset!");
static_assert(offsetof(FHoldButton, HoldStartTime) == 0x000018, "Member 'FHoldButton::HoldStartTime' has a wrong offset!");
static_assert(offsetof(FHoldButton, HoldDuration) == 0x00001C, "Member 'FHoldButton::HoldDuration' has a wrong offset!");

// ScriptStruct FSD.SpawnEffectItem
// 0x0030 (0x003C - 0x000C)
struct FSpawnEffectItem final : public FFastArraySerializerItem
{
public:
	ECreatureSize                                 CreatureSize;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C2[0x14];                                    // 0x0028(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnEffectItem) == 0x000004, "Wrong alignment on FSpawnEffectItem");
static_assert(sizeof(FSpawnEffectItem) == 0x00003C, "Wrong size on FSpawnEffectItem");
static_assert(offsetof(FSpawnEffectItem, CreatureSize) == 0x00000C, "Member 'FSpawnEffectItem::CreatureSize' has a wrong offset!");
static_assert(offsetof(FSpawnEffectItem, Location) == 0x000010, "Member 'FSpawnEffectItem::Location' has a wrong offset!");
static_assert(offsetof(FSpawnEffectItem, Rotation) == 0x00001C, "Member 'FSpawnEffectItem::Rotation' has a wrong offset!");

// ScriptStruct FSD.TerminatorTalkMaterial
// 0x0010 (0x0010 - 0x0000)
struct FTerminatorTalkMaterial final
{
public:
	class UMaterialInstanceDynamic*               Material;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasePower;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmplitudeMultiplier;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerminatorTalkMaterial) == 0x000008, "Wrong alignment on FTerminatorTalkMaterial");
static_assert(sizeof(FTerminatorTalkMaterial) == 0x000010, "Wrong size on FTerminatorTalkMaterial");
static_assert(offsetof(FTerminatorTalkMaterial, Material) == 0x000000, "Member 'FTerminatorTalkMaterial::Material' has a wrong offset!");
static_assert(offsetof(FTerminatorTalkMaterial, BasePower) == 0x000008, "Member 'FTerminatorTalkMaterial::BasePower' has a wrong offset!");
static_assert(offsetof(FTerminatorTalkMaterial, AmplitudeMultiplier) == 0x00000C, "Member 'FTerminatorTalkMaterial::AmplitudeMultiplier' has a wrong offset!");

// ScriptStruct FSD.EquippedVanity
// 0x0020 (0x0020 - 0x0000)
struct FEquippedVanity final
{
public:
	TArray<class UVanityItem*>                    Vanity;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UVanityItem*                            SelectedArmorMaterial;                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsingSlevedArmor;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C3[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquippedVanity) == 0x000008, "Wrong alignment on FEquippedVanity");
static_assert(sizeof(FEquippedVanity) == 0x000020, "Wrong size on FEquippedVanity");
static_assert(offsetof(FEquippedVanity, Vanity) == 0x000000, "Member 'FEquippedVanity::Vanity' has a wrong offset!");
static_assert(offsetof(FEquippedVanity, SelectedArmorMaterial) == 0x000010, "Member 'FEquippedVanity::SelectedArmorMaterial' has a wrong offset!");
static_assert(offsetof(FEquippedVanity, UsingSlevedArmor) == 0x000018, "Member 'FEquippedVanity::UsingSlevedArmor' has a wrong offset!");

// ScriptStruct FSD.PropHuntEventSettings
// 0x0050 (0x0050 - 0x0000)
struct FPropHuntEventSettings final
{
public:
	TSet<TSoftClassPtr<class UClass>>             DisguiseActors;                                    // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropHuntEventSettings) == 0x000008, "Wrong alignment on FPropHuntEventSettings");
static_assert(sizeof(FPropHuntEventSettings) == 0x000050, "Wrong size on FPropHuntEventSettings");
static_assert(offsetof(FPropHuntEventSettings, DisguiseActors) == 0x000000, "Member 'FPropHuntEventSettings::DisguiseActors' has a wrong offset!");

// ScriptStruct FSD.DownCameraSettings
// 0x0018 (0x0018 - 0x0000)
struct FDownCameraSettings final
{
public:
	TWeakObjectPtr<class APlayerCharacter>        Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitch;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitch;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmoothSpeed;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDownCameraSettings) == 0x000004, "Wrong alignment on FDownCameraSettings");
static_assert(sizeof(FDownCameraSettings) == 0x000018, "Wrong size on FDownCameraSettings");
static_assert(offsetof(FDownCameraSettings, Target) == 0x000000, "Member 'FDownCameraSettings::Target' has a wrong offset!");
static_assert(offsetof(FDownCameraSettings, TargetIndex) == 0x000008, "Member 'FDownCameraSettings::TargetIndex' has a wrong offset!");
static_assert(offsetof(FDownCameraSettings, MinPitch) == 0x00000C, "Member 'FDownCameraSettings::MinPitch' has a wrong offset!");
static_assert(offsetof(FDownCameraSettings, MaxPitch) == 0x000010, "Member 'FDownCameraSettings::MaxPitch' has a wrong offset!");
static_assert(offsetof(FDownCameraSettings, SmoothSpeed) == 0x000014, "Member 'FDownCameraSettings::SmoothSpeed' has a wrong offset!");

// ScriptStruct FSD.PlatformComponent
// 0x0010 (0x0010 - 0x0000)
struct FPlatformComponent final
{
public:
	TSubclassOf<class UActorComponent>            ComponentClass;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlatformComponentCriteria                    Criteria;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C4[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlatformComponent) == 0x000008, "Wrong alignment on FPlatformComponent");
static_assert(sizeof(FPlatformComponent) == 0x000010, "Wrong size on FPlatformComponent");
static_assert(offsetof(FPlatformComponent, ComponentClass) == 0x000000, "Member 'FPlatformComponent::ComponentClass' has a wrong offset!");
static_assert(offsetof(FPlatformComponent, Criteria) == 0x000008, "Member 'FPlatformComponent::Criteria' has a wrong offset!");

// ScriptStruct FSD.FSDLocalizedChatMessage
// 0x0048 (0x0048 - 0x0000)
struct FFSDLocalizedChatMessage final
{
public:
	uint8                                         Pad_16C5[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EChatMessageType                              MsgType;                                           // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C6[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Sender;                                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Msg;                                               // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FText>                           Arguments;                                         // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDLocalizedChatMessage) == 0x000008, "Wrong alignment on FFSDLocalizedChatMessage");
static_assert(sizeof(FFSDLocalizedChatMessage) == 0x000048, "Wrong size on FFSDLocalizedChatMessage");
static_assert(offsetof(FFSDLocalizedChatMessage, MsgType) == 0x000008, "Member 'FFSDLocalizedChatMessage::MsgType' has a wrong offset!");
static_assert(offsetof(FFSDLocalizedChatMessage, Sender) == 0x000010, "Member 'FFSDLocalizedChatMessage::Sender' has a wrong offset!");
static_assert(offsetof(FFSDLocalizedChatMessage, Msg) == 0x000020, "Member 'FFSDLocalizedChatMessage::Msg' has a wrong offset!");
static_assert(offsetof(FFSDLocalizedChatMessage, Arguments) == 0x000038, "Member 'FFSDLocalizedChatMessage::Arguments' has a wrong offset!");

// ScriptStruct FSD.VanityMasterySave
// 0x0010 (0x0010 - 0x0000)
struct FVanityMasterySave final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAwardedForOldPurchases;                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C7[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FashionitesAwaredForOldPurchases;                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanityMasterySave) == 0x000004, "Wrong alignment on FVanityMasterySave");
static_assert(sizeof(FVanityMasterySave) == 0x000010, "Wrong size on FVanityMasterySave");
static_assert(offsetof(FVanityMasterySave, Level) == 0x000000, "Member 'FVanityMasterySave::Level' has a wrong offset!");
static_assert(offsetof(FVanityMasterySave, XP) == 0x000004, "Member 'FVanityMasterySave::XP' has a wrong offset!");
static_assert(offsetof(FVanityMasterySave, HasAwardedForOldPurchases) == 0x000008, "Member 'FVanityMasterySave::HasAwardedForOldPurchases' has a wrong offset!");
static_assert(offsetof(FVanityMasterySave, FashionitesAwaredForOldPurchases) == 0x00000C, "Member 'FVanityMasterySave::FashionitesAwaredForOldPurchases' has a wrong offset!");

// ScriptStruct FSD.GeneratedDebris
// 0x0058 (0x0058 - 0x0000)
struct FGeneratedDebris final
{
public:
	TMap<class UDebrisBase*, class UObject*>      Debris;                                            // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C8[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratedDebris) == 0x000008, "Wrong alignment on FGeneratedDebris");
static_assert(sizeof(FGeneratedDebris) == 0x000058, "Wrong size on FGeneratedDebris");
static_assert(offsetof(FGeneratedDebris, Debris) == 0x000000, "Member 'FGeneratedDebris::Debris' has a wrong offset!");
static_assert(offsetof(FGeneratedDebris, IsValid) == 0x000050, "Member 'FGeneratedDebris::IsValid' has a wrong offset!");

// ScriptStruct FSD.EventRewardSaveItem
// 0x0020 (0x0020 - 0x0000)
struct FEventRewardSaveItem final
{
public:
	struct FGuid                                  CategoryID;                                        // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          ClassOptions;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventRewardSaveItem) == 0x000008, "Wrong alignment on FEventRewardSaveItem");
static_assert(sizeof(FEventRewardSaveItem) == 0x000020, "Wrong size on FEventRewardSaveItem");
static_assert(offsetof(FEventRewardSaveItem, CategoryID) == 0x000000, "Member 'FEventRewardSaveItem::CategoryID' has a wrong offset!");
static_assert(offsetof(FEventRewardSaveItem, ClassOptions) == 0x000010, "Member 'FEventRewardSaveItem::ClassOptions' has a wrong offset!");

// ScriptStruct FSD.EventRewardSave
// 0x0050 (0x0050 - 0x0000)
struct FEventRewardSave final
{
public:
	TMap<struct FGuid, struct FEventRewardSaveItem> PendingRewards;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventRewardSave) == 0x000008, "Wrong alignment on FEventRewardSave");
static_assert(sizeof(FEventRewardSave) == 0x000050, "Wrong size on FEventRewardSave");
static_assert(offsetof(FEventRewardSave, PendingRewards) == 0x000000, "Member 'FEventRewardSave::PendingRewards' has a wrong offset!");

// ScriptStruct FSD.HookData
// 0x0010 (0x0010 - 0x0000)
struct FHookData final
{
public:
	struct FVector_NetQuantize                    TargetLocation;                                    // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExtending;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C9[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHookData) == 0x000004, "Wrong alignment on FHookData");
static_assert(sizeof(FHookData) == 0x000010, "Wrong size on FHookData");
static_assert(offsetof(FHookData, TargetLocation) == 0x000000, "Member 'FHookData::TargetLocation' has a wrong offset!");
static_assert(offsetof(FHookData, IsExtending) == 0x00000C, "Member 'FHookData::IsExtending' has a wrong offset!");

// ScriptStruct FSD.DamageDataBase
// 0x0030 (0x0030 - 0x0000)
struct FDamageDataBase
{
public:
	class UFSDPhysicalMaterial*                   PhysMaterial;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageImpulse*                         DamageImpulseOverride;                             // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsRadial;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16CA[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageDataBase) == 0x000008, "Wrong alignment on FDamageDataBase");
static_assert(sizeof(FDamageDataBase) == 0x000030, "Wrong size on FDamageDataBase");
static_assert(offsetof(FDamageDataBase, PhysMaterial) == 0x000000, "Member 'FDamageDataBase::PhysMaterial' has a wrong offset!");
static_assert(offsetof(FDamageDataBase, Component) == 0x000008, "Member 'FDamageDataBase::Component' has a wrong offset!");
static_assert(offsetof(FDamageDataBase, HitLocation) == 0x000010, "Member 'FDamageDataBase::HitLocation' has a wrong offset!");
static_assert(offsetof(FDamageDataBase, BoneIndex) == 0x00001C, "Member 'FDamageDataBase::BoneIndex' has a wrong offset!");
static_assert(offsetof(FDamageDataBase, DamageImpulseOverride) == 0x000020, "Member 'FDamageDataBase::DamageImpulseOverride' has a wrong offset!");
static_assert(offsetof(FDamageDataBase, IsRadial) == 0x000028, "Member 'FDamageDataBase::IsRadial' has a wrong offset!");

// ScriptStruct FSD.UINotificationItem
// 0x0010 (0x0010 - 0x0000)
struct FUINotificationItem final
{
public:
	TArray<struct FGuid>                          NotificationIDs;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUINotificationItem) == 0x000008, "Wrong alignment on FUINotificationItem");
static_assert(sizeof(FUINotificationItem) == 0x000010, "Wrong size on FUINotificationItem");
static_assert(offsetof(FUINotificationItem, NotificationIDs) == 0x000000, "Member 'FUINotificationItem::NotificationIDs' has a wrong offset!");

// ScriptStruct FSD.BiomeFeatures
// 0x0010 (0x0010 - 0x0000)
struct FBiomeFeatures final
{
public:
	class UMinersManualData*                      Descriptions[0x2];                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBiomeFeatures) == 0x000008, "Wrong alignment on FBiomeFeatures");
static_assert(sizeof(FBiomeFeatures) == 0x000010, "Wrong size on FBiomeFeatures");
static_assert(offsetof(FBiomeFeatures, Descriptions) == 0x000000, "Member 'FBiomeFeatures::Descriptions' has a wrong offset!");

// ScriptStruct FSD.ColorVisionDeficiencySettings
// 0x0008 (0x0008 - 0x0000)
struct FColorVisionDeficiencySettings final
{
public:
	EColorVisionDeficiency                        Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16CB[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Severity;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorVisionDeficiencySettings) == 0x000004, "Wrong alignment on FColorVisionDeficiencySettings");
static_assert(sizeof(FColorVisionDeficiencySettings) == 0x000008, "Wrong size on FColorVisionDeficiencySettings");
static_assert(offsetof(FColorVisionDeficiencySettings, Type) == 0x000000, "Member 'FColorVisionDeficiencySettings::Type' has a wrong offset!");
static_assert(offsetof(FColorVisionDeficiencySettings, Severity) == 0x000004, "Member 'FColorVisionDeficiencySettings::Severity' has a wrong offset!");

// ScriptStruct FSD.DamageData
// 0x0020 (0x0050 - 0x0030)
struct FDamageData final : public FDamageDataBase
{
public:
	class UDamageClass*                           DamageClass;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AController>             Instigator;                                        // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  DamageCauser;                                      // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageModifier;                                    // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPenetration;                                  // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageData) == 0x000008, "Wrong alignment on FDamageData");
static_assert(sizeof(FDamageData) == 0x000050, "Wrong size on FDamageData");
static_assert(offsetof(FDamageData, DamageClass) == 0x000030, "Member 'FDamageData::DamageClass' has a wrong offset!");
static_assert(offsetof(FDamageData, Instigator) == 0x000038, "Member 'FDamageData::Instigator' has a wrong offset!");
static_assert(offsetof(FDamageData, DamageCauser) == 0x000040, "Member 'FDamageData::DamageCauser' has a wrong offset!");
static_assert(offsetof(FDamageData, DamageModifier) == 0x000048, "Member 'FDamageData::DamageModifier' has a wrong offset!");
static_assert(offsetof(FDamageData, ArmorPenetration) == 0x00004C, "Member 'FDamageData::ArmorPenetration' has a wrong offset!");

// ScriptStruct FSD.RewardsClaimed
// 0x0002 (0x0002 - 0x0000)
struct FRewardsClaimed final
{
public:
	bool                                          NormalClaimed;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SpecialClaimed;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FRewardsClaimed) == 0x000001, "Wrong alignment on FRewardsClaimed");
static_assert(sizeof(FRewardsClaimed) == 0x000002, "Wrong size on FRewardsClaimed");
static_assert(offsetof(FRewardsClaimed, NormalClaimed) == 0x000000, "Member 'FRewardsClaimed::NormalClaimed' has a wrong offset!");
static_assert(offsetof(FRewardsClaimed, SpecialClaimed) == 0x000001, "Member 'FRewardsClaimed::SpecialClaimed' has a wrong offset!");

// ScriptStruct FSD.ChallengeSaveInfo
// 0x0030 (0x0030 - 0x0000)
struct FChallengeSaveInfo final
{
public:
	TArray<int32>                                 StatIndices;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  ChallengeGuid;                                     // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentWins;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfWins;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPCompleteGain;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TokenGain;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeSaveInfo) == 0x000008, "Wrong alignment on FChallengeSaveInfo");
static_assert(sizeof(FChallengeSaveInfo) == 0x000030, "Wrong size on FChallengeSaveInfo");
static_assert(offsetof(FChallengeSaveInfo, StatIndices) == 0x000000, "Member 'FChallengeSaveInfo::StatIndices' has a wrong offset!");
static_assert(offsetof(FChallengeSaveInfo, ChallengeGuid) == 0x000010, "Member 'FChallengeSaveInfo::ChallengeGuid' has a wrong offset!");
static_assert(offsetof(FChallengeSaveInfo, CurrentWins) == 0x000020, "Member 'FChallengeSaveInfo::CurrentWins' has a wrong offset!");
static_assert(offsetof(FChallengeSaveInfo, NumberOfWins) == 0x000024, "Member 'FChallengeSaveInfo::NumberOfWins' has a wrong offset!");
static_assert(offsetof(FChallengeSaveInfo, XPCompleteGain) == 0x000028, "Member 'FChallengeSaveInfo::XPCompleteGain' has a wrong offset!");
static_assert(offsetof(FChallengeSaveInfo, TokenGain) == 0x00002C, "Member 'FChallengeSaveInfo::TokenGain' has a wrong offset!");

// ScriptStruct FSD.SeasonSaveEntry
// 0x0100 (0x0100 - 0x0000)
struct FSeasonSaveEntry final
{
public:
	int32                                         CountSeasonContentDisabled;                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSeasonContentReenabled;                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Tokens;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRewardsClaimed>                RewardsClaimed;                                    // 0x0010(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSeasonCompletedAnnounced;                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasClaimedAllRewards;                              // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16CC[0x2];                                     // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RewardsClaimedAfterMaxLevel;                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, bool>                             NodesBought;                                       // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FChallengeSaveInfo>             ActiveChallenges;                                  // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDateTime                              LastNewChallengeGiven;                             // 0x0088(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              LastChallengeReroll;                               // 0x0090(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, int32>                     CompletedSpecialChallenges;                        // 0x0098(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         ClaimedScripChallenges;                            // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlagueHeartsUsed;                                  // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimePlayedAtSeasonStart;                           // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChallengesCompletedAtSeasonStart;                  // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OptedOutOfSeasonContent;                           // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16CD[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeasonSaveEntry) == 0x000008, "Wrong alignment on FSeasonSaveEntry");
static_assert(sizeof(FSeasonSaveEntry) == 0x000100, "Wrong size on FSeasonSaveEntry");
static_assert(offsetof(FSeasonSaveEntry, CountSeasonContentDisabled) == 0x000000, "Member 'FSeasonSaveEntry::CountSeasonContentDisabled' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, CountSeasonContentReenabled) == 0x000004, "Member 'FSeasonSaveEntry::CountSeasonContentReenabled' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, XP) == 0x000008, "Member 'FSeasonSaveEntry::XP' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, Tokens) == 0x00000C, "Member 'FSeasonSaveEntry::Tokens' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, RewardsClaimed) == 0x000010, "Member 'FSeasonSaveEntry::RewardsClaimed' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, bSeasonCompletedAnnounced) == 0x000020, "Member 'FSeasonSaveEntry::bSeasonCompletedAnnounced' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, HasClaimedAllRewards) == 0x000021, "Member 'FSeasonSaveEntry::HasClaimedAllRewards' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, RewardsClaimedAfterMaxLevel) == 0x000024, "Member 'FSeasonSaveEntry::RewardsClaimedAfterMaxLevel' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, NodesBought) == 0x000028, "Member 'FSeasonSaveEntry::NodesBought' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, ActiveChallenges) == 0x000078, "Member 'FSeasonSaveEntry::ActiveChallenges' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, LastNewChallengeGiven) == 0x000088, "Member 'FSeasonSaveEntry::LastNewChallengeGiven' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, LastChallengeReroll) == 0x000090, "Member 'FSeasonSaveEntry::LastChallengeReroll' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, CompletedSpecialChallenges) == 0x000098, "Member 'FSeasonSaveEntry::CompletedSpecialChallenges' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, ClaimedScripChallenges) == 0x0000E8, "Member 'FSeasonSaveEntry::ClaimedScripChallenges' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, PlagueHeartsUsed) == 0x0000EC, "Member 'FSeasonSaveEntry::PlagueHeartsUsed' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, TimePlayedAtSeasonStart) == 0x0000F0, "Member 'FSeasonSaveEntry::TimePlayedAtSeasonStart' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, ChallengesCompletedAtSeasonStart) == 0x0000F4, "Member 'FSeasonSaveEntry::ChallengesCompletedAtSeasonStart' has a wrong offset!");
static_assert(offsetof(FSeasonSaveEntry, OptedOutOfSeasonContent) == 0x0000F8, "Member 'FSeasonSaveEntry::OptedOutOfSeasonContent' has a wrong offset!");

// ScriptStruct FSD.BiomeEnemyEntry
// 0x0010 (0x0010 - 0x0000)
struct FBiomeEnemyEntry final
{
public:
	class UEnemyDescriptor*                       Enemy;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDistruptive;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16CE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBiomeEnemyEntry) == 0x000008, "Wrong alignment on FBiomeEnemyEntry");
static_assert(sizeof(FBiomeEnemyEntry) == 0x000010, "Wrong size on FBiomeEnemyEntry");
static_assert(offsetof(FBiomeEnemyEntry, Enemy) == 0x000000, "Member 'FBiomeEnemyEntry::Enemy' has a wrong offset!");
static_assert(offsetof(FBiomeEnemyEntry, IsDistruptive) == 0x000008, "Member 'FBiomeEnemyEntry::IsDistruptive' has a wrong offset!");

// ScriptStruct FSD.CharacterViewInfo
// 0x0038 (0x0038 - 0x0000)
struct FCharacterViewInfo final
{
public:
	TSubclassOf<class APlayerCharacter>           CharacterClass;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquippedVanity                        EquippedVanity;                                    // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          SurvivedInPod;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16CF[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVictoryPose*                           VictoryPose;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterViewInfo) == 0x000008, "Wrong alignment on FCharacterViewInfo");
static_assert(sizeof(FCharacterViewInfo) == 0x000038, "Wrong size on FCharacterViewInfo");
static_assert(offsetof(FCharacterViewInfo, CharacterClass) == 0x000000, "Member 'FCharacterViewInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FCharacterViewInfo, EquippedVanity) == 0x000008, "Member 'FCharacterViewInfo::EquippedVanity' has a wrong offset!");
static_assert(offsetof(FCharacterViewInfo, SurvivedInPod) == 0x000028, "Member 'FCharacterViewInfo::SurvivedInPod' has a wrong offset!");
static_assert(offsetof(FCharacterViewInfo, VictoryPose) == 0x000030, "Member 'FCharacterViewInfo::VictoryPose' has a wrong offset!");

// ScriptStruct FSD.CharacterViewScene
// 0x0018 (0x0018 - 0x0000)
struct FCharacterViewScene final
{
public:
	TArray<struct FCharacterViewInfo>             Characters;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          MissionSuccess;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D0[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterViewScene) == 0x000008, "Wrong alignment on FCharacterViewScene");
static_assert(sizeof(FCharacterViewScene) == 0x000018, "Wrong size on FCharacterViewScene");
static_assert(offsetof(FCharacterViewScene, Characters) == 0x000000, "Member 'FCharacterViewScene::Characters' has a wrong offset!");
static_assert(offsetof(FCharacterViewScene, MissionSuccess) == 0x000010, "Member 'FCharacterViewScene::MissionSuccess' has a wrong offset!");

// ScriptStruct FSD.MissionHazardSetting
// 0x0020 (0x0020 - 0x0000)
struct FMissionHazardSetting final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         HazardBonus;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D1[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionHazardSetting) == 0x000008, "Wrong alignment on FMissionHazardSetting");
static_assert(sizeof(FMissionHazardSetting) == 0x000020, "Wrong size on FMissionHazardSetting");
static_assert(offsetof(FMissionHazardSetting, Name) == 0x000000, "Member 'FMissionHazardSetting::Name' has a wrong offset!");
static_assert(offsetof(FMissionHazardSetting, HazardBonus) == 0x000018, "Member 'FMissionHazardSetting::HazardBonus' has a wrong offset!");

// ScriptStruct FSD.ActiveCampaignItem
// 0x0018 (0x0018 - 0x0000)
struct FActiveCampaignItem final
{
public:
	struct FGuid                                  CampaignID;                                        // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progress;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveCampaignItem) == 0x000004, "Wrong alignment on FActiveCampaignItem");
static_assert(sizeof(FActiveCampaignItem) == 0x000018, "Wrong size on FActiveCampaignItem");
static_assert(offsetof(FActiveCampaignItem, CampaignID) == 0x000000, "Member 'FActiveCampaignItem::CampaignID' has a wrong offset!");
static_assert(offsetof(FActiveCampaignItem, Progress) == 0x000010, "Member 'FActiveCampaignItem::Progress' has a wrong offset!");
static_assert(offsetof(FActiveCampaignItem, Seed) == 0x000014, "Member 'FActiveCampaignItem::Seed' has a wrong offset!");

// ScriptStruct FSD.WeeklyCampaignItem
// 0x000C (0x000C - 0x0000)
struct FWeeklyCampaignItem final
{
public:
	int32                                         LastCompletedWeek;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastStartedWeek;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardedProgress;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeeklyCampaignItem) == 0x000004, "Wrong alignment on FWeeklyCampaignItem");
static_assert(sizeof(FWeeklyCampaignItem) == 0x00000C, "Wrong size on FWeeklyCampaignItem");
static_assert(offsetof(FWeeklyCampaignItem, LastCompletedWeek) == 0x000000, "Member 'FWeeklyCampaignItem::LastCompletedWeek' has a wrong offset!");
static_assert(offsetof(FWeeklyCampaignItem, LastStartedWeek) == 0x000004, "Member 'FWeeklyCampaignItem::LastStartedWeek' has a wrong offset!");
static_assert(offsetof(FWeeklyCampaignItem, RewardedProgress) == 0x000008, "Member 'FWeeklyCampaignItem::RewardedProgress' has a wrong offset!");

// ScriptStruct FSD.CampaignSave
// 0x0050 (0x0050 - 0x0000)
struct FCampaignSave final
{
public:
	struct FActiveCampaignItem                    ActiveCampaign;                                    // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          CompletedCampaigns;                                // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ActiveCampaignWeek;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeeklyCampaignItem                    WeeklySave;                                        // 0x002C(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeeklyCampaignItem                    MaxtrixCoreHuntSave;                               // 0x0038(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeeklyCampaignItem                    SeededRandomSave;                                  // 0x0044(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCampaignSave) == 0x000008, "Wrong alignment on FCampaignSave");
static_assert(sizeof(FCampaignSave) == 0x000050, "Wrong size on FCampaignSave");
static_assert(offsetof(FCampaignSave, ActiveCampaign) == 0x000000, "Member 'FCampaignSave::ActiveCampaign' has a wrong offset!");
static_assert(offsetof(FCampaignSave, CompletedCampaigns) == 0x000018, "Member 'FCampaignSave::CompletedCampaigns' has a wrong offset!");
static_assert(offsetof(FCampaignSave, ActiveCampaignWeek) == 0x000028, "Member 'FCampaignSave::ActiveCampaignWeek' has a wrong offset!");
static_assert(offsetof(FCampaignSave, WeeklySave) == 0x00002C, "Member 'FCampaignSave::WeeklySave' has a wrong offset!");
static_assert(offsetof(FCampaignSave, MaxtrixCoreHuntSave) == 0x000038, "Member 'FCampaignSave::MaxtrixCoreHuntSave' has a wrong offset!");
static_assert(offsetof(FCampaignSave, SeededRandomSave) == 0x000044, "Member 'FCampaignSave::SeededRandomSave' has a wrong offset!");

// ScriptStruct FSD.CraftingCost
// 0x0010 (0x0010 - 0x0000)
struct FCraftingCost final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amount;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D2[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCraftingCost) == 0x000008, "Wrong alignment on FCraftingCost");
static_assert(sizeof(FCraftingCost) == 0x000010, "Wrong size on FCraftingCost");
static_assert(offsetof(FCraftingCost, Resource) == 0x000000, "Member 'FCraftingCost::Resource' has a wrong offset!");
static_assert(offsetof(FCraftingCost, Amount) == 0x000008, "Member 'FCraftingCost::Amount' has a wrong offset!");

// ScriptStruct FSD.NetworkConnectionInfo
// 0x0020 (0x0020 - 0x0000)
struct FNetworkConnectionInfo final
{
public:
	class AFSDPlayerController*                   PlayerController;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PacketLossIn;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PacketLossOut;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ping;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Jitter;                                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D3[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkConnectionInfo) == 0x000008, "Wrong alignment on FNetworkConnectionInfo");
static_assert(sizeof(FNetworkConnectionInfo) == 0x000020, "Wrong size on FNetworkConnectionInfo");
static_assert(offsetof(FNetworkConnectionInfo, PlayerController) == 0x000000, "Member 'FNetworkConnectionInfo::PlayerController' has a wrong offset!");
static_assert(offsetof(FNetworkConnectionInfo, PacketLossIn) == 0x000008, "Member 'FNetworkConnectionInfo::PacketLossIn' has a wrong offset!");
static_assert(offsetof(FNetworkConnectionInfo, PacketLossOut) == 0x00000C, "Member 'FNetworkConnectionInfo::PacketLossOut' has a wrong offset!");
static_assert(offsetof(FNetworkConnectionInfo, Ping) == 0x000010, "Member 'FNetworkConnectionInfo::Ping' has a wrong offset!");
static_assert(offsetof(FNetworkConnectionInfo, Jitter) == 0x000014, "Member 'FNetworkConnectionInfo::Jitter' has a wrong offset!");
static_assert(offsetof(FNetworkConnectionInfo, IsValid) == 0x000018, "Member 'FNetworkConnectionInfo::IsValid' has a wrong offset!");

// ScriptStruct FSD.FSDServerSearchOptions
// 0x0050 (0x0050 - 0x0000)
struct FFSDServerSearchOptions final
{
public:
	ESteamServerJoinStatus                        JoinStatus;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESteamSearchRegion                            SearchRegion;                                      // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D4[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDifficultySetting*>             Difficulties;                                      // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DeepDive;                                          // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D5[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SearchString;                                      // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionSeed;                                       // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalMissionSeed;                                 // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D6[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameType>                             GameTypes;                                         // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDServerSearchOptions) == 0x000008, "Wrong alignment on FFSDServerSearchOptions");
static_assert(sizeof(FFSDServerSearchOptions) == 0x000050, "Wrong size on FFSDServerSearchOptions");
static_assert(offsetof(FFSDServerSearchOptions, JoinStatus) == 0x000000, "Member 'FFSDServerSearchOptions::JoinStatus' has a wrong offset!");
static_assert(offsetof(FFSDServerSearchOptions, SearchRegion) == 0x000001, "Member 'FFSDServerSearchOptions::SearchRegion' has a wrong offset!");
static_assert(offsetof(FFSDServerSearchOptions, Difficulties) == 0x000008, "Member 'FFSDServerSearchOptions::Difficulties' has a wrong offset!");
static_assert(offsetof(FFSDServerSearchOptions, DeepDive) == 0x000018, "Member 'FFSDServerSearchOptions::DeepDive' has a wrong offset!");
static_assert(offsetof(FFSDServerSearchOptions, SearchString) == 0x000020, "Member 'FFSDServerSearchOptions::SearchString' has a wrong offset!");
static_assert(offsetof(FFSDServerSearchOptions, MissionSeed) == 0x000030, "Member 'FFSDServerSearchOptions::MissionSeed' has a wrong offset!");
static_assert(offsetof(FFSDServerSearchOptions, GlobalMissionSeed) == 0x000034, "Member 'FFSDServerSearchOptions::GlobalMissionSeed' has a wrong offset!");
static_assert(offsetof(FFSDServerSearchOptions, GameTypes) == 0x000040, "Member 'FFSDServerSearchOptions::GameTypes' has a wrong offset!");

// ScriptStruct FSD.ForgingResult
// 0x000C (0x000C - 0x0000)
struct FForgingResult final
{
public:
	bool                                          LevelledUp;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D7[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RewardLevel;                                       // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardSeed;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForgingResult) == 0x000004, "Wrong alignment on FForgingResult");
static_assert(sizeof(FForgingResult) == 0x00000C, "Wrong size on FForgingResult");
static_assert(offsetof(FForgingResult, LevelledUp) == 0x000000, "Member 'FForgingResult::LevelledUp' has a wrong offset!");
static_assert(offsetof(FForgingResult, RewardLevel) == 0x000004, "Member 'FForgingResult::RewardLevel' has a wrong offset!");
static_assert(offsetof(FForgingResult, RewardSeed) == 0x000008, "Member 'FForgingResult::RewardSeed' has a wrong offset!");

// ScriptStruct FSD.ItemAnimationItem
// 0x0018 (0x0018 - 0x0000)
struct FItemAnimationItem final
{
public:
	class UAnimMontage*                           FP_CharacterMontage;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TP_CharacterMontage;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ItemMontage;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemAnimationItem) == 0x000008, "Wrong alignment on FItemAnimationItem");
static_assert(sizeof(FItemAnimationItem) == 0x000018, "Wrong size on FItemAnimationItem");
static_assert(offsetof(FItemAnimationItem, FP_CharacterMontage) == 0x000000, "Member 'FItemAnimationItem::FP_CharacterMontage' has a wrong offset!");
static_assert(offsetof(FItemAnimationItem, TP_CharacterMontage) == 0x000008, "Member 'FItemAnimationItem::TP_CharacterMontage' has a wrong offset!");
static_assert(offsetof(FItemAnimationItem, ItemMontage) == 0x000010, "Member 'FItemAnimationItem::ItemMontage' has a wrong offset!");

// ScriptStruct FSD.PushPoint
// 0x0010 (0x0010 - 0x0000)
struct FPushPoint final
{
public:
	class USphereComponent*                       Collider;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       Character;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPushPoint) == 0x000008, "Wrong alignment on FPushPoint");
static_assert(sizeof(FPushPoint) == 0x000010, "Wrong size on FPushPoint");
static_assert(offsetof(FPushPoint, Collider) == 0x000000, "Member 'FPushPoint::Collider' has a wrong offset!");
static_assert(offsetof(FPushPoint, Character) == 0x000008, "Member 'FPushPoint::Character' has a wrong offset!");

// ScriptStruct FSD.TrackMovement
// 0x000C (0x000C - 0x0000)
struct FTrackMovement final
{
public:
	int32                                         Direction;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackMovement) == 0x000004, "Wrong alignment on FTrackMovement");
static_assert(sizeof(FTrackMovement) == 0x00000C, "Wrong size on FTrackMovement");
static_assert(offsetof(FTrackMovement, Direction) == 0x000000, "Member 'FTrackMovement::Direction' has a wrong offset!");
static_assert(offsetof(FTrackMovement, Distance) == 0x000004, "Member 'FTrackMovement::Distance' has a wrong offset!");
static_assert(offsetof(FTrackMovement, Speed) == 0x000008, "Member 'FTrackMovement::Speed' has a wrong offset!");

// ScriptStruct FSD.ItemUpgradeSelection
// 0x0078 (0x0078 - 0x0000)
struct FItemUpgradeSelection final
{
public:
	struct FGuid                                  WeaponID;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          EquippedUpgrades;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          PermanentUpgrades;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedOverclock;                                 // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          EquippedSkins;                                     // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          OverclockingUnlocked;                              // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D8[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  EquippedSkinColor;                                 // 0x0054(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  EquippedSkinMesh;                                  // 0x0064(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16D9[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemUpgradeSelection) == 0x000008, "Wrong alignment on FItemUpgradeSelection");
static_assert(sizeof(FItemUpgradeSelection) == 0x000078, "Wrong size on FItemUpgradeSelection");
static_assert(offsetof(FItemUpgradeSelection, WeaponID) == 0x000000, "Member 'FItemUpgradeSelection::WeaponID' has a wrong offset!");
static_assert(offsetof(FItemUpgradeSelection, EquippedUpgrades) == 0x000010, "Member 'FItemUpgradeSelection::EquippedUpgrades' has a wrong offset!");
static_assert(offsetof(FItemUpgradeSelection, PermanentUpgrades) == 0x000020, "Member 'FItemUpgradeSelection::PermanentUpgrades' has a wrong offset!");
static_assert(offsetof(FItemUpgradeSelection, EquippedOverclock) == 0x000030, "Member 'FItemUpgradeSelection::EquippedOverclock' has a wrong offset!");
static_assert(offsetof(FItemUpgradeSelection, EquippedSkins) == 0x000040, "Member 'FItemUpgradeSelection::EquippedSkins' has a wrong offset!");
static_assert(offsetof(FItemUpgradeSelection, OverclockingUnlocked) == 0x000050, "Member 'FItemUpgradeSelection::OverclockingUnlocked' has a wrong offset!");
static_assert(offsetof(FItemUpgradeSelection, EquippedSkinColor) == 0x000054, "Member 'FItemUpgradeSelection::EquippedSkinColor' has a wrong offset!");
static_assert(offsetof(FItemUpgradeSelection, EquippedSkinMesh) == 0x000064, "Member 'FItemUpgradeSelection::EquippedSkinMesh' has a wrong offset!");

// ScriptStruct FSD.FSDChatMessage
// 0x0060 (0x0060 - 0x0000)
struct FFSDChatMessage final
{
public:
	uint8                                         Pad_16DA[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EChatMessageType                              MsgType;                                           // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16DB[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Sender;                                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatSenderType                               SenderType;                                        // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16DC[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Msg;                                               // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       SenderNetID;                                       // 0x0038(0x0028)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDChatMessage) == 0x000008, "Wrong alignment on FFSDChatMessage");
static_assert(sizeof(FFSDChatMessage) == 0x000060, "Wrong size on FFSDChatMessage");
static_assert(offsetof(FFSDChatMessage, MsgType) == 0x000008, "Member 'FFSDChatMessage::MsgType' has a wrong offset!");
static_assert(offsetof(FFSDChatMessage, Sender) == 0x000010, "Member 'FFSDChatMessage::Sender' has a wrong offset!");
static_assert(offsetof(FFSDChatMessage, SenderType) == 0x000020, "Member 'FFSDChatMessage::SenderType' has a wrong offset!");
static_assert(offsetof(FFSDChatMessage, Msg) == 0x000028, "Member 'FFSDChatMessage::Msg' has a wrong offset!");
static_assert(offsetof(FFSDChatMessage, SenderNetID) == 0x000038, "Member 'FFSDChatMessage::SenderNetID' has a wrong offset!");

// ScriptStruct FSD.UnLockedMissionParameters
// 0x0020 (0x0020 - 0x0000)
struct FUnLockedMissionParameters final
{
public:
	TArray<struct FGuid>                          UnLockedComplexities;                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          UnLockedDurations;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnLockedMissionParameters) == 0x000008, "Wrong alignment on FUnLockedMissionParameters");
static_assert(sizeof(FUnLockedMissionParameters) == 0x000020, "Wrong size on FUnLockedMissionParameters");
static_assert(offsetof(FUnLockedMissionParameters, UnLockedComplexities) == 0x000000, "Member 'FUnLockedMissionParameters::UnLockedComplexities' has a wrong offset!");
static_assert(offsetof(FUnLockedMissionParameters, UnLockedDurations) == 0x000010, "Member 'FUnLockedMissionParameters::UnLockedDurations' has a wrong offset!");

// ScriptStruct FSD.LocalizedLanguageInfo
// 0x0038 (0x0038 - 0x0000)
struct FLocalizedLanguageInfo final
{
public:
	class FString                                 EnglishName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NativeName;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CodeName;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CommunityTranslated;                               // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16DD[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TranslatedPercent;                                 // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalizedLanguageInfo) == 0x000008, "Wrong alignment on FLocalizedLanguageInfo");
static_assert(sizeof(FLocalizedLanguageInfo) == 0x000038, "Wrong size on FLocalizedLanguageInfo");
static_assert(offsetof(FLocalizedLanguageInfo, EnglishName) == 0x000000, "Member 'FLocalizedLanguageInfo::EnglishName' has a wrong offset!");
static_assert(offsetof(FLocalizedLanguageInfo, NativeName) == 0x000010, "Member 'FLocalizedLanguageInfo::NativeName' has a wrong offset!");
static_assert(offsetof(FLocalizedLanguageInfo, CodeName) == 0x000020, "Member 'FLocalizedLanguageInfo::CodeName' has a wrong offset!");
static_assert(offsetof(FLocalizedLanguageInfo, CommunityTranslated) == 0x000030, "Member 'FLocalizedLanguageInfo::CommunityTranslated' has a wrong offset!");
static_assert(offsetof(FLocalizedLanguageInfo, TranslatedPercent) == 0x000034, "Member 'FLocalizedLanguageInfo::TranslatedPercent' has a wrong offset!");

// ScriptStruct FSD.VanityMasteryResult
// 0x0024 (0x0024 - 0x0000)
struct FVanityMasteryResult final
{
public:
	struct FVanityMasterySave                     Previous;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVanityMasterySave                     Current;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         FashionitesRewarded;                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanityMasteryResult) == 0x000004, "Wrong alignment on FVanityMasteryResult");
static_assert(sizeof(FVanityMasteryResult) == 0x000024, "Wrong size on FVanityMasteryResult");
static_assert(offsetof(FVanityMasteryResult, Previous) == 0x000000, "Member 'FVanityMasteryResult::Previous' has a wrong offset!");
static_assert(offsetof(FVanityMasteryResult, Current) == 0x000010, "Member 'FVanityMasteryResult::Current' has a wrong offset!");
static_assert(offsetof(FVanityMasteryResult, FashionitesRewarded) == 0x000020, "Member 'FVanityMasteryResult::FashionitesRewarded' has a wrong offset!");

// ScriptStruct FSD.CustomKeySetting
// 0x0038 (0x0038 - 0x0000)
struct FCustomKeySetting final
{
public:
	class FName                                   SaveID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActionNames;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EKeyBindingAxis                               ActionAxis;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16DE[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomKeySetting) == 0x000008, "Wrong alignment on FCustomKeySetting");
static_assert(sizeof(FCustomKeySetting) == 0x000038, "Wrong size on FCustomKeySetting");
static_assert(offsetof(FCustomKeySetting, SaveID) == 0x000000, "Member 'FCustomKeySetting::SaveID' has a wrong offset!");
static_assert(offsetof(FCustomKeySetting, Description) == 0x000008, "Member 'FCustomKeySetting::Description' has a wrong offset!");
static_assert(offsetof(FCustomKeySetting, ActionNames) == 0x000020, "Member 'FCustomKeySetting::ActionNames' has a wrong offset!");
static_assert(offsetof(FCustomKeySetting, ActionAxis) == 0x000030, "Member 'FCustomKeySetting::ActionAxis' has a wrong offset!");

// ScriptStruct FSD.SonyInputSettings
// 0x0030 (0x0030 - 0x0000)
struct FSonyInputSettings final
{
public:
	bool                                          MotionControlEnabled;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16DF[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionControlXSensitivity;                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionControlYSensitivity;                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotionControlPrecisionMode;                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotionControlSalute;                               // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotionControlFlight;                               // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESonyControllerMotionMapping                  MotionXMapping;                                    // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AdaptiveTriggersEnabled;                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E0[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControllerSpeakerVolume;                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ControllerSpeakerMissionControl;                   // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ControllerSpeakerSalute;                           // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ControllerSpeakerFlare;                            // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ControllerSpeakerMineralCollection;                // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TouchPadTerrainScannerEnabled;                     // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E1[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TouchPadTerrainScannerXSensitivity;                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TouchPadTerrainScannerYSensitivity;                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TouchPadTerrainScannerZoomSensitivity;             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TouchPadGesturesEnabled;                           // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESonyControllerLightMode                      ControllerLightMode;                               // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E2[0x2];                                     // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSonyInputSettings) == 0x000004, "Wrong alignment on FSonyInputSettings");
static_assert(sizeof(FSonyInputSettings) == 0x000030, "Wrong size on FSonyInputSettings");
static_assert(offsetof(FSonyInputSettings, MotionControlEnabled) == 0x000000, "Member 'FSonyInputSettings::MotionControlEnabled' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, MotionControlXSensitivity) == 0x000004, "Member 'FSonyInputSettings::MotionControlXSensitivity' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, MotionControlYSensitivity) == 0x000008, "Member 'FSonyInputSettings::MotionControlYSensitivity' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, MotionControlPrecisionMode) == 0x00000C, "Member 'FSonyInputSettings::MotionControlPrecisionMode' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, MotionControlSalute) == 0x00000D, "Member 'FSonyInputSettings::MotionControlSalute' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, MotionControlFlight) == 0x00000E, "Member 'FSonyInputSettings::MotionControlFlight' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, MotionXMapping) == 0x00000F, "Member 'FSonyInputSettings::MotionXMapping' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, AdaptiveTriggersEnabled) == 0x000010, "Member 'FSonyInputSettings::AdaptiveTriggersEnabled' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, ControllerSpeakerVolume) == 0x000014, "Member 'FSonyInputSettings::ControllerSpeakerVolume' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, ControllerSpeakerMissionControl) == 0x000018, "Member 'FSonyInputSettings::ControllerSpeakerMissionControl' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, ControllerSpeakerSalute) == 0x000019, "Member 'FSonyInputSettings::ControllerSpeakerSalute' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, ControllerSpeakerFlare) == 0x00001A, "Member 'FSonyInputSettings::ControllerSpeakerFlare' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, ControllerSpeakerMineralCollection) == 0x00001B, "Member 'FSonyInputSettings::ControllerSpeakerMineralCollection' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, TouchPadTerrainScannerEnabled) == 0x00001C, "Member 'FSonyInputSettings::TouchPadTerrainScannerEnabled' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, TouchPadTerrainScannerXSensitivity) == 0x000020, "Member 'FSonyInputSettings::TouchPadTerrainScannerXSensitivity' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, TouchPadTerrainScannerYSensitivity) == 0x000024, "Member 'FSonyInputSettings::TouchPadTerrainScannerYSensitivity' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, TouchPadTerrainScannerZoomSensitivity) == 0x000028, "Member 'FSonyInputSettings::TouchPadTerrainScannerZoomSensitivity' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, TouchPadGesturesEnabled) == 0x00002C, "Member 'FSonyInputSettings::TouchPadGesturesEnabled' has a wrong offset!");
static_assert(offsetof(FSonyInputSettings, ControllerLightMode) == 0x00002D, "Member 'FSonyInputSettings::ControllerLightMode' has a wrong offset!");

// ScriptStruct FSD.GDKWinOptionsInSaveGame
// 0x0070 (0x0070 - 0x0000)
struct FGDKWinOptionsInSaveGame final
{
public:
	bool                                          SaveGameOptionsValid;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E3[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenMode;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ResolutionSizeX;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ResolutionSizeY;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVSync;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E4[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrameRateLimit;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sharpening;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingType;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gamma;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverallQuality;                                    // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResolutionScale;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureQuality;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadowQuality;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingQuality;                               // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostProcessingQuality;                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectsQuality;                                    // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewDistanceQuality;                               // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventLatejoinCharacterDuplication;               // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E5[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocalGameServerName;                               // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentAudioOutputDeviceId;                        // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDefaultAudioOutputDevice;                       // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E6[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGDKWinOptionsInSaveGame) == 0x000008, "Wrong alignment on FGDKWinOptionsInSaveGame");
static_assert(sizeof(FGDKWinOptionsInSaveGame) == 0x000070, "Wrong size on FGDKWinOptionsInSaveGame");
static_assert(offsetof(FGDKWinOptionsInSaveGame, SaveGameOptionsValid) == 0x000000, "Member 'FGDKWinOptionsInSaveGame::SaveGameOptionsValid' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, ScreenMode) == 0x000004, "Member 'FGDKWinOptionsInSaveGame::ScreenMode' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, ResolutionSizeX) == 0x000008, "Member 'FGDKWinOptionsInSaveGame::ResolutionSizeX' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, ResolutionSizeY) == 0x00000C, "Member 'FGDKWinOptionsInSaveGame::ResolutionSizeY' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, bUseVSync) == 0x000010, "Member 'FGDKWinOptionsInSaveGame::bUseVSync' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, FrameRateLimit) == 0x000014, "Member 'FGDKWinOptionsInSaveGame::FrameRateLimit' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, Sharpening) == 0x000018, "Member 'FGDKWinOptionsInSaveGame::Sharpening' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, AntiAliasingType) == 0x00001C, "Member 'FGDKWinOptionsInSaveGame::AntiAliasingType' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, Gamma) == 0x000020, "Member 'FGDKWinOptionsInSaveGame::Gamma' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, OverallQuality) == 0x000024, "Member 'FGDKWinOptionsInSaveGame::OverallQuality' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, ResolutionScale) == 0x000028, "Member 'FGDKWinOptionsInSaveGame::ResolutionScale' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, TextureQuality) == 0x00002C, "Member 'FGDKWinOptionsInSaveGame::TextureQuality' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, ShadowQuality) == 0x000030, "Member 'FGDKWinOptionsInSaveGame::ShadowQuality' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, AntiAliasingQuality) == 0x000034, "Member 'FGDKWinOptionsInSaveGame::AntiAliasingQuality' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, PostProcessingQuality) == 0x000038, "Member 'FGDKWinOptionsInSaveGame::PostProcessingQuality' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, EffectsQuality) == 0x00003C, "Member 'FGDKWinOptionsInSaveGame::EffectsQuality' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, ViewDistanceQuality) == 0x000040, "Member 'FGDKWinOptionsInSaveGame::ViewDistanceQuality' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, PreventLatejoinCharacterDuplication) == 0x000044, "Member 'FGDKWinOptionsInSaveGame::PreventLatejoinCharacterDuplication' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, LocalGameServerName) == 0x000048, "Member 'FGDKWinOptionsInSaveGame::LocalGameServerName' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, CurrentAudioOutputDeviceId) == 0x000058, "Member 'FGDKWinOptionsInSaveGame::CurrentAudioOutputDeviceId' has a wrong offset!");
static_assert(offsetof(FGDKWinOptionsInSaveGame, UseDefaultAudioOutputDevice) == 0x000068, "Member 'FGDKWinOptionsInSaveGame::UseDefaultAudioOutputDevice' has a wrong offset!");

// ScriptStruct FSD.DeepDiveLoaderSequence
// 0x0028 (0x0028 - 0x0000)
struct FDeepDiveLoaderSequence final
{
public:
	TSoftObjectPtr<class ULevelSequence>          LevelSequence;                                     // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeepDiveLoaderSequence) == 0x000008, "Wrong alignment on FDeepDiveLoaderSequence");
static_assert(sizeof(FDeepDiveLoaderSequence) == 0x000028, "Wrong size on FDeepDiveLoaderSequence");
static_assert(offsetof(FDeepDiveLoaderSequence, LevelSequence) == 0x000000, "Member 'FDeepDiveLoaderSequence::LevelSequence' has a wrong offset!");

// ScriptStruct FSD.GDStats
// 0x0148 (0x0148 - 0x0000)
struct FGDStats final
{
public:
	class UPawnStat*                              MaxAmmo;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MaxShields;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ShieldRegenerationRate;                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MaxHealth;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              DamageResistance;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              FireResistance;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ColdResistance;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MeleeAttackDamage;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MovementSpeed;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              AirControl;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              SprintSpeed;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              CarryingSpeedModifier;                             // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ReviveSpeed;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              DepositSpeed;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              RessuplySpeed;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              RedSugarHeal;                                      // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              CarryingCapacity;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ZiplineSpeed;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ZiplineDownwardsBoost;                             // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              SlideDownIce;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              FriendlyFire;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              DamageFromPlayers;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              DamageBonus;                                       // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              FlareThrowingStrength;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              CaveLeechSense;                                    // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MorkiteMining;                                     // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              GoldMining;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              RockMiningStrength;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              DirtMiningStrength;                                // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ResourceMiningStrength;                            // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              PowerAttackCooldownRate;                           // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ImpactCompensation;                                // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MovementSpeedPenalty;                              // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MovementSpeedPenaltyReduction;                     // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MovementSpeedEnvironmentalPenalty;                 // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              MovementSpeedEnvironmentalPenaltyReduction;        // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              CarriableThrowing;                                 // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              HoverBootsDuration;                                // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              ExplodeOnDeath;                                    // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              CritChance;                                        // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnStat*                              CritDamageBonus;                                   // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDStats) == 0x000008, "Wrong alignment on FGDStats");
static_assert(sizeof(FGDStats) == 0x000148, "Wrong size on FGDStats");
static_assert(offsetof(FGDStats, MaxAmmo) == 0x000000, "Member 'FGDStats::MaxAmmo' has a wrong offset!");
static_assert(offsetof(FGDStats, MaxShields) == 0x000008, "Member 'FGDStats::MaxShields' has a wrong offset!");
static_assert(offsetof(FGDStats, ShieldRegenerationRate) == 0x000010, "Member 'FGDStats::ShieldRegenerationRate' has a wrong offset!");
static_assert(offsetof(FGDStats, MaxHealth) == 0x000018, "Member 'FGDStats::MaxHealth' has a wrong offset!");
static_assert(offsetof(FGDStats, DamageResistance) == 0x000020, "Member 'FGDStats::DamageResistance' has a wrong offset!");
static_assert(offsetof(FGDStats, FireResistance) == 0x000028, "Member 'FGDStats::FireResistance' has a wrong offset!");
static_assert(offsetof(FGDStats, ColdResistance) == 0x000030, "Member 'FGDStats::ColdResistance' has a wrong offset!");
static_assert(offsetof(FGDStats, MeleeAttackDamage) == 0x000038, "Member 'FGDStats::MeleeAttackDamage' has a wrong offset!");
static_assert(offsetof(FGDStats, MovementSpeed) == 0x000040, "Member 'FGDStats::MovementSpeed' has a wrong offset!");
static_assert(offsetof(FGDStats, AirControl) == 0x000048, "Member 'FGDStats::AirControl' has a wrong offset!");
static_assert(offsetof(FGDStats, SprintSpeed) == 0x000050, "Member 'FGDStats::SprintSpeed' has a wrong offset!");
static_assert(offsetof(FGDStats, CarryingSpeedModifier) == 0x000058, "Member 'FGDStats::CarryingSpeedModifier' has a wrong offset!");
static_assert(offsetof(FGDStats, ReviveSpeed) == 0x000060, "Member 'FGDStats::ReviveSpeed' has a wrong offset!");
static_assert(offsetof(FGDStats, DepositSpeed) == 0x000068, "Member 'FGDStats::DepositSpeed' has a wrong offset!");
static_assert(offsetof(FGDStats, RessuplySpeed) == 0x000070, "Member 'FGDStats::RessuplySpeed' has a wrong offset!");
static_assert(offsetof(FGDStats, RedSugarHeal) == 0x000078, "Member 'FGDStats::RedSugarHeal' has a wrong offset!");
static_assert(offsetof(FGDStats, CarryingCapacity) == 0x000080, "Member 'FGDStats::CarryingCapacity' has a wrong offset!");
static_assert(offsetof(FGDStats, ZiplineSpeed) == 0x000088, "Member 'FGDStats::ZiplineSpeed' has a wrong offset!");
static_assert(offsetof(FGDStats, ZiplineDownwardsBoost) == 0x000090, "Member 'FGDStats::ZiplineDownwardsBoost' has a wrong offset!");
static_assert(offsetof(FGDStats, SlideDownIce) == 0x000098, "Member 'FGDStats::SlideDownIce' has a wrong offset!");
static_assert(offsetof(FGDStats, FriendlyFire) == 0x0000A0, "Member 'FGDStats::FriendlyFire' has a wrong offset!");
static_assert(offsetof(FGDStats, DamageFromPlayers) == 0x0000A8, "Member 'FGDStats::DamageFromPlayers' has a wrong offset!");
static_assert(offsetof(FGDStats, DamageBonus) == 0x0000B0, "Member 'FGDStats::DamageBonus' has a wrong offset!");
static_assert(offsetof(FGDStats, FlareThrowingStrength) == 0x0000B8, "Member 'FGDStats::FlareThrowingStrength' has a wrong offset!");
static_assert(offsetof(FGDStats, CaveLeechSense) == 0x0000C0, "Member 'FGDStats::CaveLeechSense' has a wrong offset!");
static_assert(offsetof(FGDStats, MorkiteMining) == 0x0000C8, "Member 'FGDStats::MorkiteMining' has a wrong offset!");
static_assert(offsetof(FGDStats, GoldMining) == 0x0000D0, "Member 'FGDStats::GoldMining' has a wrong offset!");
static_assert(offsetof(FGDStats, RockMiningStrength) == 0x0000D8, "Member 'FGDStats::RockMiningStrength' has a wrong offset!");
static_assert(offsetof(FGDStats, DirtMiningStrength) == 0x0000E0, "Member 'FGDStats::DirtMiningStrength' has a wrong offset!");
static_assert(offsetof(FGDStats, ResourceMiningStrength) == 0x0000E8, "Member 'FGDStats::ResourceMiningStrength' has a wrong offset!");
static_assert(offsetof(FGDStats, PowerAttackCooldownRate) == 0x0000F0, "Member 'FGDStats::PowerAttackCooldownRate' has a wrong offset!");
static_assert(offsetof(FGDStats, ImpactCompensation) == 0x0000F8, "Member 'FGDStats::ImpactCompensation' has a wrong offset!");
static_assert(offsetof(FGDStats, MovementSpeedPenalty) == 0x000100, "Member 'FGDStats::MovementSpeedPenalty' has a wrong offset!");
static_assert(offsetof(FGDStats, MovementSpeedPenaltyReduction) == 0x000108, "Member 'FGDStats::MovementSpeedPenaltyReduction' has a wrong offset!");
static_assert(offsetof(FGDStats, MovementSpeedEnvironmentalPenalty) == 0x000110, "Member 'FGDStats::MovementSpeedEnvironmentalPenalty' has a wrong offset!");
static_assert(offsetof(FGDStats, MovementSpeedEnvironmentalPenaltyReduction) == 0x000118, "Member 'FGDStats::MovementSpeedEnvironmentalPenaltyReduction' has a wrong offset!");
static_assert(offsetof(FGDStats, CarriableThrowing) == 0x000120, "Member 'FGDStats::CarriableThrowing' has a wrong offset!");
static_assert(offsetof(FGDStats, HoverBootsDuration) == 0x000128, "Member 'FGDStats::HoverBootsDuration' has a wrong offset!");
static_assert(offsetof(FGDStats, ExplodeOnDeath) == 0x000130, "Member 'FGDStats::ExplodeOnDeath' has a wrong offset!");
static_assert(offsetof(FGDStats, CritChance) == 0x000138, "Member 'FGDStats::CritChance' has a wrong offset!");
static_assert(offsetof(FGDStats, CritDamageBonus) == 0x000140, "Member 'FGDStats::CritDamageBonus' has a wrong offset!");

// ScriptStruct FSD.ControllerSettings
// 0x0010 (0x0010 - 0x0000)
struct FControllerSettings final
{
public:
	float                                         AimInnerDeadZone;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSensitivity;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOuterAcceleration;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETurn180Mode                                  Turn180Mode;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviousItemEnabled;                              // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChatEnabled;                                      // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E7[0x1];                                     // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControllerSettings) == 0x000004, "Wrong alignment on FControllerSettings");
static_assert(sizeof(FControllerSettings) == 0x000010, "Wrong size on FControllerSettings");
static_assert(offsetof(FControllerSettings, AimInnerDeadZone) == 0x000000, "Member 'FControllerSettings::AimInnerDeadZone' has a wrong offset!");
static_assert(offsetof(FControllerSettings, AimSensitivity) == 0x000004, "Member 'FControllerSettings::AimSensitivity' has a wrong offset!");
static_assert(offsetof(FControllerSettings, AimOuterAcceleration) == 0x000008, "Member 'FControllerSettings::AimOuterAcceleration' has a wrong offset!");
static_assert(offsetof(FControllerSettings, Turn180Mode) == 0x00000C, "Member 'FControllerSettings::Turn180Mode' has a wrong offset!");
static_assert(offsetof(FControllerSettings, bPreviousItemEnabled) == 0x00000D, "Member 'FControllerSettings::bPreviousItemEnabled' has a wrong offset!");
static_assert(offsetof(FControllerSettings, bChatEnabled) == 0x00000E, "Member 'FControllerSettings::bChatEnabled' has a wrong offset!");

// ScriptStruct FSD.HUDElementData
// 0x0008 (0x0008 - 0x0000)
struct FHUDElementData final
{
public:
	EHUDVisibilityMode                            Mode;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E8[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Version;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHUDElementData) == 0x000004, "Wrong alignment on FHUDElementData");
static_assert(sizeof(FHUDElementData) == 0x000008, "Wrong size on FHUDElementData");
static_assert(offsetof(FHUDElementData, Mode) == 0x000000, "Member 'FHUDElementData::Mode' has a wrong offset!");
static_assert(offsetof(FHUDElementData, Version) == 0x000004, "Member 'FHUDElementData::Version' has a wrong offset!");

// ScriptStruct FSD.HUDElements
// 0x0080 (0x0080 - 0x0000)
struct FHUDElements final
{
public:
	struct FHUDElementData                        OnScreenHelp;                                      // 0x0000(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        EnemyHealth;                                       // 0x0008(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        RadarDepth;                                        // 0x0010(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        PlayerHealthShield;                                // 0x0018(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        PlayerNameClassIcon;                               // 0x0020(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        PlayerItems;                                       // 0x0028(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        PlayerResources;                                   // 0x0030(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        WeaponInfo;                                        // 0x0038(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        Grenades;                                          // 0x0040(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        FlashLight;                                        // 0x0048(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        Flares;                                            // 0x0050(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        Crosshair;                                         // 0x0058(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        Objectives;                                        // 0x0060(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        TeamDisplay;                                       // 0x0068(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        SentryGunDisplay;                                  // 0x0070(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHUDElementData                        VersionNumber;                                     // 0x0078(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHUDElements) == 0x000004, "Wrong alignment on FHUDElements");
static_assert(sizeof(FHUDElements) == 0x000080, "Wrong size on FHUDElements");
static_assert(offsetof(FHUDElements, OnScreenHelp) == 0x000000, "Member 'FHUDElements::OnScreenHelp' has a wrong offset!");
static_assert(offsetof(FHUDElements, EnemyHealth) == 0x000008, "Member 'FHUDElements::EnemyHealth' has a wrong offset!");
static_assert(offsetof(FHUDElements, RadarDepth) == 0x000010, "Member 'FHUDElements::RadarDepth' has a wrong offset!");
static_assert(offsetof(FHUDElements, PlayerHealthShield) == 0x000018, "Member 'FHUDElements::PlayerHealthShield' has a wrong offset!");
static_assert(offsetof(FHUDElements, PlayerNameClassIcon) == 0x000020, "Member 'FHUDElements::PlayerNameClassIcon' has a wrong offset!");
static_assert(offsetof(FHUDElements, PlayerItems) == 0x000028, "Member 'FHUDElements::PlayerItems' has a wrong offset!");
static_assert(offsetof(FHUDElements, PlayerResources) == 0x000030, "Member 'FHUDElements::PlayerResources' has a wrong offset!");
static_assert(offsetof(FHUDElements, WeaponInfo) == 0x000038, "Member 'FHUDElements::WeaponInfo' has a wrong offset!");
static_assert(offsetof(FHUDElements, Grenades) == 0x000040, "Member 'FHUDElements::Grenades' has a wrong offset!");
static_assert(offsetof(FHUDElements, FlashLight) == 0x000048, "Member 'FHUDElements::FlashLight' has a wrong offset!");
static_assert(offsetof(FHUDElements, Flares) == 0x000050, "Member 'FHUDElements::Flares' has a wrong offset!");
static_assert(offsetof(FHUDElements, Crosshair) == 0x000058, "Member 'FHUDElements::Crosshair' has a wrong offset!");
static_assert(offsetof(FHUDElements, Objectives) == 0x000060, "Member 'FHUDElements::Objectives' has a wrong offset!");
static_assert(offsetof(FHUDElements, TeamDisplay) == 0x000068, "Member 'FHUDElements::TeamDisplay' has a wrong offset!");
static_assert(offsetof(FHUDElements, SentryGunDisplay) == 0x000070, "Member 'FHUDElements::SentryGunDisplay' has a wrong offset!");
static_assert(offsetof(FHUDElements, VersionNumber) == 0x000078, "Member 'FHUDElements::VersionNumber' has a wrong offset!");

// ScriptStruct FSD.CharacterOptions
// 0x0004 (0x0004 - 0x0000)
struct FCharacterOptions final
{
public:
	bool                                          GrapplingHookAutoSwitch;                           // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ZiplineGunAutoSwitch;                              // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HoldToBreakImmobilization;                         // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HoldToFire;                                        // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterOptions) == 0x000001, "Wrong alignment on FCharacterOptions");
static_assert(sizeof(FCharacterOptions) == 0x000004, "Wrong size on FCharacterOptions");
static_assert(offsetof(FCharacterOptions, GrapplingHookAutoSwitch) == 0x000000, "Member 'FCharacterOptions::GrapplingHookAutoSwitch' has a wrong offset!");
static_assert(offsetof(FCharacterOptions, ZiplineGunAutoSwitch) == 0x000001, "Member 'FCharacterOptions::ZiplineGunAutoSwitch' has a wrong offset!");
static_assert(offsetof(FCharacterOptions, HoldToBreakImmobilization) == 0x000002, "Member 'FCharacterOptions::HoldToBreakImmobilization' has a wrong offset!");
static_assert(offsetof(FCharacterOptions, HoldToFire) == 0x000003, "Member 'FCharacterOptions::HoldToFire' has a wrong offset!");

// ScriptStruct FSD.ConsoleOptionsInSaveGame
// 0x0148 (0x0148 - 0x0000)
struct FConsoleOptionsInSaveGame final
{
public:
	struct FControllerSettings                    ControllerSettings;                                // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FHUDElements                           HUDElements;                                       // 0x0010(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          SaveGameOptionsValid;                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTutorialHintsEnabled;                             // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFPS;                                          // 0x0092(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E9[0x1];                                     // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShowNetInfoLevel;                                  // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadbobbingScale;                                  // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeScale;                                  // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIDPIScale;                                        // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeCharacterVoice;                              // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMaster;                                      // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMissionControl;                              // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeSFX;                                         // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMusic;                                       // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSubtitles;                                    // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertMouse;                                       // 0x00BD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PhotosensitiveMode;                                // 0x00BE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldToSprint;                                     // 0x00BF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleLaserPointer;                               // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleTerrainScanner;                             // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMouseSmoothing;                                // 0x00C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16EA[0x1];                                     // 0x00C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseXSensitivity;                                 // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseYSensitivity;                                 // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSeperateSensitivity;                           // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertMouseWheel;                                 // 0x00CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertIncapacitatedX_Mouse;                       // 0x00CE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertIncapacitatedX_Controller;                  // 0x00CF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertFlightControls;                             // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUIAnimations;                                 // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaySoundOnChatMessage;                           // 0x00D2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16EB[0x1];                                     // 0x00D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChatFadeTime;                                      // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceFeedbackScale;                                // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChatFontSize;                                      // 0x00DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRColorGamma;                                     // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConsoleGraphicsMode                          ConsoleGraphicsMode;                               // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16EC[0x3];                                     // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterOptions                      CharacterOptions;                                  // 0x00F8(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16ED[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomKeyBinding>              CustomKeyBindings;                                 // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCustomKeyBinding>              CustomControllerBindings;                          // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SwapControllerThumbsticks;                         // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16EE[0x3];                                     // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FSDResolutionScale;                                // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpscalingType;                                     // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmdFsrMode;                                        // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmdFsr2Mode;                                       // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUDLSSMode                                    NvidiaDlssMode;                                    // 0x0134(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16EF[0x3];                                     // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmdFsrSharpness;                                   // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmdFsr2Sharpness;                                  // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NvidiaDlssSharpness;                               // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F0[0x4];                                     // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConsoleOptionsInSaveGame) == 0x000008, "Wrong alignment on FConsoleOptionsInSaveGame");
static_assert(sizeof(FConsoleOptionsInSaveGame) == 0x000148, "Wrong size on FConsoleOptionsInSaveGame");
static_assert(offsetof(FConsoleOptionsInSaveGame, ControllerSettings) == 0x000000, "Member 'FConsoleOptionsInSaveGame::ControllerSettings' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, HUDElements) == 0x000010, "Member 'FConsoleOptionsInSaveGame::HUDElements' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, SaveGameOptionsValid) == 0x000090, "Member 'FConsoleOptionsInSaveGame::SaveGameOptionsValid' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bTutorialHintsEnabled) == 0x000091, "Member 'FConsoleOptionsInSaveGame::bTutorialHintsEnabled' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bShowFPS) == 0x000092, "Member 'FConsoleOptionsInSaveGame::bShowFPS' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, ShowNetInfoLevel) == 0x000094, "Member 'FConsoleOptionsInSaveGame::ShowNetInfoLevel' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, FOV) == 0x000098, "Member 'FConsoleOptionsInSaveGame::FOV' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, HeadbobbingScale) == 0x00009C, "Member 'FConsoleOptionsInSaveGame::HeadbobbingScale' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, CameraShakeScale) == 0x0000A0, "Member 'FConsoleOptionsInSaveGame::CameraShakeScale' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, UIDPIScale) == 0x0000A4, "Member 'FConsoleOptionsInSaveGame::UIDPIScale' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, VolumeCharacterVoice) == 0x0000A8, "Member 'FConsoleOptionsInSaveGame::VolumeCharacterVoice' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, VolumeMaster) == 0x0000AC, "Member 'FConsoleOptionsInSaveGame::VolumeMaster' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, VolumeMissionControl) == 0x0000B0, "Member 'FConsoleOptionsInSaveGame::VolumeMissionControl' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, VolumeSFX) == 0x0000B4, "Member 'FConsoleOptionsInSaveGame::VolumeSFX' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, VolumeMusic) == 0x0000B8, "Member 'FConsoleOptionsInSaveGame::VolumeMusic' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bShowSubtitles) == 0x0000BC, "Member 'FConsoleOptionsInSaveGame::bShowSubtitles' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, InvertMouse) == 0x0000BD, "Member 'FConsoleOptionsInSaveGame::InvertMouse' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, PhotosensitiveMode) == 0x0000BE, "Member 'FConsoleOptionsInSaveGame::PhotosensitiveMode' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bHoldToSprint) == 0x0000BF, "Member 'FConsoleOptionsInSaveGame::bHoldToSprint' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bToggleLaserPointer) == 0x0000C0, "Member 'FConsoleOptionsInSaveGame::bToggleLaserPointer' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bToggleTerrainScanner) == 0x0000C1, "Member 'FConsoleOptionsInSaveGame::bToggleTerrainScanner' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bUseMouseSmoothing) == 0x0000C2, "Member 'FConsoleOptionsInSaveGame::bUseMouseSmoothing' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, MouseXSensitivity) == 0x0000C4, "Member 'FConsoleOptionsInSaveGame::MouseXSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, MouseYSensitivity) == 0x0000C8, "Member 'FConsoleOptionsInSaveGame::MouseYSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bUseSeperateSensitivity) == 0x0000CC, "Member 'FConsoleOptionsInSaveGame::bUseSeperateSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bInvertMouseWheel) == 0x0000CD, "Member 'FConsoleOptionsInSaveGame::bInvertMouseWheel' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bInvertIncapacitatedX_Mouse) == 0x0000CE, "Member 'FConsoleOptionsInSaveGame::bInvertIncapacitatedX_Mouse' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bInvertIncapacitatedX_Controller) == 0x0000CF, "Member 'FConsoleOptionsInSaveGame::bInvertIncapacitatedX_Controller' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bInvertFlightControls) == 0x0000D0, "Member 'FConsoleOptionsInSaveGame::bInvertFlightControls' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bShowUIAnimations) == 0x0000D1, "Member 'FConsoleOptionsInSaveGame::bShowUIAnimations' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, bPlaySoundOnChatMessage) == 0x0000D2, "Member 'FConsoleOptionsInSaveGame::bPlaySoundOnChatMessage' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, ChatFadeTime) == 0x0000D4, "Member 'FConsoleOptionsInSaveGame::ChatFadeTime' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, ForceFeedbackScale) == 0x0000D8, "Member 'FConsoleOptionsInSaveGame::ForceFeedbackScale' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, ChatFontSize) == 0x0000DC, "Member 'FConsoleOptionsInSaveGame::ChatFontSize' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, HDRColorGamma) == 0x0000E0, "Member 'FConsoleOptionsInSaveGame::HDRColorGamma' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, ConsoleGraphicsMode) == 0x0000E4, "Member 'FConsoleOptionsInSaveGame::ConsoleGraphicsMode' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, Language) == 0x0000E8, "Member 'FConsoleOptionsInSaveGame::Language' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, CharacterOptions) == 0x0000F8, "Member 'FConsoleOptionsInSaveGame::CharacterOptions' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, CustomKeyBindings) == 0x000100, "Member 'FConsoleOptionsInSaveGame::CustomKeyBindings' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, CustomControllerBindings) == 0x000110, "Member 'FConsoleOptionsInSaveGame::CustomControllerBindings' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, SwapControllerThumbsticks) == 0x000120, "Member 'FConsoleOptionsInSaveGame::SwapControllerThumbsticks' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, FSDResolutionScale) == 0x000124, "Member 'FConsoleOptionsInSaveGame::FSDResolutionScale' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, UpscalingType) == 0x000128, "Member 'FConsoleOptionsInSaveGame::UpscalingType' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, AmdFsrMode) == 0x00012C, "Member 'FConsoleOptionsInSaveGame::AmdFsrMode' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, AmdFsr2Mode) == 0x000130, "Member 'FConsoleOptionsInSaveGame::AmdFsr2Mode' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, NvidiaDlssMode) == 0x000134, "Member 'FConsoleOptionsInSaveGame::NvidiaDlssMode' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, AmdFsrSharpness) == 0x000138, "Member 'FConsoleOptionsInSaveGame::AmdFsrSharpness' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, AmdFsr2Sharpness) == 0x00013C, "Member 'FConsoleOptionsInSaveGame::AmdFsr2Sharpness' has a wrong offset!");
static_assert(offsetof(FConsoleOptionsInSaveGame, NvidiaDlssSharpness) == 0x000140, "Member 'FConsoleOptionsInSaveGame::NvidiaDlssSharpness' has a wrong offset!");

// ScriptStruct FSD.FakeMoveState
// 0x0024 (0x0024 - 0x0000)
struct FFakeMoveState
{
public:
	struct FVector                                Pos1;                                              // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos2;                                              // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vel;                                               // 0x0018(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFakeMoveState) == 0x000004, "Wrong alignment on FFakeMoveState");
static_assert(sizeof(FFakeMoveState) == 0x000024, "Wrong size on FFakeMoveState");
static_assert(offsetof(FFakeMoveState, Pos1) == 0x000000, "Member 'FFakeMoveState::Pos1' has a wrong offset!");
static_assert(offsetof(FFakeMoveState, Pos2) == 0x00000C, "Member 'FFakeMoveState::Pos2' has a wrong offset!");
static_assert(offsetof(FFakeMoveState, Vel) == 0x000018, "Member 'FFakeMoveState::Vel' has a wrong offset!");

// ScriptStruct FSD.FSDWeeklySeedResponse
// 0x0018 (0x0018 - 0x0000)
struct FFSDWeeklySeedResponse final
{
public:
	uint32                                        Seed;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F1[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExpirationTime;                                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDWeeklySeedResponse) == 0x000008, "Wrong alignment on FFSDWeeklySeedResponse");
static_assert(sizeof(FFSDWeeklySeedResponse) == 0x000018, "Wrong size on FFSDWeeklySeedResponse");
static_assert(offsetof(FFSDWeeklySeedResponse, Seed) == 0x000000, "Member 'FFSDWeeklySeedResponse::Seed' has a wrong offset!");
static_assert(offsetof(FFSDWeeklySeedResponse, ExpirationTime) == 0x000008, "Member 'FFSDWeeklySeedResponse::ExpirationTime' has a wrong offset!");

// ScriptStruct FSD.ScalingMeshAfflictionItem
// 0x0018 (0x0018 - 0x0000)
struct FScalingMeshAfflictionItem final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandRange                             MeshScale;                                         // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EFrozenBitsSize                               FrozenBitsSize;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F2[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToSpawn;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScalingMeshAfflictionItem) == 0x000004, "Wrong alignment on FScalingMeshAfflictionItem");
static_assert(sizeof(FScalingMeshAfflictionItem) == 0x000018, "Wrong size on FScalingMeshAfflictionItem");
static_assert(offsetof(FScalingMeshAfflictionItem, BoneName) == 0x000000, "Member 'FScalingMeshAfflictionItem::BoneName' has a wrong offset!");
static_assert(offsetof(FScalingMeshAfflictionItem, MeshScale) == 0x000008, "Member 'FScalingMeshAfflictionItem::MeshScale' has a wrong offset!");
static_assert(offsetof(FScalingMeshAfflictionItem, FrozenBitsSize) == 0x000010, "Member 'FScalingMeshAfflictionItem::FrozenBitsSize' has a wrong offset!");
static_assert(offsetof(FScalingMeshAfflictionItem, ChanceToSpawn) == 0x000014, "Member 'FScalingMeshAfflictionItem::ChanceToSpawn' has a wrong offset!");

// ScriptStruct FSD.NotificationEntry
// 0x0030 (0x0030 - 0x0000)
struct FNotificationEntry final
{
public:
	class UObject*                                ObjectInstance;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WindowClass;                                       // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNotificationEntry) == 0x000008, "Wrong alignment on FNotificationEntry");
static_assert(sizeof(FNotificationEntry) == 0x000030, "Wrong size on FNotificationEntry");
static_assert(offsetof(FNotificationEntry, ObjectInstance) == 0x000000, "Member 'FNotificationEntry::ObjectInstance' has a wrong offset!");
static_assert(offsetof(FNotificationEntry, WindowClass) == 0x000008, "Member 'FNotificationEntry::WindowClass' has a wrong offset!");

// ScriptStruct FSD.CommunityGoalTierDataRequest
// 0x0010 (0x0010 - 0x0000)
struct FCommunityGoalTierDataRequest final
{
public:
	class FString                                 GoalID;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityGoalTierDataRequest) == 0x000008, "Wrong alignment on FCommunityGoalTierDataRequest");
static_assert(sizeof(FCommunityGoalTierDataRequest) == 0x000010, "Wrong size on FCommunityGoalTierDataRequest");
static_assert(offsetof(FCommunityGoalTierDataRequest, GoalID) == 0x000000, "Member 'FCommunityGoalTierDataRequest::GoalID' has a wrong offset!");

// ScriptStruct FSD.WatchedTutorial
// 0x0018 (0x0018 - 0x0000)
struct FWatchedTutorial final
{
public:
	class FString                                 TutorialName;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F3[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWatchedTutorial) == 0x000008, "Wrong alignment on FWatchedTutorial");
static_assert(sizeof(FWatchedTutorial) == 0x000018, "Wrong size on FWatchedTutorial");
static_assert(offsetof(FWatchedTutorial, TutorialName) == 0x000000, "Member 'FWatchedTutorial::TutorialName' has a wrong offset!");
static_assert(offsetof(FWatchedTutorial, Count) == 0x000010, "Member 'FWatchedTutorial::Count' has a wrong offset!");

// ScriptStruct FSD.GDPerks
// 0x0090 (0x0090 - 0x0000)
struct FGDPerks final
{
public:
	TArray<class UPerkAsset*>                     PerkAssets;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RequiredClaimsPerTier;                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        IronWill;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        DashPerk;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        MarathonPerk;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        ShieldLink;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        Bezerk;                                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        JumpBoots;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        ImpactCompensators;                                // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        BeastMaster;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        DownedBomb;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        FieldMedic;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        HeightenedSenses;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        HoverBoots;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        ActivePerkSlots;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatPerkAsset*                        PassivePerkSlots;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDPerks) == 0x000008, "Wrong alignment on FGDPerks");
static_assert(sizeof(FGDPerks) == 0x000090, "Wrong size on FGDPerks");
static_assert(offsetof(FGDPerks, PerkAssets) == 0x000000, "Member 'FGDPerks::PerkAssets' has a wrong offset!");
static_assert(offsetof(FGDPerks, RequiredClaimsPerTier) == 0x000010, "Member 'FGDPerks::RequiredClaimsPerTier' has a wrong offset!");
static_assert(offsetof(FGDPerks, IronWill) == 0x000020, "Member 'FGDPerks::IronWill' has a wrong offset!");
static_assert(offsetof(FGDPerks, DashPerk) == 0x000028, "Member 'FGDPerks::DashPerk' has a wrong offset!");
static_assert(offsetof(FGDPerks, MarathonPerk) == 0x000030, "Member 'FGDPerks::MarathonPerk' has a wrong offset!");
static_assert(offsetof(FGDPerks, ShieldLink) == 0x000038, "Member 'FGDPerks::ShieldLink' has a wrong offset!");
static_assert(offsetof(FGDPerks, Bezerk) == 0x000040, "Member 'FGDPerks::Bezerk' has a wrong offset!");
static_assert(offsetof(FGDPerks, JumpBoots) == 0x000048, "Member 'FGDPerks::JumpBoots' has a wrong offset!");
static_assert(offsetof(FGDPerks, ImpactCompensators) == 0x000050, "Member 'FGDPerks::ImpactCompensators' has a wrong offset!");
static_assert(offsetof(FGDPerks, BeastMaster) == 0x000058, "Member 'FGDPerks::BeastMaster' has a wrong offset!");
static_assert(offsetof(FGDPerks, DownedBomb) == 0x000060, "Member 'FGDPerks::DownedBomb' has a wrong offset!");
static_assert(offsetof(FGDPerks, FieldMedic) == 0x000068, "Member 'FGDPerks::FieldMedic' has a wrong offset!");
static_assert(offsetof(FGDPerks, HeightenedSenses) == 0x000070, "Member 'FGDPerks::HeightenedSenses' has a wrong offset!");
static_assert(offsetof(FGDPerks, HoverBoots) == 0x000078, "Member 'FGDPerks::HoverBoots' has a wrong offset!");
static_assert(offsetof(FGDPerks, ActivePerkSlots) == 0x000080, "Member 'FGDPerks::ActivePerkSlots' has a wrong offset!");
static_assert(offsetof(FGDPerks, PassivePerkSlots) == 0x000088, "Member 'FGDPerks::PassivePerkSlots' has a wrong offset!");

// ScriptStruct FSD.ResourcesSave
// 0x00A0 (0x00A0 - 0x0000)
struct FResourcesSave final
{
public:
	TMap<struct FGuid, float>                     OwnedResources;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<class UResourceData*, float>             Resources;                                         // 0x0050(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FResourcesSave) == 0x000008, "Wrong alignment on FResourcesSave");
static_assert(sizeof(FResourcesSave) == 0x0000A0, "Wrong size on FResourcesSave");
static_assert(offsetof(FResourcesSave, OwnedResources) == 0x000000, "Member 'FResourcesSave::OwnedResources' has a wrong offset!");
static_assert(offsetof(FResourcesSave, Resources) == 0x000050, "Member 'FResourcesSave::Resources' has a wrong offset!");

// ScriptStruct FSD.ItemUINotifications
// 0x0068 (0x0068 - 0x0000)
struct FItemUINotifications final
{
public:
	TArray<struct FUINotificationItem>            UINotifications;                                   // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGuid>                            UINotificationSet;                                 // 0x0010(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UFSDSaveGame*                           SaveGame;                                          // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FItemUINotifications) == 0x000008, "Wrong alignment on FItemUINotifications");
static_assert(sizeof(FItemUINotifications) == 0x000068, "Wrong size on FItemUINotifications");
static_assert(offsetof(FItemUINotifications, UINotifications) == 0x000000, "Member 'FItemUINotifications::UINotifications' has a wrong offset!");
static_assert(offsetof(FItemUINotifications, UINotificationSet) == 0x000010, "Member 'FItemUINotifications::UINotificationSet' has a wrong offset!");
static_assert(offsetof(FItemUINotifications, SaveGame) == 0x000060, "Member 'FItemUINotifications::SaveGame' has a wrong offset!");

// ScriptStruct FSD.EliminationDescriptors
// 0x0010 (0x0010 - 0x0000)
struct FEliminationDescriptors final
{
public:
	TArray<class UEnemyDescriptor*>               Descriptors;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEliminationDescriptors) == 0x000008, "Wrong alignment on FEliminationDescriptors");
static_assert(sizeof(FEliminationDescriptors) == 0x000010, "Wrong size on FEliminationDescriptors");
static_assert(offsetof(FEliminationDescriptors, Descriptors) == 0x000000, "Member 'FEliminationDescriptors::Descriptors' has a wrong offset!");

// ScriptStruct FSD.SkinList
// 0x0050 (0x0050 - 0x0000)
struct FSkinList final
{
public:
	TSet<struct FGuid>                            Skins;                                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinList) == 0x000008, "Wrong alignment on FSkinList");
static_assert(sizeof(FSkinList) == 0x000050, "Wrong size on FSkinList");
static_assert(offsetof(FSkinList, Skins) == 0x000000, "Member 'FSkinList::Skins' has a wrong offset!");

// ScriptStruct FSD.ItemNotificationInfo
// 0x0004 (0x0004 - 0x0000)
struct FItemNotificationInfo final
{
public:
	int32                                         NotificationFlags;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemNotificationInfo) == 0x000004, "Wrong alignment on FItemNotificationInfo");
static_assert(sizeof(FItemNotificationInfo) == 0x000004, "Wrong size on FItemNotificationInfo");
static_assert(offsetof(FItemNotificationInfo, NotificationFlags) == 0x000000, "Member 'FItemNotificationInfo::NotificationFlags' has a wrong offset!");

// ScriptStruct FSD.HitscanDelayedImpact
// 0x0028 (0x0028 - 0x0000)
struct FHitscanDelayedImpact final
{
public:
	uint8                                         Pad_16F4[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              ImpactSound;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FirstPersonImpactSound;                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F5[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitscanDelayedImpact) == 0x000008, "Wrong alignment on FHitscanDelayedImpact");
static_assert(sizeof(FHitscanDelayedImpact) == 0x000028, "Wrong size on FHitscanDelayedImpact");
static_assert(offsetof(FHitscanDelayedImpact, ImpactSound) == 0x000008, "Member 'FHitscanDelayedImpact::ImpactSound' has a wrong offset!");
static_assert(offsetof(FHitscanDelayedImpact, FirstPersonImpactSound) == 0x000010, "Member 'FHitscanDelayedImpact::FirstPersonImpactSound' has a wrong offset!");

// ScriptStruct FSD.UpgradeLoadout
// 0x0050 (0x0050 - 0x0000)
struct FUpgradeLoadout final
{
public:
	TMap<struct FGuid, struct FItemUpgradeSelection> Loadout;                                           // 0x0000(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FUpgradeLoadout) == 0x000008, "Wrong alignment on FUpgradeLoadout");
static_assert(sizeof(FUpgradeLoadout) == 0x000050, "Wrong size on FUpgradeLoadout");
static_assert(offsetof(FUpgradeLoadout, Loadout) == 0x000000, "Member 'FUpgradeLoadout::Loadout' has a wrong offset!");

// ScriptStruct FSD.RandFloatIntervalItem
// 0x000C (0x000C - 0x0000)
struct FRandFloatIntervalItem final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandRange                             Range;                                             // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandFloatIntervalItem) == 0x000004, "Wrong alignment on FRandFloatIntervalItem");
static_assert(sizeof(FRandFloatIntervalItem) == 0x00000C, "Wrong size on FRandFloatIntervalItem");
static_assert(offsetof(FRandFloatIntervalItem, Weight) == 0x000000, "Member 'FRandFloatIntervalItem::Weight' has a wrong offset!");
static_assert(offsetof(FRandFloatIntervalItem, Range) == 0x000004, "Member 'FRandFloatIntervalItem::Range' has a wrong offset!");

// ScriptStruct FSD.DrinkSave
// 0x0058 (0x0058 - 0x0000)
struct FDrinkSave final
{
public:
	TSet<struct FGuid>                            UnlockedDrinks;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	bool                                          HasUnlockedSpecial;                                // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F6[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDrinkSave) == 0x000008, "Wrong alignment on FDrinkSave");
static_assert(sizeof(FDrinkSave) == 0x000058, "Wrong size on FDrinkSave");
static_assert(offsetof(FDrinkSave, UnlockedDrinks) == 0x000000, "Member 'FDrinkSave::UnlockedDrinks' has a wrong offset!");
static_assert(offsetof(FDrinkSave, HasUnlockedSpecial) == 0x000050, "Member 'FDrinkSave::HasUnlockedSpecial' has a wrong offset!");

// ScriptStruct FSD.TesterName
// 0x0020 (0x0028 - 0x0008)
struct FTesterName final : public FTableRowBase
{
public:
	class FString                                 SteamID;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SteamProfileName;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTesterName) == 0x000008, "Wrong alignment on FTesterName");
static_assert(sizeof(FTesterName) == 0x000028, "Wrong size on FTesterName");
static_assert(offsetof(FTesterName, SteamID) == 0x000008, "Member 'FTesterName::SteamID' has a wrong offset!");
static_assert(offsetof(FTesterName, SteamProfileName) == 0x000018, "Member 'FTesterName::SteamProfileName' has a wrong offset!");

// ScriptStruct FSD.DebrisCellNoiseParameters
// 0x0010 (0x0010 - 0x0000)
struct FDebrisCellNoiseParameters final
{
public:
	class UDebrisCellNoise*                       Noise;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCellValue;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCellValue;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebrisCellNoiseParameters) == 0x000008, "Wrong alignment on FDebrisCellNoiseParameters");
static_assert(sizeof(FDebrisCellNoiseParameters) == 0x000010, "Wrong size on FDebrisCellNoiseParameters");
static_assert(offsetof(FDebrisCellNoiseParameters, Noise) == 0x000000, "Member 'FDebrisCellNoiseParameters::Noise' has a wrong offset!");
static_assert(offsetof(FDebrisCellNoiseParameters, MinCellValue) == 0x000008, "Member 'FDebrisCellNoiseParameters::MinCellValue' has a wrong offset!");
static_assert(offsetof(FDebrisCellNoiseParameters, MaxCellValue) == 0x00000C, "Member 'FDebrisCellNoiseParameters::MaxCellValue' has a wrong offset!");

// ScriptStruct FSD.ForgingPendingReward
// 0x0008 (0x0008 - 0x0000)
struct FForgingPendingReward final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForgingPendingReward) == 0x000004, "Wrong alignment on FForgingPendingReward");
static_assert(sizeof(FForgingPendingReward) == 0x000008, "Wrong size on FForgingPendingReward");
static_assert(offsetof(FForgingPendingReward, Level) == 0x000000, "Member 'FForgingPendingReward::Level' has a wrong offset!");
static_assert(offsetof(FForgingPendingReward, Seed) == 0x000004, "Member 'FForgingPendingReward::Seed' has a wrong offset!");

// ScriptStruct FSD.ForgingSave
// 0x0018 (0x0018 - 0x0000)
struct FForgingSave final
{
public:
	int32                                         XP;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16F7[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FForgingPendingReward>          PendingMasteryRewards;                             // 0x0008(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FForgingSave) == 0x000008, "Wrong alignment on FForgingSave");
static_assert(sizeof(FForgingSave) == 0x000018, "Wrong size on FForgingSave");
static_assert(offsetof(FForgingSave, XP) == 0x000000, "Member 'FForgingSave::XP' has a wrong offset!");
static_assert(offsetof(FForgingSave, PendingMasteryRewards) == 0x000008, "Member 'FForgingSave::PendingMasteryRewards' has a wrong offset!");

// ScriptStruct FSD.DiscordServerData
// 0x0008 (0x0008 - 0x0000)
struct FDiscordServerData final
{
public:
	int32                                         PresenceCount;                                     // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemberCount;                                       // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordServerData) == 0x000004, "Wrong alignment on FDiscordServerData");
static_assert(sizeof(FDiscordServerData) == 0x000008, "Wrong size on FDiscordServerData");
static_assert(offsetof(FDiscordServerData, PresenceCount) == 0x000000, "Member 'FDiscordServerData::PresenceCount' has a wrong offset!");
static_assert(offsetof(FDiscordServerData, MemberCount) == 0x000004, "Member 'FDiscordServerData::MemberCount' has a wrong offset!");

// ScriptStruct FSD.HealthBarLooks
// 0x0020 (0x0020 - 0x0000)
struct FHealthBarLooks final
{
public:
	struct FLinearColor                           HealthColor;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DamageColor;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealthBarLooks) == 0x000004, "Wrong alignment on FHealthBarLooks");
static_assert(sizeof(FHealthBarLooks) == 0x000020, "Wrong size on FHealthBarLooks");
static_assert(offsetof(FHealthBarLooks, HealthColor) == 0x000000, "Member 'FHealthBarLooks::HealthColor' has a wrong offset!");
static_assert(offsetof(FHealthBarLooks, DamageColor) == 0x000010, "Member 'FHealthBarLooks::DamageColor' has a wrong offset!");

// ScriptStruct FSD.CharacterVanityLoadout
// 0x0098 (0x0098 - 0x0000)
struct FCharacterVanityLoadout final
{
public:
	struct FGuid                                  EquippedHeadItemID;                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedBeardItemID;                               // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedArmorItemID;                               // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedArmorMaterialID;                           // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedBeardColorItemID;                          // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedSkinColorItemID;                           // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedEyebrowsItemID;                            // 0x0060(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedMoustacheItemID;                           // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EquippedSideburnsItemID;                           // 0x0080(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsingSleevelessArmor;                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F8[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MedicalGownIndex;                                  // 0x0094(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterVanityLoadout) == 0x000004, "Wrong alignment on FCharacterVanityLoadout");
static_assert(sizeof(FCharacterVanityLoadout) == 0x000098, "Wrong size on FCharacterVanityLoadout");
static_assert(offsetof(FCharacterVanityLoadout, EquippedHeadItemID) == 0x000000, "Member 'FCharacterVanityLoadout::EquippedHeadItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedBeardItemID) == 0x000010, "Member 'FCharacterVanityLoadout::EquippedBeardItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedArmorItemID) == 0x000020, "Member 'FCharacterVanityLoadout::EquippedArmorItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedArmorMaterialID) == 0x000030, "Member 'FCharacterVanityLoadout::EquippedArmorMaterialID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedBeardColorItemID) == 0x000040, "Member 'FCharacterVanityLoadout::EquippedBeardColorItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedSkinColorItemID) == 0x000050, "Member 'FCharacterVanityLoadout::EquippedSkinColorItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedEyebrowsItemID) == 0x000060, "Member 'FCharacterVanityLoadout::EquippedEyebrowsItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedMoustacheItemID) == 0x000070, "Member 'FCharacterVanityLoadout::EquippedMoustacheItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, EquippedSideburnsItemID) == 0x000080, "Member 'FCharacterVanityLoadout::EquippedSideburnsItemID' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, UsingSleevelessArmor) == 0x000090, "Member 'FCharacterVanityLoadout::UsingSleevelessArmor' has a wrong offset!");
static_assert(offsetof(FCharacterVanityLoadout, MedicalGownIndex) == 0x000094, "Member 'FCharacterVanityLoadout::MedicalGownIndex' has a wrong offset!");

// ScriptStruct FSD.CharacterVanitySave
// 0x0118 (0x0118 - 0x0000)
struct FCharacterVanitySave final
{
public:
	TArray<struct FCharacterVanityLoadout>        Loadouts;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FCharacterVanityLoadout                RandomVanityLoadout;                               // 0x0010(0x0098)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          UnLockedVanityItemIDs;                             // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UVanityItem*>                    UnLockedVanityItems;                               // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EVanitySlot, struct FGuid>               NewVanityItems;                                    // 0x00C8(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterVanitySave) == 0x000008, "Wrong alignment on FCharacterVanitySave");
static_assert(sizeof(FCharacterVanitySave) == 0x000118, "Wrong size on FCharacterVanitySave");
static_assert(offsetof(FCharacterVanitySave, Loadouts) == 0x000000, "Member 'FCharacterVanitySave::Loadouts' has a wrong offset!");
static_assert(offsetof(FCharacterVanitySave, RandomVanityLoadout) == 0x000010, "Member 'FCharacterVanitySave::RandomVanityLoadout' has a wrong offset!");
static_assert(offsetof(FCharacterVanitySave, UnLockedVanityItemIDs) == 0x0000A8, "Member 'FCharacterVanitySave::UnLockedVanityItemIDs' has a wrong offset!");
static_assert(offsetof(FCharacterVanitySave, UnLockedVanityItems) == 0x0000B8, "Member 'FCharacterVanitySave::UnLockedVanityItems' has a wrong offset!");
static_assert(offsetof(FCharacterVanitySave, NewVanityItems) == 0x0000C8, "Member 'FCharacterVanitySave::NewVanityItems' has a wrong offset!");

// ScriptStruct FSD.VictoryPoseSave
// 0x0030 (0x0030 - 0x0000)
struct FVictoryPoseSave final
{
public:
	struct FGuid                                  EquippedVictoryPose;                               // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          UnlockedVictoryPoses;                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          EquippedVictoryPoses;                              // 0x0020(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FVictoryPoseSave) == 0x000008, "Wrong alignment on FVictoryPoseSave");
static_assert(sizeof(FVictoryPoseSave) == 0x000030, "Wrong size on FVictoryPoseSave");
static_assert(offsetof(FVictoryPoseSave, EquippedVictoryPose) == 0x000000, "Member 'FVictoryPoseSave::EquippedVictoryPose' has a wrong offset!");
static_assert(offsetof(FVictoryPoseSave, UnlockedVictoryPoses) == 0x000010, "Member 'FVictoryPoseSave::UnlockedVictoryPoses' has a wrong offset!");
static_assert(offsetof(FVictoryPoseSave, EquippedVictoryPoses) == 0x000020, "Member 'FVictoryPoseSave::EquippedVictoryPoses' has a wrong offset!");

// ScriptStruct FSD.CharacterSave
// 0x02F8 (0x02F8 - 0x0000)
struct FCharacterSave final
{
public:
	struct FGuid                                  SavegameID;                                        // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasCompletedRetirementCampaign;                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F9[0x3];                                     // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimesRetired;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RetiredCharacterLevels;                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenRetirementRewardScreen;                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16FA[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APlayerCharacter>           CharacterClass;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCharacterVanitySave                   Vanity;                                            // 0x0030(0x0118)(NativeAccessSpecifierPrivate)
	int32                                         SelectedLoadout;                                   // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FItemLoadout                           Loadout;                                           // 0x014C(0x0084)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FItemLoadout>                   Loadouts;                                          // 0x01D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUpgradeLoadout>                ItemUpgradeLoadouts;                               // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FItemLoadout                           RandomWeaponLoadout;                               // 0x01F0(0x0084)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16FB[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUpgradeLoadout                        RandomItemUpgradeLoadouts;                         // 0x0278(0x0050)(NativeAccessSpecifierPrivate)
	struct FVictoryPoseSave                       VictoryPose;                                       // 0x02C8(0x0030)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterSave) == 0x000008, "Wrong alignment on FCharacterSave");
static_assert(sizeof(FCharacterSave) == 0x0002F8, "Wrong size on FCharacterSave");
static_assert(offsetof(FCharacterSave, SavegameID) == 0x000000, "Member 'FCharacterSave::SavegameID' has a wrong offset!");
static_assert(offsetof(FCharacterSave, XP) == 0x000010, "Member 'FCharacterSave::XP' has a wrong offset!");
static_assert(offsetof(FCharacterSave, HasCompletedRetirementCampaign) == 0x000014, "Member 'FCharacterSave::HasCompletedRetirementCampaign' has a wrong offset!");
static_assert(offsetof(FCharacterSave, TimesRetired) == 0x000018, "Member 'FCharacterSave::TimesRetired' has a wrong offset!");
static_assert(offsetof(FCharacterSave, RetiredCharacterLevels) == 0x00001C, "Member 'FCharacterSave::RetiredCharacterLevels' has a wrong offset!");
static_assert(offsetof(FCharacterSave, HasSeenRetirementRewardScreen) == 0x000020, "Member 'FCharacterSave::HasSeenRetirementRewardScreen' has a wrong offset!");
static_assert(offsetof(FCharacterSave, CharacterClass) == 0x000028, "Member 'FCharacterSave::CharacterClass' has a wrong offset!");
static_assert(offsetof(FCharacterSave, Vanity) == 0x000030, "Member 'FCharacterSave::Vanity' has a wrong offset!");
static_assert(offsetof(FCharacterSave, SelectedLoadout) == 0x000148, "Member 'FCharacterSave::SelectedLoadout' has a wrong offset!");
static_assert(offsetof(FCharacterSave, Loadout) == 0x00014C, "Member 'FCharacterSave::Loadout' has a wrong offset!");
static_assert(offsetof(FCharacterSave, Loadouts) == 0x0001D0, "Member 'FCharacterSave::Loadouts' has a wrong offset!");
static_assert(offsetof(FCharacterSave, ItemUpgradeLoadouts) == 0x0001E0, "Member 'FCharacterSave::ItemUpgradeLoadouts' has a wrong offset!");
static_assert(offsetof(FCharacterSave, RandomWeaponLoadout) == 0x0001F0, "Member 'FCharacterSave::RandomWeaponLoadout' has a wrong offset!");
static_assert(offsetof(FCharacterSave, RandomItemUpgradeLoadouts) == 0x000278, "Member 'FCharacterSave::RandomItemUpgradeLoadouts' has a wrong offset!");
static_assert(offsetof(FCharacterSave, VictoryPose) == 0x0002C8, "Member 'FCharacterSave::VictoryPose' has a wrong offset!");

// ScriptStruct FSD.GraplingGunState
// 0x0010 (0x0010 - 0x0000)
struct FGraplingGunState final
{
public:
	struct FVector_NetQuantize                    TargetLocation;                                    // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsGrapling : 1;                                    // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_16FC[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGraplingGunState) == 0x000004, "Wrong alignment on FGraplingGunState");
static_assert(sizeof(FGraplingGunState) == 0x000010, "Wrong size on FGraplingGunState");
static_assert(offsetof(FGraplingGunState, TargetLocation) == 0x000000, "Member 'FGraplingGunState::TargetLocation' has a wrong offset!");

// ScriptStruct FSD.DiscordUserInfoRequest
// 0x0010 (0x0010 - 0x0000)
struct FDiscordUserInfoRequest final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordUserInfoRequest) == 0x000008, "Wrong alignment on FDiscordUserInfoRequest");
static_assert(sizeof(FDiscordUserInfoRequest) == 0x000010, "Wrong size on FDiscordUserInfoRequest");
static_assert(offsetof(FDiscordUserInfoRequest, UserId) == 0x000000, "Member 'FDiscordUserInfoRequest::UserId' has a wrong offset!");

// ScriptStruct FSD.ItemRefundResourceItem
// 0x0018 (0x0018 - 0x0000)
struct FItemRefundResourceItem final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amount;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16FD[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemRefundResourceItem) == 0x000008, "Wrong alignment on FItemRefundResourceItem");
static_assert(sizeof(FItemRefundResourceItem) == 0x000018, "Wrong size on FItemRefundResourceItem");
static_assert(offsetof(FItemRefundResourceItem, Name) == 0x000000, "Member 'FItemRefundResourceItem::Name' has a wrong offset!");
static_assert(offsetof(FItemRefundResourceItem, Amount) == 0x000010, "Member 'FItemRefundResourceItem::Amount' has a wrong offset!");

// ScriptStruct FSD.ItemRefundListItem
// 0x0068 (0x0068 - 0x0000)
struct FItemRefundListItem final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FItemRefundResourceItem> Resources;                                         // 0x0010(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	float                                         CreditCost;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16FE[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemRefundListItem) == 0x000008, "Wrong alignment on FItemRefundListItem");
static_assert(sizeof(FItemRefundListItem) == 0x000068, "Wrong size on FItemRefundListItem");
static_assert(offsetof(FItemRefundListItem, Name) == 0x000000, "Member 'FItemRefundListItem::Name' has a wrong offset!");
static_assert(offsetof(FItemRefundListItem, Resources) == 0x000010, "Member 'FItemRefundListItem::Resources' has a wrong offset!");
static_assert(offsetof(FItemRefundListItem, CreditCost) == 0x000060, "Member 'FItemRefundListItem::CreditCost' has a wrong offset!");

// ScriptStruct FSD.ControlEnemyState
// 0x0060 (0x0060 - 0x0000)
struct FControlEnemyState final
{
public:
	class ADeepPathfinderCharacter*               ControlledEnemy;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16FF[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTargetTransform;                            // 0x0010(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InitialTargetBlendTotalTime;                       // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialCharacterVelocity;                          // 0x0044(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialEnemyVelocity;                              // 0x0050(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1700[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlEnemyState) == 0x000010, "Wrong alignment on FControlEnemyState");
static_assert(sizeof(FControlEnemyState) == 0x000060, "Wrong size on FControlEnemyState");
static_assert(offsetof(FControlEnemyState, ControlledEnemy) == 0x000000, "Member 'FControlEnemyState::ControlledEnemy' has a wrong offset!");
static_assert(offsetof(FControlEnemyState, InitialTargetTransform) == 0x000010, "Member 'FControlEnemyState::InitialTargetTransform' has a wrong offset!");
static_assert(offsetof(FControlEnemyState, InitialTargetBlendTotalTime) == 0x000040, "Member 'FControlEnemyState::InitialTargetBlendTotalTime' has a wrong offset!");
static_assert(offsetof(FControlEnemyState, InitialCharacterVelocity) == 0x000044, "Member 'FControlEnemyState::InitialCharacterVelocity' has a wrong offset!");
static_assert(offsetof(FControlEnemyState, InitialEnemyVelocity) == 0x000050, "Member 'FControlEnemyState::InitialEnemyVelocity' has a wrong offset!");

// ScriptStruct FSD.DiscordFSDRichPresence
// 0x0080 (0x0080 - 0x0000)
struct FDiscordFSDRichPresence final
{
public:
	class FString                                 State;                                             // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Details;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchSecret;                                       // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JoinSecret;                                        // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SmallImageText;                                    // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LargeImageText;                                    // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartTimestamp;                                    // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartySize;                                         // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDiscordBiomeType                             BiomeType;                                         // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDiscordMissionType                           MissionType;                                       // 0x0079(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPureSolo;                                       // 0x007A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1701[0x5];                                     // 0x007B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDiscordFSDRichPresence) == 0x000008, "Wrong alignment on FDiscordFSDRichPresence");
static_assert(sizeof(FDiscordFSDRichPresence) == 0x000080, "Wrong size on FDiscordFSDRichPresence");
static_assert(offsetof(FDiscordFSDRichPresence, State) == 0x000000, "Member 'FDiscordFSDRichPresence::State' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, Details) == 0x000010, "Member 'FDiscordFSDRichPresence::Details' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, MatchSecret) == 0x000020, "Member 'FDiscordFSDRichPresence::MatchSecret' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, JoinSecret) == 0x000030, "Member 'FDiscordFSDRichPresence::JoinSecret' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, PartyId) == 0x000040, "Member 'FDiscordFSDRichPresence::PartyId' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, SmallImageText) == 0x000050, "Member 'FDiscordFSDRichPresence::SmallImageText' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, LargeImageText) == 0x000060, "Member 'FDiscordFSDRichPresence::LargeImageText' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, StartTimestamp) == 0x000070, "Member 'FDiscordFSDRichPresence::StartTimestamp' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, PartySize) == 0x000074, "Member 'FDiscordFSDRichPresence::PartySize' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, BiomeType) == 0x000078, "Member 'FDiscordFSDRichPresence::BiomeType' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, MissionType) == 0x000079, "Member 'FDiscordFSDRichPresence::MissionType' has a wrong offset!");
static_assert(offsetof(FDiscordFSDRichPresence, bIsPureSolo) == 0x00007A, "Member 'FDiscordFSDRichPresence::bIsPureSolo' has a wrong offset!");

// ScriptStruct FSD.GDMissionStats
// 0x0168 (0x0168 - 0x0000)
struct FGDMissionStats final
{
public:
	class UMissionStat*                           TimePlayed;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           DistanceTravelled;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           EnemiesKilled;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           MineralsMined;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           MissionCompleted;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           SoloMissionCompleted;                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           SecondaryMissionCompleted;                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           CharacterLevelUp;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           VanityItemsBought;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           ItemUpgradesBought;                                // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           CosmeticMasteryLevelledUp;                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           DrinkablesConsumed;                                // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           DrinkableRoundsOrdered;                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           BartenderCreditsTipped;                            // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           CampaignMissionsCompleted;                         // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           CampaignsCompleted;                                // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           TimesDowned;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           TimesPassedOut;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           WeaponsUnlockedStat;                               // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           SeasonEventsCompleted;                             // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           SeasonChallengesCompleted;                         // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           DeepDivesCompleted;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           EliteDeepDivesCompleted;                           // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           CosmeticsCrafted;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           WeaponSkinsCrafted;                                // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           WeaponOverclocksCrafted;                           // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           CraftingMasteryLevel;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           DefendBlackBoxObjectivesCompleted;                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           RepairMiniMuleObjectivesCompleted;                 // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           DeepDiveCompletedBestTime;                         // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           EliteDeepDiveCompletedBestTime;                    // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           SpecialBeersUnlocked;                              // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionStat*                           JettyBootCreditsSpent;                             // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMissionStat*>                   AllMissionStats;                                   // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class UPlayerCharacterID*, class UMissionStat*> CharacterMissionsCompleted;                        // 0x0118(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGDMissionStats) == 0x000008, "Wrong alignment on FGDMissionStats");
static_assert(sizeof(FGDMissionStats) == 0x000168, "Wrong size on FGDMissionStats");
static_assert(offsetof(FGDMissionStats, TimePlayed) == 0x000000, "Member 'FGDMissionStats::TimePlayed' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, DistanceTravelled) == 0x000008, "Member 'FGDMissionStats::DistanceTravelled' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, EnemiesKilled) == 0x000010, "Member 'FGDMissionStats::EnemiesKilled' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, MineralsMined) == 0x000018, "Member 'FGDMissionStats::MineralsMined' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, MissionCompleted) == 0x000020, "Member 'FGDMissionStats::MissionCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, SoloMissionCompleted) == 0x000028, "Member 'FGDMissionStats::SoloMissionCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, SecondaryMissionCompleted) == 0x000030, "Member 'FGDMissionStats::SecondaryMissionCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, CharacterLevelUp) == 0x000038, "Member 'FGDMissionStats::CharacterLevelUp' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, VanityItemsBought) == 0x000040, "Member 'FGDMissionStats::VanityItemsBought' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, ItemUpgradesBought) == 0x000048, "Member 'FGDMissionStats::ItemUpgradesBought' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, CosmeticMasteryLevelledUp) == 0x000050, "Member 'FGDMissionStats::CosmeticMasteryLevelledUp' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, DrinkablesConsumed) == 0x000058, "Member 'FGDMissionStats::DrinkablesConsumed' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, DrinkableRoundsOrdered) == 0x000060, "Member 'FGDMissionStats::DrinkableRoundsOrdered' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, BartenderCreditsTipped) == 0x000068, "Member 'FGDMissionStats::BartenderCreditsTipped' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, CampaignMissionsCompleted) == 0x000070, "Member 'FGDMissionStats::CampaignMissionsCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, CampaignsCompleted) == 0x000078, "Member 'FGDMissionStats::CampaignsCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, TimesDowned) == 0x000080, "Member 'FGDMissionStats::TimesDowned' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, TimesPassedOut) == 0x000088, "Member 'FGDMissionStats::TimesPassedOut' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, WeaponsUnlockedStat) == 0x000090, "Member 'FGDMissionStats::WeaponsUnlockedStat' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, SeasonEventsCompleted) == 0x000098, "Member 'FGDMissionStats::SeasonEventsCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, SeasonChallengesCompleted) == 0x0000A0, "Member 'FGDMissionStats::SeasonChallengesCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, DeepDivesCompleted) == 0x0000A8, "Member 'FGDMissionStats::DeepDivesCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, EliteDeepDivesCompleted) == 0x0000B0, "Member 'FGDMissionStats::EliteDeepDivesCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, CosmeticsCrafted) == 0x0000B8, "Member 'FGDMissionStats::CosmeticsCrafted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, WeaponSkinsCrafted) == 0x0000C0, "Member 'FGDMissionStats::WeaponSkinsCrafted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, WeaponOverclocksCrafted) == 0x0000C8, "Member 'FGDMissionStats::WeaponOverclocksCrafted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, CraftingMasteryLevel) == 0x0000D0, "Member 'FGDMissionStats::CraftingMasteryLevel' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, DefendBlackBoxObjectivesCompleted) == 0x0000D8, "Member 'FGDMissionStats::DefendBlackBoxObjectivesCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, RepairMiniMuleObjectivesCompleted) == 0x0000E0, "Member 'FGDMissionStats::RepairMiniMuleObjectivesCompleted' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, DeepDiveCompletedBestTime) == 0x0000E8, "Member 'FGDMissionStats::DeepDiveCompletedBestTime' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, EliteDeepDiveCompletedBestTime) == 0x0000F0, "Member 'FGDMissionStats::EliteDeepDiveCompletedBestTime' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, SpecialBeersUnlocked) == 0x0000F8, "Member 'FGDMissionStats::SpecialBeersUnlocked' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, JettyBootCreditsSpent) == 0x000100, "Member 'FGDMissionStats::JettyBootCreditsSpent' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, AllMissionStats) == 0x000108, "Member 'FGDMissionStats::AllMissionStats' has a wrong offset!");
static_assert(offsetof(FGDMissionStats, CharacterMissionsCompleted) == 0x000118, "Member 'FGDMissionStats::CharacterMissionsCompleted' has a wrong offset!");

// ScriptStruct FSD.FSDSeasonExpiryResponse
// 0x0030 (0x0030 - 0x0000)
struct FFSDSeasonExpiryResponse final
{
public:
	class FString                                 SeasonExpirationTimeSteam;                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SeasonExpirationTimeSony;                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SeasonExpirationTimeGDK;                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDSeasonExpiryResponse) == 0x000008, "Wrong alignment on FFSDSeasonExpiryResponse");
static_assert(sizeof(FFSDSeasonExpiryResponse) == 0x000030, "Wrong size on FFSDSeasonExpiryResponse");
static_assert(offsetof(FFSDSeasonExpiryResponse, SeasonExpirationTimeSteam) == 0x000000, "Member 'FFSDSeasonExpiryResponse::SeasonExpirationTimeSteam' has a wrong offset!");
static_assert(offsetof(FFSDSeasonExpiryResponse, SeasonExpirationTimeSony) == 0x000010, "Member 'FFSDSeasonExpiryResponse::SeasonExpirationTimeSony' has a wrong offset!");
static_assert(offsetof(FFSDSeasonExpiryResponse, SeasonExpirationTimeGDK) == 0x000020, "Member 'FFSDSeasonExpiryResponse::SeasonExpirationTimeGDK' has a wrong offset!");

// ScriptStruct FSD.InputTranslationEntry
// 0x0010 (0x0010 - 0x0000)
struct FInputTranslationEntry final
{
public:
	EInputInteraction                             Interaction;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1702[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InputName;                                         // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Axis;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputTranslationEntry) == 0x000004, "Wrong alignment on FInputTranslationEntry");
static_assert(sizeof(FInputTranslationEntry) == 0x000010, "Wrong size on FInputTranslationEntry");
static_assert(offsetof(FInputTranslationEntry, Interaction) == 0x000000, "Member 'FInputTranslationEntry::Interaction' has a wrong offset!");
static_assert(offsetof(FInputTranslationEntry, InputName) == 0x000004, "Member 'FInputTranslationEntry::InputName' has a wrong offset!");
static_assert(offsetof(FInputTranslationEntry, Axis) == 0x00000C, "Member 'FInputTranslationEntry::Axis' has a wrong offset!");

// ScriptStruct FSD.InputTranslation
// 0x0024 (0x0024 - 0x0000)
struct FInputTranslation final
{
public:
	struct FInputTranslationEntry                 Default;                                           // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bControllerOverride;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1703[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputTranslationEntry                 ControllerOverride;                                // 0x0014(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputTranslation) == 0x000004, "Wrong alignment on FInputTranslation");
static_assert(sizeof(FInputTranslation) == 0x000024, "Wrong size on FInputTranslation");
static_assert(offsetof(FInputTranslation, Default) == 0x000000, "Member 'FInputTranslation::Default' has a wrong offset!");
static_assert(offsetof(FInputTranslation, bControllerOverride) == 0x000010, "Member 'FInputTranslation::bControllerOverride' has a wrong offset!");
static_assert(offsetof(FInputTranslation, ControllerOverride) == 0x000014, "Member 'FInputTranslation::ControllerOverride' has a wrong offset!");

// ScriptStruct FSD.InputTranslationTable
// 0x0050 (0x0050 - 0x0000)
struct FInputTranslationTable final
{
public:
	TMap<class FName, struct FInputTranslation>   Entries;                                           // 0x0000(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInputTranslationTable) == 0x000008, "Wrong alignment on FInputTranslationTable");
static_assert(sizeof(FInputTranslationTable) == 0x000050, "Wrong size on FInputTranslationTable");
static_assert(offsetof(FInputTranslationTable, Entries) == 0x000000, "Member 'FInputTranslationTable::Entries' has a wrong offset!");

// ScriptStruct FSD.WeaponMaintenanceEntry
// 0x001C (0x001C - 0x0000)
struct FWeaponMaintenanceEntry final
{
public:
	struct FGuid                                  WeaponID;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LevelUpNotification;                               // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1704[0x3];                                     // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponMaintenanceEntry) == 0x000004, "Wrong alignment on FWeaponMaintenanceEntry");
static_assert(sizeof(FWeaponMaintenanceEntry) == 0x00001C, "Wrong size on FWeaponMaintenanceEntry");
static_assert(offsetof(FWeaponMaintenanceEntry, WeaponID) == 0x000000, "Member 'FWeaponMaintenanceEntry::WeaponID' has a wrong offset!");
static_assert(offsetof(FWeaponMaintenanceEntry, XP) == 0x000010, "Member 'FWeaponMaintenanceEntry::XP' has a wrong offset!");
static_assert(offsetof(FWeaponMaintenanceEntry, Level) == 0x000014, "Member 'FWeaponMaintenanceEntry::Level' has a wrong offset!");
static_assert(offsetof(FWeaponMaintenanceEntry, LevelUpNotification) == 0x000018, "Member 'FWeaponMaintenanceEntry::LevelUpNotification' has a wrong offset!");

// ScriptStruct FSD.WeaponMaintenance
// 0x0018 (0x0018 - 0x0000)
struct FWeaponMaintenance final
{
public:
	TArray<struct FWeaponMaintenanceEntry>        Entries;                                           // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxLevel;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1705[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponMaintenance) == 0x000008, "Wrong alignment on FWeaponMaintenance");
static_assert(sizeof(FWeaponMaintenance) == 0x000018, "Wrong size on FWeaponMaintenance");
static_assert(offsetof(FWeaponMaintenance, Entries) == 0x000000, "Member 'FWeaponMaintenance::Entries' has a wrong offset!");
static_assert(offsetof(FWeaponMaintenance, MaxLevel) == 0x000010, "Member 'FWeaponMaintenance::MaxLevel' has a wrong offset!");

// ScriptStruct FSD.SchematicAnalyticInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSchematicAnalyticInfo final
{
public:
	uint8                                         Pad_1706[0x20];                                    // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSchematicAnalyticInfo) == 0x000008, "Wrong alignment on FSchematicAnalyticInfo");
static_assert(sizeof(FSchematicAnalyticInfo) == 0x000020, "Wrong size on FSchematicAnalyticInfo");

// ScriptStruct FSD.PerkEquipEntry
// 0x0020 (0x0020 - 0x0000)
struct FPerkEquipEntry final
{
public:
	struct FGuid                                  CharacterID;                                       // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          PerkIDs;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkEquipEntry) == 0x000008, "Wrong alignment on FPerkEquipEntry");
static_assert(sizeof(FPerkEquipEntry) == 0x000020, "Wrong size on FPerkEquipEntry");
static_assert(offsetof(FPerkEquipEntry, CharacterID) == 0x000000, "Member 'FPerkEquipEntry::CharacterID' has a wrong offset!");
static_assert(offsetof(FPerkEquipEntry, PerkIDs) == 0x000010, "Member 'FPerkEquipEntry::PerkIDs' has a wrong offset!");

// ScriptStruct FSD.CharacterPerksSave
// 0x0010 (0x0010 - 0x0000)
struct FCharacterPerksSave final
{
public:
	TArray<struct FPerkEquipEntry>                CharacterPerks;                                    // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCharacterPerksSave) == 0x000008, "Wrong alignment on FCharacterPerksSave");
static_assert(sizeof(FCharacterPerksSave) == 0x000010, "Wrong size on FCharacterPerksSave");
static_assert(offsetof(FCharacterPerksSave, CharacterPerks) == 0x000000, "Member 'FCharacterPerksSave::CharacterPerks' has a wrong offset!");

// ScriptStruct FSD.LoadoutCopy
// 0x0180 (0x0180 - 0x0000)
struct FLoadoutCopy final
{
public:
	struct FItemLoadout                           ItemLoadout;                                       // 0x0000(0x0084)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1707[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUpgradeLoadout                        UpgradeLoadout;                                    // 0x0088(0x0050)(NativeAccessSpecifierPublic)
	struct FCharacterPerksSave                    PerkLoadout;                                       // 0x00D8(0x0010)(NativeAccessSpecifierPublic)
	struct FCharacterVanityLoadout                VanityLoadout;                                     // 0x00E8(0x0098)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadoutCopy) == 0x000008, "Wrong alignment on FLoadoutCopy");
static_assert(sizeof(FLoadoutCopy) == 0x000180, "Wrong size on FLoadoutCopy");
static_assert(offsetof(FLoadoutCopy, ItemLoadout) == 0x000000, "Member 'FLoadoutCopy::ItemLoadout' has a wrong offset!");
static_assert(offsetof(FLoadoutCopy, UpgradeLoadout) == 0x000088, "Member 'FLoadoutCopy::UpgradeLoadout' has a wrong offset!");
static_assert(offsetof(FLoadoutCopy, PerkLoadout) == 0x0000D8, "Member 'FLoadoutCopy::PerkLoadout' has a wrong offset!");
static_assert(offsetof(FLoadoutCopy, VanityLoadout) == 0x0000E8, "Member 'FLoadoutCopy::VanityLoadout' has a wrong offset!");

// ScriptStruct FSD.GameDLCSave
// 0x0050 (0x0050 - 0x0000)
struct FGameDLCSave final
{
public:
	TSet<struct FGuid>                            AnnouncedIDs;                                      // 0x0000(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameDLCSave) == 0x000008, "Wrong alignment on FGameDLCSave");
static_assert(sizeof(FGameDLCSave) == 0x000050, "Wrong size on FGameDLCSave");
static_assert(offsetof(FGameDLCSave, AnnouncedIDs) == 0x000000, "Member 'FGameDLCSave::AnnouncedIDs' has a wrong offset!");

// ScriptStruct FSD.SeasonSave
// 0x0050 (0x0050 - 0x0000)
struct FSeasonSave final
{
public:
	TMap<struct FGuid, struct FSeasonSaveEntry>   Seasons;                                           // 0x0000(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSeasonSave) == 0x000008, "Wrong alignment on FSeasonSave");
static_assert(sizeof(FSeasonSave) == 0x000050, "Wrong size on FSeasonSave");
static_assert(offsetof(FSeasonSave, Seasons) == 0x000000, "Member 'FSeasonSave::Seasons' has a wrong offset!");

// ScriptStruct FSD.RandFloatInterval
// 0x0010 (0x0010 - 0x0000)
struct FRandFloatInterval final
{
public:
	TArray<struct FRandFloatIntervalItem>         Intervals;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandFloatInterval) == 0x000008, "Wrong alignment on FRandFloatInterval");
static_assert(sizeof(FRandFloatInterval) == 0x000010, "Wrong size on FRandFloatInterval");
static_assert(offsetof(FRandFloatInterval, Intervals) == 0x000000, "Member 'FRandFloatInterval::Intervals' has a wrong offset!");

// ScriptStruct FSD.FSDEventRewardsSave
// 0x00A0 (0x00A0 - 0x0000)
struct FFSDEventRewardsSave final
{
public:
	TSet<struct FGuid>                            EventsSeen;                                        // 0x0000(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<struct FGuid>                            PopupsSeen;                                        // 0x0050(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FFSDEventRewardsSave) == 0x000008, "Wrong alignment on FFSDEventRewardsSave");
static_assert(sizeof(FFSDEventRewardsSave) == 0x0000A0, "Wrong size on FFSDEventRewardsSave");
static_assert(offsetof(FFSDEventRewardsSave, EventsSeen) == 0x000000, "Member 'FFSDEventRewardsSave::EventsSeen' has a wrong offset!");
static_assert(offsetof(FFSDEventRewardsSave, PopupsSeen) == 0x000050, "Member 'FFSDEventRewardsSave::PopupsSeen' has a wrong offset!");

// ScriptStruct FSD.PromotionRewardsSave
// 0x0058 (0x0058 - 0x0000)
struct FPromotionRewardsSave final
{
public:
	int32                                         PendingPromotionGifts;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1708[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGuid>                            ClaimedRewards;                                    // 0x0008(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPromotionRewardsSave) == 0x000008, "Wrong alignment on FPromotionRewardsSave");
static_assert(sizeof(FPromotionRewardsSave) == 0x000058, "Wrong size on FPromotionRewardsSave");
static_assert(offsetof(FPromotionRewardsSave, PendingPromotionGifts) == 0x000000, "Member 'FPromotionRewardsSave::PendingPromotionGifts' has a wrong offset!");
static_assert(offsetof(FPromotionRewardsSave, ClaimedRewards) == 0x000008, "Member 'FPromotionRewardsSave::ClaimedRewards' has a wrong offset!");

// ScriptStruct FSD.RecoilImpulse
// 0x000C (0x000C - 0x0000)
struct FRecoilImpulse final
{
public:
	float                                         Rotation;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Impulse;                                           // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecoilImpulse) == 0x000004, "Wrong alignment on FRecoilImpulse");
static_assert(sizeof(FRecoilImpulse) == 0x00000C, "Wrong size on FRecoilImpulse");
static_assert(offsetof(FRecoilImpulse, Rotation) == 0x000000, "Member 'FRecoilImpulse::Rotation' has a wrong offset!");
static_assert(offsetof(FRecoilImpulse, Impulse) == 0x000004, "Member 'FRecoilImpulse::Impulse' has a wrong offset!");

// ScriptStruct FSD.SchematicSave
// 0x0040 (0x0040 - 0x0000)
struct FSchematicSave final
{
public:
	struct FGuid                                  PendingReward;                                     // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstSchematicMessageShown;                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1709[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          ForgedSchematics;                                  // 0x0018(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          OwnedSchematics;                                   // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         SkinFixupCounter;                                  // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170A[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSchematicSave) == 0x000008, "Wrong alignment on FSchematicSave");
static_assert(sizeof(FSchematicSave) == 0x000040, "Wrong size on FSchematicSave");
static_assert(offsetof(FSchematicSave, PendingReward) == 0x000000, "Member 'FSchematicSave::PendingReward' has a wrong offset!");
static_assert(offsetof(FSchematicSave, bFirstSchematicMessageShown) == 0x000010, "Member 'FSchematicSave::bFirstSchematicMessageShown' has a wrong offset!");
static_assert(offsetof(FSchematicSave, ForgedSchematics) == 0x000018, "Member 'FSchematicSave::ForgedSchematics' has a wrong offset!");
static_assert(offsetof(FSchematicSave, OwnedSchematics) == 0x000028, "Member 'FSchematicSave::OwnedSchematics' has a wrong offset!");
static_assert(offsetof(FSchematicSave, SkinFixupCounter) == 0x000038, "Member 'FSchematicSave::SkinFixupCounter' has a wrong offset!");

// ScriptStruct FSD.WidgetAnimationSettings
// 0x0008 (0x0008 - 0x0000)
struct FWidgetAnimationSettings final
{
public:
	float                                         PlaybackSpeed;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUMGSequencePlayMode                          PlayMode;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestoreState;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170B[0x2];                                     // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetAnimationSettings) == 0x000004, "Wrong alignment on FWidgetAnimationSettings");
static_assert(sizeof(FWidgetAnimationSettings) == 0x000008, "Wrong size on FWidgetAnimationSettings");
static_assert(offsetof(FWidgetAnimationSettings, PlaybackSpeed) == 0x000000, "Member 'FWidgetAnimationSettings::PlaybackSpeed' has a wrong offset!");
static_assert(offsetof(FWidgetAnimationSettings, PlayMode) == 0x000004, "Member 'FWidgetAnimationSettings::PlayMode' has a wrong offset!");
static_assert(offsetof(FWidgetAnimationSettings, bRestoreState) == 0x000005, "Member 'FWidgetAnimationSettings::bRestoreState' has a wrong offset!");

// ScriptStruct FSD.JettyBootsScore
// 0x0018 (0x0018 - 0x0000)
struct FJettyBootsScore final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170C[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJettyBootsScore) == 0x000008, "Wrong alignment on FJettyBootsScore");
static_assert(sizeof(FJettyBootsScore) == 0x000018, "Wrong size on FJettyBootsScore");
static_assert(offsetof(FJettyBootsScore, PlayerName) == 0x000000, "Member 'FJettyBootsScore::PlayerName' has a wrong offset!");
static_assert(offsetof(FJettyBootsScore, Score) == 0x000010, "Member 'FJettyBootsScore::Score' has a wrong offset!");

// ScriptStruct FSD.JettyBootsSave
// 0x0028 (0x0028 - 0x0000)
struct FJettyBootsSave final
{
public:
	TArray<struct FJettyBootsScore>               HighScores;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJettyBootsScore>               NPC_HighScores;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInitializeNPCs;                                   // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170D[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastHighScoreIndex;                                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJettyBootsSave) == 0x000008, "Wrong alignment on FJettyBootsSave");
static_assert(sizeof(FJettyBootsSave) == 0x000028, "Wrong size on FJettyBootsSave");
static_assert(offsetof(FJettyBootsSave, HighScores) == 0x000000, "Member 'FJettyBootsSave::HighScores' has a wrong offset!");
static_assert(offsetof(FJettyBootsSave, NPC_HighScores) == 0x000010, "Member 'FJettyBootsSave::NPC_HighScores' has a wrong offset!");
static_assert(offsetof(FJettyBootsSave, bInitializeNPCs) == 0x000020, "Member 'FJettyBootsSave::bInitializeNPCs' has a wrong offset!");
static_assert(offsetof(FJettyBootsSave, LastHighScoreIndex) == 0x000024, "Member 'FJettyBootsSave::LastHighScoreIndex' has a wrong offset!");

// ScriptStruct FSD.SpaceRigNotification
// 0x0040 (0x0040 - 0x0000)
struct FSpaceRigNotification final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColor;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170E[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpaceRigNotification) == 0x000008, "Wrong alignment on FSpaceRigNotification");
static_assert(sizeof(FSpaceRigNotification) == 0x000040, "Wrong size on FSpaceRigNotification");
static_assert(offsetof(FSpaceRigNotification, Text) == 0x000000, "Member 'FSpaceRigNotification::Text' has a wrong offset!");
static_assert(offsetof(FSpaceRigNotification, Icon) == 0x000018, "Member 'FSpaceRigNotification::Icon' has a wrong offset!");
static_assert(offsetof(FSpaceRigNotification, IconColor) == 0x000020, "Member 'FSpaceRigNotification::IconColor' has a wrong offset!");

// ScriptStruct FSD.MiningPodDialogs
// 0x0050 (0x0050 - 0x0000)
struct FMiningPodDialogs final
{
public:
	class UDialogDataAsset*                       DepartingIn5Min;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepartingIn4Min;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepartingIn3Min;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepartingIn2Min;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepartingIn1Min;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepartingIn30Sec;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepartingIn10Sec;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepartingIn123Sec;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Departed;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DeepDiveDeparted;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiningPodDialogs) == 0x000008, "Wrong alignment on FMiningPodDialogs");
static_assert(sizeof(FMiningPodDialogs) == 0x000050, "Wrong size on FMiningPodDialogs");
static_assert(offsetof(FMiningPodDialogs, DepartingIn5Min) == 0x000000, "Member 'FMiningPodDialogs::DepartingIn5Min' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DepartingIn4Min) == 0x000008, "Member 'FMiningPodDialogs::DepartingIn4Min' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DepartingIn3Min) == 0x000010, "Member 'FMiningPodDialogs::DepartingIn3Min' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DepartingIn2Min) == 0x000018, "Member 'FMiningPodDialogs::DepartingIn2Min' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DepartingIn1Min) == 0x000020, "Member 'FMiningPodDialogs::DepartingIn1Min' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DepartingIn30Sec) == 0x000028, "Member 'FMiningPodDialogs::DepartingIn30Sec' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DepartingIn10Sec) == 0x000030, "Member 'FMiningPodDialogs::DepartingIn10Sec' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DepartingIn123Sec) == 0x000038, "Member 'FMiningPodDialogs::DepartingIn123Sec' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, Departed) == 0x000040, "Member 'FMiningPodDialogs::Departed' has a wrong offset!");
static_assert(offsetof(FMiningPodDialogs, DeepDiveDeparted) == 0x000048, "Member 'FMiningPodDialogs::DeepDiveDeparted' has a wrong offset!");

// ScriptStruct FSD.RoomGeneratorItem
// 0x0018 (0x0018 - 0x0000)
struct FRoomGeneratorItem final
{
public:
	class URoomGeneratorBase*                     RoomGenerator;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomGeneratorItem) == 0x000008, "Wrong alignment on FRoomGeneratorItem");
static_assert(sizeof(FRoomGeneratorItem) == 0x000018, "Wrong size on FRoomGeneratorItem");
static_assert(offsetof(FRoomGeneratorItem, RoomGenerator) == 0x000000, "Member 'FRoomGeneratorItem::RoomGenerator' has a wrong offset!");
static_assert(offsetof(FRoomGeneratorItem, Position) == 0x000008, "Member 'FRoomGeneratorItem::Position' has a wrong offset!");
static_assert(offsetof(FRoomGeneratorItem, Rotation) == 0x000014, "Member 'FRoomGeneratorItem::Rotation' has a wrong offset!");

// ScriptStruct FSD.ResourceInitalizer
// 0x0010 (0x0010 - 0x0000)
struct FResourceInitalizer final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAmount;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170F[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResourceInitalizer) == 0x000008, "Wrong alignment on FResourceInitalizer");
static_assert(sizeof(FResourceInitalizer) == 0x000010, "Wrong size on FResourceInitalizer");
static_assert(offsetof(FResourceInitalizer, Resource) == 0x000000, "Member 'FResourceInitalizer::Resource' has a wrong offset!");
static_assert(offsetof(FResourceInitalizer, MaxAmount) == 0x000008, "Member 'FResourceInitalizer::MaxAmount' has a wrong offset!");

// ScriptStruct FSD.PickaxeDigOperationData
// 0x0028 (0x0028 - 0x0000)
struct FPickaxeDigOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitPos;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Dir;                                               // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DigSize;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Miner;                                             // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickaxeDigOperationData) == 0x000008, "Wrong alignment on FPickaxeDigOperationData");
static_assert(sizeof(FPickaxeDigOperationData) == 0x000028, "Wrong size on FPickaxeDigOperationData");
static_assert(offsetof(FPickaxeDigOperationData, OperationNumber) == 0x000000, "Member 'FPickaxeDigOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FPickaxeDigOperationData, HitPos) == 0x000004, "Member 'FPickaxeDigOperationData::HitPos' has a wrong offset!");
static_assert(offsetof(FPickaxeDigOperationData, Dir) == 0x000010, "Member 'FPickaxeDigOperationData::Dir' has a wrong offset!");
static_assert(offsetof(FPickaxeDigOperationData, DigSize) == 0x00001C, "Member 'FPickaxeDigOperationData::DigSize' has a wrong offset!");
static_assert(offsetof(FPickaxeDigOperationData, Miner) == 0x000020, "Member 'FPickaxeDigOperationData::Miner' has a wrong offset!");

// ScriptStruct FSD.AchievementSaveEntry
// 0x0018 (0x0018 - 0x0000)
struct FAchievementSaveEntry final
{
public:
	struct FGuid                                  AchievementSaveID;                                 // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighestSavedProgress;                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentProgress;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementSaveEntry) == 0x000004, "Wrong alignment on FAchievementSaveEntry");
static_assert(sizeof(FAchievementSaveEntry) == 0x000018, "Wrong size on FAchievementSaveEntry");
static_assert(offsetof(FAchievementSaveEntry, AchievementSaveID) == 0x000000, "Member 'FAchievementSaveEntry::AchievementSaveID' has a wrong offset!");
static_assert(offsetof(FAchievementSaveEntry, HighestSavedProgress) == 0x000010, "Member 'FAchievementSaveEntry::HighestSavedProgress' has a wrong offset!");
static_assert(offsetof(FAchievementSaveEntry, CurrentProgress) == 0x000014, "Member 'FAchievementSaveEntry::CurrentProgress' has a wrong offset!");

// ScriptStruct FSD.AchievementSave
// 0x0020 (0x0020 - 0x0000)
struct FAchievementSave final
{
public:
	TArray<class FString>                         OfflineAchievedAchievements;                       // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAchievementSaveEntry>          AchievementEntries;                                // 0x0010(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAchievementSave) == 0x000008, "Wrong alignment on FAchievementSave");
static_assert(sizeof(FAchievementSave) == 0x000020, "Wrong size on FAchievementSave");
static_assert(offsetof(FAchievementSave, OfflineAchievedAchievements) == 0x000000, "Member 'FAchievementSave::OfflineAchievedAchievements' has a wrong offset!");
static_assert(offsetof(FAchievementSave, AchievementEntries) == 0x000010, "Member 'FAchievementSave::AchievementEntries' has a wrong offset!");

// ScriptStruct FSD.ItemLoadoutAnimations
// 0x0018 (0x0018 - 0x0000)
struct FItemLoadoutAnimations final
{
public:
	class UAnimMontage*                           Loadout;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  Loadout_IdleBreaks;                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemLoadoutAnimations) == 0x000008, "Wrong alignment on FItemLoadoutAnimations");
static_assert(sizeof(FItemLoadoutAnimations) == 0x000018, "Wrong size on FItemLoadoutAnimations");
static_assert(offsetof(FItemLoadoutAnimations, Loadout) == 0x000000, "Member 'FItemLoadoutAnimations::Loadout' has a wrong offset!");
static_assert(offsetof(FItemLoadoutAnimations, Loadout_IdleBreaks) == 0x000008, "Member 'FItemLoadoutAnimations::Loadout_IdleBreaks' has a wrong offset!");

// ScriptStruct FSD.PerkClaimEntry
// 0x0014 (0x0014 - 0x0000)
struct FPerkClaimEntry final
{
public:
	struct FGuid                                  PerkID;                                            // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentRank;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkClaimEntry) == 0x000004, "Wrong alignment on FPerkClaimEntry");
static_assert(sizeof(FPerkClaimEntry) == 0x000014, "Wrong size on FPerkClaimEntry");
static_assert(offsetof(FPerkClaimEntry, PerkID) == 0x000000, "Member 'FPerkClaimEntry::PerkID' has a wrong offset!");
static_assert(offsetof(FPerkClaimEntry, CurrentRank) == 0x000010, "Member 'FPerkClaimEntry::CurrentRank' has a wrong offset!");

// ScriptStruct FSD.PerkClaimsSave
// 0x0018 (0x0018 - 0x0000)
struct FPerkClaimsSave final
{
public:
	TArray<struct FPerkClaimEntry>                PerkEntries;                                       // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          HasResetPerks2;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1710[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkClaimsSave) == 0x000008, "Wrong alignment on FPerkClaimsSave");
static_assert(sizeof(FPerkClaimsSave) == 0x000018, "Wrong size on FPerkClaimsSave");
static_assert(offsetof(FPerkClaimsSave, PerkEntries) == 0x000000, "Member 'FPerkClaimsSave::PerkEntries' has a wrong offset!");
static_assert(offsetof(FPerkClaimsSave, HasResetPerks2) == 0x000010, "Member 'FPerkClaimsSave::HasResetPerks2' has a wrong offset!");

// ScriptStruct FSD.ClaimableRewardEntry
// 0x0090 (0x0090 - 0x0000)
struct FClaimableRewardEntry final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Image;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UReward*>                        Rewards;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EntryWidgetOverride;                               // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClaimableRewardEntry) == 0x000008, "Wrong alignment on FClaimableRewardEntry");
static_assert(sizeof(FClaimableRewardEntry) == 0x000090, "Wrong size on FClaimableRewardEntry");
static_assert(offsetof(FClaimableRewardEntry, Title) == 0x000000, "Member 'FClaimableRewardEntry::Title' has a wrong offset!");
static_assert(offsetof(FClaimableRewardEntry, Text) == 0x000018, "Member 'FClaimableRewardEntry::Text' has a wrong offset!");
static_assert(offsetof(FClaimableRewardEntry, Image) == 0x000030, "Member 'FClaimableRewardEntry::Image' has a wrong offset!");
static_assert(offsetof(FClaimableRewardEntry, Rewards) == 0x000058, "Member 'FClaimableRewardEntry::Rewards' has a wrong offset!");
static_assert(offsetof(FClaimableRewardEntry, EntryWidgetOverride) == 0x000068, "Member 'FClaimableRewardEntry::EntryWidgetOverride' has a wrong offset!");

// ScriptStruct FSD.ClaimableRewardView
// 0x0088 (0x0088 - 0x0000)
struct FClaimableRewardView final
{
public:
	class UDialogDataAsset*                       MissionControlSpeak;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BackgroundWidgetClass;                             // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundCue>               FanfareAudio;                                      // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveInRewardsDelay;                                // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1711[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FClaimableRewardEntry>          RewardDisplays;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FText                                   ClaimButtonText;                                   // 0x0070(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClaimableRewardView) == 0x000008, "Wrong alignment on FClaimableRewardView");
static_assert(sizeof(FClaimableRewardView) == 0x000088, "Wrong size on FClaimableRewardView");
static_assert(offsetof(FClaimableRewardView, MissionControlSpeak) == 0x000000, "Member 'FClaimableRewardView::MissionControlSpeak' has a wrong offset!");
static_assert(offsetof(FClaimableRewardView, BackgroundWidgetClass) == 0x000008, "Member 'FClaimableRewardView::BackgroundWidgetClass' has a wrong offset!");
static_assert(offsetof(FClaimableRewardView, FanfareAudio) == 0x000030, "Member 'FClaimableRewardView::FanfareAudio' has a wrong offset!");
static_assert(offsetof(FClaimableRewardView, MoveInRewardsDelay) == 0x000058, "Member 'FClaimableRewardView::MoveInRewardsDelay' has a wrong offset!");
static_assert(offsetof(FClaimableRewardView, RewardDisplays) == 0x000060, "Member 'FClaimableRewardView::RewardDisplays' has a wrong offset!");
static_assert(offsetof(FClaimableRewardView, ClaimButtonText) == 0x000070, "Member 'FClaimableRewardView::ClaimButtonText' has a wrong offset!");

// ScriptStruct FSD.ScaledEffect
// 0x0010 (0x0010 - 0x0000)
struct FScaledEffect final
{
public:
	class UFXSystemAsset*                         ParticleSystem;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1712[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScaledEffect) == 0x000008, "Wrong alignment on FScaledEffect");
static_assert(sizeof(FScaledEffect) == 0x000010, "Wrong size on FScaledEffect");
static_assert(offsetof(FScaledEffect, ParticleSystem) == 0x000000, "Member 'FScaledEffect::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FScaledEffect, Scale) == 0x000008, "Member 'FScaledEffect::Scale' has a wrong offset!");

// ScriptStruct FSD.EquippedActorData
// 0x0010 (0x0010 - 0x0000)
struct FEquippedActorData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsExternalActor : 1;                               // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1713[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquippedActorData) == 0x000008, "Wrong alignment on FEquippedActorData");
static_assert(sizeof(FEquippedActorData) == 0x000010, "Wrong size on FEquippedActorData");
static_assert(offsetof(FEquippedActorData, Actor) == 0x000000, "Member 'FEquippedActorData::Actor' has a wrong offset!");

// ScriptStruct FSD.ProfileCategoryTiming
// 0x0018 (0x0018 - 0x0000)
struct FProfileCategoryTiming final
{
public:
	class FString                                 CategoryName;                                      // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CategoryTime;                                      // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1714[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProfileCategoryTiming) == 0x000008, "Wrong alignment on FProfileCategoryTiming");
static_assert(sizeof(FProfileCategoryTiming) == 0x000018, "Wrong size on FProfileCategoryTiming");
static_assert(offsetof(FProfileCategoryTiming, CategoryName) == 0x000000, "Member 'FProfileCategoryTiming::CategoryName' has a wrong offset!");
static_assert(offsetof(FProfileCategoryTiming, CategoryTime) == 0x000010, "Member 'FProfileCategoryTiming::CategoryTime' has a wrong offset!");

// ScriptStruct FSD.MilestoneCounter
// 0x0014 (0x0014 - 0x0000)
struct FMilestoneCounter final
{
public:
	struct FGuid                                  KPIGuid;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Tier;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMilestoneCounter) == 0x000004, "Wrong alignment on FMilestoneCounter");
static_assert(sizeof(FMilestoneCounter) == 0x000014, "Wrong size on FMilestoneCounter");
static_assert(offsetof(FMilestoneCounter, KPIGuid) == 0x000000, "Member 'FMilestoneCounter::KPIGuid' has a wrong offset!");
static_assert(offsetof(FMilestoneCounter, Tier) == 0x000010, "Member 'FMilestoneCounter::Tier' has a wrong offset!");

// ScriptStruct FSD.MilestoneSave
// 0x0010 (0x0010 - 0x0000)
struct FMilestoneSave final
{
public:
	TArray<struct FMilestoneCounter>              ClaimedKPIRewards;                                 // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMilestoneSave) == 0x000008, "Wrong alignment on FMilestoneSave");
static_assert(sizeof(FMilestoneSave) == 0x000010, "Wrong size on FMilestoneSave");
static_assert(offsetof(FMilestoneSave, ClaimedKPIRewards) == 0x000000, "Member 'FMilestoneSave::ClaimedKPIRewards' has a wrong offset!");

// ScriptStruct FSD.DamageModifierItem
// 0x000C (0x000C - 0x0000)
struct FDamageModifierItem final
{
public:
	EDamageUpgrade                                DamageUpgrade;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1715[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Additive;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplicative;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageModifierItem) == 0x000004, "Wrong alignment on FDamageModifierItem");
static_assert(sizeof(FDamageModifierItem) == 0x00000C, "Wrong size on FDamageModifierItem");
static_assert(offsetof(FDamageModifierItem, DamageUpgrade) == 0x000000, "Member 'FDamageModifierItem::DamageUpgrade' has a wrong offset!");
static_assert(offsetof(FDamageModifierItem, Additive) == 0x000004, "Member 'FDamageModifierItem::Additive' has a wrong offset!");
static_assert(offsetof(FDamageModifierItem, Multiplicative) == 0x000008, "Member 'FDamageModifierItem::Multiplicative' has a wrong offset!");

// ScriptStruct FSD.MissionStatCounter
// 0x0024 (0x0024 - 0x0000)
struct FMissionStatCounter final
{
public:
	struct FGuid                                  PlayerClassID;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MissionStatID;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionStatCounter) == 0x000004, "Wrong alignment on FMissionStatCounter");
static_assert(sizeof(FMissionStatCounter) == 0x000024, "Wrong size on FMissionStatCounter");
static_assert(offsetof(FMissionStatCounter, PlayerClassID) == 0x000000, "Member 'FMissionStatCounter::PlayerClassID' has a wrong offset!");
static_assert(offsetof(FMissionStatCounter, MissionStatID) == 0x000010, "Member 'FMissionStatCounter::MissionStatID' has a wrong offset!");
static_assert(offsetof(FMissionStatCounter, Value) == 0x000020, "Member 'FMissionStatCounter::Value' has a wrong offset!");

// ScriptStruct FSD.MissionStatSave
// 0x0018 (0x0018 - 0x0000)
struct FMissionStatSave final
{
public:
	TArray<struct FMissionStatCounter>            Counters;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCharacterLevelUpFixed;                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBoughtVanityItemsFixed;                           // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBoughtEquipmentUpgradesFixed;                     // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCampaignsCompletedFixed;                          // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WeaponUpgradesFixed;                               // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1716[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionStatSave) == 0x000008, "Wrong alignment on FMissionStatSave");
static_assert(sizeof(FMissionStatSave) == 0x000018, "Wrong size on FMissionStatSave");
static_assert(offsetof(FMissionStatSave, Counters) == 0x000000, "Member 'FMissionStatSave::Counters' has a wrong offset!");
static_assert(offsetof(FMissionStatSave, bCharacterLevelUpFixed) == 0x000010, "Member 'FMissionStatSave::bCharacterLevelUpFixed' has a wrong offset!");
static_assert(offsetof(FMissionStatSave, bBoughtVanityItemsFixed) == 0x000011, "Member 'FMissionStatSave::bBoughtVanityItemsFixed' has a wrong offset!");
static_assert(offsetof(FMissionStatSave, bBoughtEquipmentUpgradesFixed) == 0x000012, "Member 'FMissionStatSave::bBoughtEquipmentUpgradesFixed' has a wrong offset!");
static_assert(offsetof(FMissionStatSave, bCampaignsCompletedFixed) == 0x000013, "Member 'FMissionStatSave::bCampaignsCompletedFixed' has a wrong offset!");
static_assert(offsetof(FMissionStatSave, WeaponUpgradesFixed) == 0x000014, "Member 'FMissionStatSave::WeaponUpgradesFixed' has a wrong offset!");

// ScriptStruct FSD.LookupSessionRequest
// 0x0010 (0x0010 - 0x0000)
struct FLookupSessionRequest final
{
public:
	class FString                                 SessionKey;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookupSessionRequest) == 0x000008, "Wrong alignment on FLookupSessionRequest");
static_assert(sizeof(FLookupSessionRequest) == 0x000010, "Wrong size on FLookupSessionRequest");
static_assert(offsetof(FLookupSessionRequest, SessionKey) == 0x000000, "Member 'FLookupSessionRequest::SessionKey' has a wrong offset!");

// ScriptStruct FSD.PlayerProgress
// 0x0008 (0x0008 - 0x0000)
struct FPlayerProgress final
{
public:
	int32                                         PlayerRank;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerStars;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlayerProgress) == 0x000004, "Wrong alignment on FPlayerProgress");
static_assert(sizeof(FPlayerProgress) == 0x000008, "Wrong size on FPlayerProgress");
static_assert(offsetof(FPlayerProgress, PlayerRank) == 0x000000, "Member 'FPlayerProgress::PlayerRank' has a wrong offset!");
static_assert(offsetof(FPlayerProgress, PlayerStars) == 0x000004, "Member 'FPlayerProgress::PlayerStars' has a wrong offset!");

// ScriptStruct FSD.CharacterProgress
// 0x0020 (0x0020 - 0x0000)
struct FCharacterProgress final
{
public:
	class UPlayerCharacterID*                     CharacterID;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentXP;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLevelXP;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesRetired;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1717[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterProgress) == 0x000008, "Wrong alignment on FCharacterProgress");
static_assert(sizeof(FCharacterProgress) == 0x000020, "Wrong size on FCharacterProgress");
static_assert(offsetof(FCharacterProgress, CharacterID) == 0x000000, "Member 'FCharacterProgress::CharacterID' has a wrong offset!");
static_assert(offsetof(FCharacterProgress, Level) == 0x000008, "Member 'FCharacterProgress::Level' has a wrong offset!");
static_assert(offsetof(FCharacterProgress, Progress) == 0x00000C, "Member 'FCharacterProgress::Progress' has a wrong offset!");
static_assert(offsetof(FCharacterProgress, CurrentXP) == 0x000010, "Member 'FCharacterProgress::CurrentXP' has a wrong offset!");
static_assert(offsetof(FCharacterProgress, NextLevelXP) == 0x000014, "Member 'FCharacterProgress::NextLevelXP' has a wrong offset!");
static_assert(offsetof(FCharacterProgress, TimesRetired) == 0x000018, "Member 'FCharacterProgress::TimesRetired' has a wrong offset!");

// ScriptStruct FSD.EndMissionResult
// 0x0060 (0x0060 - 0x0000)
struct FEndMissionResult final
{
public:
	struct FPlayerProgress                        PreviousPlayerProgress;                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerProgress                        PlayerProgress;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterProgress                     PreviousCharacterProgress;                         // 0x0010(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterProgress                     CharacterProgress;                                 // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class USchematic*                             RewardedSchematic;                                 // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadyForUse;                                      // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1718[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndMissionResult) == 0x000008, "Wrong alignment on FEndMissionResult");
static_assert(sizeof(FEndMissionResult) == 0x000060, "Wrong size on FEndMissionResult");
static_assert(offsetof(FEndMissionResult, PreviousPlayerProgress) == 0x000000, "Member 'FEndMissionResult::PreviousPlayerProgress' has a wrong offset!");
static_assert(offsetof(FEndMissionResult, PlayerProgress) == 0x000008, "Member 'FEndMissionResult::PlayerProgress' has a wrong offset!");
static_assert(offsetof(FEndMissionResult, PreviousCharacterProgress) == 0x000010, "Member 'FEndMissionResult::PreviousCharacterProgress' has a wrong offset!");
static_assert(offsetof(FEndMissionResult, CharacterProgress) == 0x000030, "Member 'FEndMissionResult::CharacterProgress' has a wrong offset!");
static_assert(offsetof(FEndMissionResult, RewardedSchematic) == 0x000050, "Member 'FEndMissionResult::RewardedSchematic' has a wrong offset!");
static_assert(offsetof(FEndMissionResult, bReadyForUse) == 0x000058, "Member 'FEndMissionResult::bReadyForUse' has a wrong offset!");

// ScriptStruct FSD.ActiveCampaingMission
// 0x000C (0x000C - 0x0000)
struct FActiveCampaingMission final
{
public:
	bool                                          HasMission;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1719[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GlobalSeed;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionSeed;                                       // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveCampaingMission) == 0x000004, "Wrong alignment on FActiveCampaingMission");
static_assert(sizeof(FActiveCampaingMission) == 0x00000C, "Wrong size on FActiveCampaingMission");
static_assert(offsetof(FActiveCampaingMission, HasMission) == 0x000000, "Member 'FActiveCampaingMission::HasMission' has a wrong offset!");
static_assert(offsetof(FActiveCampaingMission, GlobalSeed) == 0x000004, "Member 'FActiveCampaingMission::GlobalSeed' has a wrong offset!");
static_assert(offsetof(FActiveCampaingMission, MissionSeed) == 0x000008, "Member 'FActiveCampaingMission::MissionSeed' has a wrong offset!");

// ScriptStruct FSD.ProximityTriggerItem
// 0x0028 (0x0028 - 0x0000)
struct FProximityTriggerItem final
{
public:
	uint8                                         Pad_171A[0x18];                                    // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class APlayerCharacter* Player, bool EnteredTrigger)> Callback;                                          // 0x0018(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProximityTriggerItem) == 0x000004, "Wrong alignment on FProximityTriggerItem");
static_assert(sizeof(FProximityTriggerItem) == 0x000028, "Wrong size on FProximityTriggerItem");
static_assert(offsetof(FProximityTriggerItem, Callback) == 0x000018, "Member 'FProximityTriggerItem::Callback' has a wrong offset!");

// ScriptStruct FSD.SaveGameStatePerkItem
// 0x0010 (0x0010 - 0x0000)
struct FSaveGameStatePerkItem final
{
public:
	uint8                                         Rank;                                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171B[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPerkAsset*                             Perk;                                              // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveGameStatePerkItem) == 0x000008, "Wrong alignment on FSaveGameStatePerkItem");
static_assert(sizeof(FSaveGameStatePerkItem) == 0x000010, "Wrong size on FSaveGameStatePerkItem");
static_assert(offsetof(FSaveGameStatePerkItem, Rank) == 0x000000, "Member 'FSaveGameStatePerkItem::Rank' has a wrong offset!");
static_assert(offsetof(FSaveGameStatePerkItem, Perk) == 0x000008, "Member 'FSaveGameStatePerkItem::Perk' has a wrong offset!");

// ScriptStruct FSD.BackendNotificationEvent
// 0x0040 (0x0040 - 0x0000)
struct FBackendNotificationEvent final
{
public:
	class FString                                 MessageType;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Header;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Link;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBackendNotificationEvent) == 0x000008, "Wrong alignment on FBackendNotificationEvent");
static_assert(sizeof(FBackendNotificationEvent) == 0x000040, "Wrong size on FBackendNotificationEvent");
static_assert(offsetof(FBackendNotificationEvent, MessageType) == 0x000000, "Member 'FBackendNotificationEvent::MessageType' has a wrong offset!");
static_assert(offsetof(FBackendNotificationEvent, Header) == 0x000010, "Member 'FBackendNotificationEvent::Header' has a wrong offset!");
static_assert(offsetof(FBackendNotificationEvent, Message) == 0x000020, "Member 'FBackendNotificationEvent::Message' has a wrong offset!");
static_assert(offsetof(FBackendNotificationEvent, Link) == 0x000030, "Member 'FBackendNotificationEvent::Link' has a wrong offset!");

// ScriptStruct FSD.IRandRange
// 0x0008 (0x0008 - 0x0000)
struct FIRandRange final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIRandRange) == 0x000004, "Wrong alignment on FIRandRange");
static_assert(sizeof(FIRandRange) == 0x000008, "Wrong size on FIRandRange");
static_assert(offsetof(FIRandRange, Min) == 0x000000, "Member 'FIRandRange::Min' has a wrong offset!");
static_assert(offsetof(FIRandRange, Max) == 0x000004, "Member 'FIRandRange::Max' has a wrong offset!");

// ScriptStruct FSD.RandIntervalItem
// 0x000C (0x000C - 0x0000)
struct FRandIntervalItem final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIRandRange                            Range;                                             // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandIntervalItem) == 0x000004, "Wrong alignment on FRandIntervalItem");
static_assert(sizeof(FRandIntervalItem) == 0x00000C, "Wrong size on FRandIntervalItem");
static_assert(offsetof(FRandIntervalItem, Weight) == 0x000000, "Member 'FRandIntervalItem::Weight' has a wrong offset!");
static_assert(offsetof(FRandIntervalItem, Range) == 0x000004, "Member 'FRandIntervalItem::Range' has a wrong offset!");

// ScriptStruct FSD.AnimNode_Tentacle
// 0x0108 (0x01D0 - 0x00C8)
struct alignas(0x10) FAnimNode_Tentacle final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FBoneReference>                 BonesToModify;                                     // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_171C[0xF8];                                    // 0x00D8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_Tentacle) == 0x000010, "Wrong alignment on FAnimNode_Tentacle");
static_assert(sizeof(FAnimNode_Tentacle) == 0x0001D0, "Wrong size on FAnimNode_Tentacle");
static_assert(offsetof(FAnimNode_Tentacle, BonesToModify) == 0x0000C8, "Member 'FAnimNode_Tentacle::BonesToModify' has a wrong offset!");

// ScriptStruct FSD.JettyBootEventSettings
// 0x0050 (0x0050 - 0x0000)
struct FJettyBootEventSettings final
{
public:
	TSoftObjectPtr<class UTexture2D>              JettyBootCharacter;                                // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JettyBootArcadeOverlay;                            // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJettyBootEventSettings) == 0x000008, "Wrong alignment on FJettyBootEventSettings");
static_assert(sizeof(FJettyBootEventSettings) == 0x000050, "Wrong size on FJettyBootEventSettings");
static_assert(offsetof(FJettyBootEventSettings, JettyBootCharacter) == 0x000000, "Member 'FJettyBootEventSettings::JettyBootCharacter' has a wrong offset!");
static_assert(offsetof(FJettyBootEventSettings, JettyBootArcadeOverlay) == 0x000028, "Member 'FJettyBootEventSettings::JettyBootArcadeOverlay' has a wrong offset!");

// ScriptStruct FSD.TestAnimInstanceProxy
// 0x0020 (0x0790 - 0x0770)
struct FTestAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	bool                                          IsAlive;                                           // 0x0770(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171D[0x3];                                     // 0x0771(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomStartPosition;                               // 0x0774(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMoving;                                          // 0x077C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171E[0x3];                                     // 0x077D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkCyclePlayRate;                                 // 0x0780(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171F[0xC];                                     // 0x0784(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestAnimInstanceProxy) == 0x000010, "Wrong alignment on FTestAnimInstanceProxy");
static_assert(sizeof(FTestAnimInstanceProxy) == 0x000790, "Wrong size on FTestAnimInstanceProxy");
static_assert(offsetof(FTestAnimInstanceProxy, IsAlive) == 0x000770, "Member 'FTestAnimInstanceProxy::IsAlive' has a wrong offset!");
static_assert(offsetof(FTestAnimInstanceProxy, RandomStartPosition) == 0x000774, "Member 'FTestAnimInstanceProxy::RandomStartPosition' has a wrong offset!");
static_assert(offsetof(FTestAnimInstanceProxy, Speed) == 0x000778, "Member 'FTestAnimInstanceProxy::Speed' has a wrong offset!");
static_assert(offsetof(FTestAnimInstanceProxy, IsMoving) == 0x00077C, "Member 'FTestAnimInstanceProxy::IsMoving' has a wrong offset!");
static_assert(offsetof(FTestAnimInstanceProxy, WalkCyclePlayRate) == 0x000780, "Member 'FTestAnimInstanceProxy::WalkCyclePlayRate' has a wrong offset!");

// ScriptStruct FSD.FSDEventWithEnd
// 0x0020 (0x0020 - 0x0000)
struct FFSDEventWithEnd final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventExpirationDate;                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDEventWithEnd) == 0x000008, "Wrong alignment on FFSDEventWithEnd");
static_assert(sizeof(FFSDEventWithEnd) == 0x000020, "Wrong size on FFSDEventWithEnd");
static_assert(offsetof(FFSDEventWithEnd, EventName) == 0x000000, "Member 'FFSDEventWithEnd::EventName' has a wrong offset!");
static_assert(offsetof(FFSDEventWithEnd, EventExpirationDate) == 0x000010, "Member 'FFSDEventWithEnd::EventExpirationDate' has a wrong offset!");

// ScriptStruct FSD.HolidayMeshItems
// 0x0010 (0x0010 - 0x0000)
struct FHolidayMeshItems final
{
public:
	TArray<class USkeletalMeshComponent*>         HolidayMeshComponents;                             // 0x0000(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHolidayMeshItems) == 0x000008, "Wrong alignment on FHolidayMeshItems");
static_assert(sizeof(FHolidayMeshItems) == 0x000010, "Wrong size on FHolidayMeshItems");
static_assert(offsetof(FHolidayMeshItems, HolidayMeshComponents) == 0x000000, "Member 'FHolidayMeshItems::HolidayMeshComponents' has a wrong offset!");

// ScriptStruct FSD.DrinkableBarSlot
// 0x0014 (0x0014 - 0x0000)
struct FDrinkableBarSlot final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADrinkableActor>         DrinkableActor;                                    // 0x000C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDrinkableBarSlot) == 0x000004, "Wrong alignment on FDrinkableBarSlot");
static_assert(sizeof(FDrinkableBarSlot) == 0x000014, "Wrong size on FDrinkableBarSlot");
static_assert(offsetof(FDrinkableBarSlot, WorldLocation) == 0x000000, "Member 'FDrinkableBarSlot::WorldLocation' has a wrong offset!");
static_assert(offsetof(FDrinkableBarSlot, DrinkableActor) == 0x00000C, "Member 'FDrinkableBarSlot::DrinkableActor' has a wrong offset!");

// ScriptStruct FSD.UpgradeValues
// 0x001C (0x001C - 0x0000)
struct FUpgradeValues final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpgradedValue;                                     // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpgradedPercentageValue;                           // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldUpgradedValue;                                  // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldUpgradedPercentageValue;                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUpgradeCalucationType                        CalculationType;                                   // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemPreviewStatus                            PreviewStatus;                                     // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1720[0x2];                                     // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUpgradeValues) == 0x000004, "Wrong alignment on FUpgradeValues");
static_assert(sizeof(FUpgradeValues) == 0x00001C, "Wrong size on FUpgradeValues");
static_assert(offsetof(FUpgradeValues, BaseValue) == 0x000000, "Member 'FUpgradeValues::BaseValue' has a wrong offset!");
static_assert(offsetof(FUpgradeValues, UpgradedValue) == 0x000004, "Member 'FUpgradeValues::UpgradedValue' has a wrong offset!");
static_assert(offsetof(FUpgradeValues, UpgradedPercentageValue) == 0x000008, "Member 'FUpgradeValues::UpgradedPercentageValue' has a wrong offset!");
static_assert(offsetof(FUpgradeValues, OldUpgradedValue) == 0x00000C, "Member 'FUpgradeValues::OldUpgradedValue' has a wrong offset!");
static_assert(offsetof(FUpgradeValues, OldUpgradedPercentageValue) == 0x000010, "Member 'FUpgradeValues::OldUpgradedPercentageValue' has a wrong offset!");
static_assert(offsetof(FUpgradeValues, CurrentValue) == 0x000014, "Member 'FUpgradeValues::CurrentValue' has a wrong offset!");
static_assert(offsetof(FUpgradeValues, CalculationType) == 0x000018, "Member 'FUpgradeValues::CalculationType' has a wrong offset!");
static_assert(offsetof(FUpgradeValues, PreviewStatus) == 0x000019, "Member 'FUpgradeValues::PreviewStatus' has a wrong offset!");

// ScriptStruct FSD.ItemUpgradeStatText
// 0x0020 (0x0020 - 0x0000)
struct FItemUpgradeStatText final
{
public:
	class FText                                   StatText;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsAdventageous;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1721[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemUpgradeStatText) == 0x000008, "Wrong alignment on FItemUpgradeStatText");
static_assert(sizeof(FItemUpgradeStatText) == 0x000020, "Wrong size on FItemUpgradeStatText");
static_assert(offsetof(FItemUpgradeStatText, StatText) == 0x000000, "Member 'FItemUpgradeStatText::StatText' has a wrong offset!");
static_assert(offsetof(FItemUpgradeStatText, IsAdventageous) == 0x000018, "Member 'FItemUpgradeStatText::IsAdventageous' has a wrong offset!");

// ScriptStruct FSD.SplineTrailMaterial
// 0x0038 (0x0038 - 0x0000)
struct FSplineTrailMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1722[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplineTrailMaterial) == 0x000008, "Wrong alignment on FSplineTrailMaterial");
static_assert(sizeof(FSplineTrailMaterial) == 0x000038, "Wrong size on FSplineTrailMaterial");
static_assert(offsetof(FSplineTrailMaterial, Material) == 0x000000, "Member 'FSplineTrailMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSplineTrailMaterial, SlotName) == 0x000028, "Member 'FSplineTrailMaterial::SlotName' has a wrong offset!");
static_assert(offsetof(FSplineTrailMaterial, SlotIndex) == 0x000030, "Member 'FSplineTrailMaterial::SlotIndex' has a wrong offset!");

// ScriptStruct FSD.DeepDiveTesterItem
// 0x0030 (0x0030 - 0x0000)
struct FDeepDiveTesterItem final
{
public:
	class UMissionComplexity*                     Complexity;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionDuration*                       Duration;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionTemplate*                       Mission;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObjective>                 DeepDiveObjective;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionMutator*                        Mutator;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionWarning*                        Warning;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeepDiveTesterItem) == 0x000008, "Wrong alignment on FDeepDiveTesterItem");
static_assert(sizeof(FDeepDiveTesterItem) == 0x000030, "Wrong size on FDeepDiveTesterItem");
static_assert(offsetof(FDeepDiveTesterItem, Complexity) == 0x000000, "Member 'FDeepDiveTesterItem::Complexity' has a wrong offset!");
static_assert(offsetof(FDeepDiveTesterItem, Duration) == 0x000008, "Member 'FDeepDiveTesterItem::Duration' has a wrong offset!");
static_assert(offsetof(FDeepDiveTesterItem, Mission) == 0x000010, "Member 'FDeepDiveTesterItem::Mission' has a wrong offset!");
static_assert(offsetof(FDeepDiveTesterItem, DeepDiveObjective) == 0x000018, "Member 'FDeepDiveTesterItem::DeepDiveObjective' has a wrong offset!");
static_assert(offsetof(FDeepDiveTesterItem, Mutator) == 0x000020, "Member 'FDeepDiveTesterItem::Mutator' has a wrong offset!");
static_assert(offsetof(FDeepDiveTesterItem, Warning) == 0x000028, "Member 'FDeepDiveTesterItem::Warning' has a wrong offset!");

// ScriptStruct FSD.DeepDiveBank
// 0x0010 (0x0010 - 0x0000)
struct FDeepDiveBank final
{
public:
	class UDeepDive*                              NormalDeepDive;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDeepDive*                              HardDeepDive;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeepDiveBank) == 0x000008, "Wrong alignment on FDeepDiveBank");
static_assert(sizeof(FDeepDiveBank) == 0x000010, "Wrong size on FDeepDiveBank");
static_assert(offsetof(FDeepDiveBank, NormalDeepDive) == 0x000000, "Member 'FDeepDiveBank::NormalDeepDive' has a wrong offset!");
static_assert(offsetof(FDeepDiveBank, HardDeepDive) == 0x000008, "Member 'FDeepDiveBank::HardDeepDive' has a wrong offset!");

// ScriptStruct FSD.ArmorHealthSubItem
// 0x0028 (0x0028 - 0x0000)
struct FArmorHealthSubItem final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1723[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AdditionalBones;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   OptionalFXSocket;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorHealthSubItem) == 0x000008, "Wrong alignment on FArmorHealthSubItem");
static_assert(sizeof(FArmorHealthSubItem) == 0x000028, "Wrong size on FArmorHealthSubItem");
static_assert(offsetof(FArmorHealthSubItem, Health) == 0x000000, "Member 'FArmorHealthSubItem::Health' has a wrong offset!");
static_assert(offsetof(FArmorHealthSubItem, BoneName) == 0x000008, "Member 'FArmorHealthSubItem::BoneName' has a wrong offset!");
static_assert(offsetof(FArmorHealthSubItem, AdditionalBones) == 0x000010, "Member 'FArmorHealthSubItem::AdditionalBones' has a wrong offset!");
static_assert(offsetof(FArmorHealthSubItem, OptionalFXSocket) == 0x000020, "Member 'FArmorHealthSubItem::OptionalFXSocket' has a wrong offset!");

// ScriptStruct FSD.ArmorHealthItem
// 0x0018 (0x0018 - 0x0000)
struct FArmorHealthItem final
{
public:
	uint8                                         MaterialIndex;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HealthIsBreakPercentage;                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideAffectedByAmorBreak;                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewAffectedByArmorBreak;                           // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideArmorDamageEnabled;                        // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1724[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArmorHealthSubItem>            ArmorBones;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorHealthItem) == 0x000008, "Wrong alignment on FArmorHealthItem");
static_assert(sizeof(FArmorHealthItem) == 0x000018, "Wrong size on FArmorHealthItem");
static_assert(offsetof(FArmorHealthItem, MaterialIndex) == 0x000000, "Member 'FArmorHealthItem::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FArmorHealthItem, HealthIsBreakPercentage) == 0x000001, "Member 'FArmorHealthItem::HealthIsBreakPercentage' has a wrong offset!");
static_assert(offsetof(FArmorHealthItem, OverrideAffectedByAmorBreak) == 0x000002, "Member 'FArmorHealthItem::OverrideAffectedByAmorBreak' has a wrong offset!");
static_assert(offsetof(FArmorHealthItem, NewAffectedByArmorBreak) == 0x000003, "Member 'FArmorHealthItem::NewAffectedByArmorBreak' has a wrong offset!");
static_assert(offsetof(FArmorHealthItem, OverrideArmorDamageEnabled) == 0x000004, "Member 'FArmorHealthItem::OverrideArmorDamageEnabled' has a wrong offset!");
static_assert(offsetof(FArmorHealthItem, ArmorBones) == 0x000008, "Member 'FArmorHealthItem::ArmorBones' has a wrong offset!");

// ScriptStruct FSD.RichTextToken
// 0x0020 (0x0020 - 0x0000)
struct FRichTextToken final
{
public:
	class FString                                 Tag;                                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichTextToken) == 0x000008, "Wrong alignment on FRichTextToken");
static_assert(sizeof(FRichTextToken) == 0x000020, "Wrong size on FRichTextToken");
static_assert(offsetof(FRichTextToken, Tag) == 0x000000, "Member 'FRichTextToken::Tag' has a wrong offset!");
static_assert(offsetof(FRichTextToken, Text) == 0x000010, "Member 'FRichTextToken::Text' has a wrong offset!");

// ScriptStruct FSD.ObjectiveMissionIcon
// 0x0018 (0x0018 - 0x0000)
struct FObjectiveMissionIcon final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveMissionIcon) == 0x000008, "Wrong alignment on FObjectiveMissionIcon");
static_assert(sizeof(FObjectiveMissionIcon) == 0x000018, "Wrong size on FObjectiveMissionIcon");
static_assert(offsetof(FObjectiveMissionIcon, Texture) == 0x000000, "Member 'FObjectiveMissionIcon::Texture' has a wrong offset!");
static_assert(offsetof(FObjectiveMissionIcon, Tint) == 0x000008, "Member 'FObjectiveMissionIcon::Tint' has a wrong offset!");

// ScriptStruct FSD.CreditsReward
// 0x0020 (0x0020 - 0x0000)
struct FCreditsReward final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1725[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreditsReward) == 0x000008, "Wrong alignment on FCreditsReward");
static_assert(sizeof(FCreditsReward) == 0x000020, "Wrong size on FCreditsReward");
static_assert(offsetof(FCreditsReward, Description) == 0x000000, "Member 'FCreditsReward::Description' has a wrong offset!");
static_assert(offsetof(FCreditsReward, Amount) == 0x000018, "Member 'FCreditsReward::Amount' has a wrong offset!");

// ScriptStruct FSD.FriendInfo
// 0x0060 (0x0060 - 0x0000)
struct FFriendInfo final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RealName;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnline;                                          // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaying;                                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayingThisGame;                                 // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJoinable;                                        // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1726[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SessionId;                                         // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasVoiceSupport;                                   // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1727[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PresenceStatus;                                    // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendInfo) == 0x000008, "Wrong alignment on FFriendInfo");
static_assert(sizeof(FFriendInfo) == 0x000060, "Wrong size on FFriendInfo");
static_assert(offsetof(FFriendInfo, DisplayName) == 0x000000, "Member 'FFriendInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FFriendInfo, RealName) == 0x000010, "Member 'FFriendInfo::RealName' has a wrong offset!");
static_assert(offsetof(FFriendInfo, UserId) == 0x000020, "Member 'FFriendInfo::UserId' has a wrong offset!");
static_assert(offsetof(FFriendInfo, IsOnline) == 0x000030, "Member 'FFriendInfo::IsOnline' has a wrong offset!");
static_assert(offsetof(FFriendInfo, IsPlaying) == 0x000031, "Member 'FFriendInfo::IsPlaying' has a wrong offset!");
static_assert(offsetof(FFriendInfo, IsPlayingThisGame) == 0x000032, "Member 'FFriendInfo::IsPlayingThisGame' has a wrong offset!");
static_assert(offsetof(FFriendInfo, IsJoinable) == 0x000033, "Member 'FFriendInfo::IsJoinable' has a wrong offset!");
static_assert(offsetof(FFriendInfo, SessionId) == 0x000038, "Member 'FFriendInfo::SessionId' has a wrong offset!");
static_assert(offsetof(FFriendInfo, HasVoiceSupport) == 0x000048, "Member 'FFriendInfo::HasVoiceSupport' has a wrong offset!");
static_assert(offsetof(FFriendInfo, PresenceStatus) == 0x000050, "Member 'FFriendInfo::PresenceStatus' has a wrong offset!");

// ScriptStruct FSD.MissionShouts
// 0x0038 (0x0038 - 0x0000)
struct FMissionShouts final
{
public:
	class UDialogDataAsset*                       AfterDropPodExit;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OnExitPodDescending;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OnExitPodArrived;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OnCompletion;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OnCompletion_OneOfMultiple;                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OnAllReturnObjectivesCompleted;                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OnDeepDiveExitPodDescending;                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionShouts) == 0x000008, "Wrong alignment on FMissionShouts");
static_assert(sizeof(FMissionShouts) == 0x000038, "Wrong size on FMissionShouts");
static_assert(offsetof(FMissionShouts, AfterDropPodExit) == 0x000000, "Member 'FMissionShouts::AfterDropPodExit' has a wrong offset!");
static_assert(offsetof(FMissionShouts, OnExitPodDescending) == 0x000008, "Member 'FMissionShouts::OnExitPodDescending' has a wrong offset!");
static_assert(offsetof(FMissionShouts, OnExitPodArrived) == 0x000010, "Member 'FMissionShouts::OnExitPodArrived' has a wrong offset!");
static_assert(offsetof(FMissionShouts, OnCompletion) == 0x000018, "Member 'FMissionShouts::OnCompletion' has a wrong offset!");
static_assert(offsetof(FMissionShouts, OnCompletion_OneOfMultiple) == 0x000020, "Member 'FMissionShouts::OnCompletion_OneOfMultiple' has a wrong offset!");
static_assert(offsetof(FMissionShouts, OnAllReturnObjectivesCompleted) == 0x000028, "Member 'FMissionShouts::OnAllReturnObjectivesCompleted' has a wrong offset!");
static_assert(offsetof(FMissionShouts, OnDeepDiveExitPodDescending) == 0x000030, "Member 'FMissionShouts::OnDeepDiveExitPodDescending' has a wrong offset!");

// ScriptStruct FSD.MusicHandle
// 0x0004 (0x0004 - 0x0000)
struct FMusicHandle final
{
public:
	int32                                         MusicHandle;                                       // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicHandle) == 0x000004, "Wrong alignment on FMusicHandle");
static_assert(sizeof(FMusicHandle) == 0x000004, "Wrong size on FMusicHandle");
static_assert(offsetof(FMusicHandle, MusicHandle) == 0x000000, "Member 'FMusicHandle::MusicHandle' has a wrong offset!");

// ScriptStruct FSD.AfflictionEntry
// 0x000C (0x0018 - 0x000C)
struct FAfflictionEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_1728[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPawnAffliction*                        Affliction;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAfflictionEntry) == 0x000008, "Wrong alignment on FAfflictionEntry");
static_assert(sizeof(FAfflictionEntry) == 0x000018, "Wrong size on FAfflictionEntry");
static_assert(offsetof(FAfflictionEntry, Affliction) == 0x000010, "Member 'FAfflictionEntry::Affliction' has a wrong offset!");

// ScriptStruct FSD.AfflictionEntriesArray
// 0x0018 (0x0120 - 0x0108)
struct FAfflictionEntriesArray final : public FFastArraySerializer
{
public:
	TArray<struct FAfflictionEntry>               Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UPawnAfflictionComponent*               Owner;                                             // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAfflictionEntriesArray) == 0x000008, "Wrong alignment on FAfflictionEntriesArray");
static_assert(sizeof(FAfflictionEntriesArray) == 0x000120, "Wrong size on FAfflictionEntriesArray");
static_assert(offsetof(FAfflictionEntriesArray, Items) == 0x000108, "Member 'FAfflictionEntriesArray::Items' has a wrong offset!");
static_assert(offsetof(FAfflictionEntriesArray, Owner) == 0x000118, "Member 'FAfflictionEntriesArray::Owner' has a wrong offset!");

// ScriptStruct FSD.FakeMoverState
// 0x0060 (0x0060 - 0x0000)
struct FFakeMoverState final
{
public:
	float                                         TickRate;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickTime;                                          // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrevPos;                                           // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextPos;                                           // 0x0014(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrevSurfaceNormal;                                 // 0x0020(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextSurfaceNormal;                                 // 0x002C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1729[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0048(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NearSurface;                                       // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172A[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SignedDistToSurface;                               // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172B[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFakeMoverState) == 0x000008, "Wrong alignment on FFakeMoverState");
static_assert(sizeof(FFakeMoverState) == 0x000060, "Wrong size on FFakeMoverState");
static_assert(offsetof(FFakeMoverState, TickRate) == 0x000000, "Member 'FFakeMoverState::TickRate' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, TickTime) == 0x000004, "Member 'FFakeMoverState::TickTime' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, PrevPos) == 0x000008, "Member 'FFakeMoverState::PrevPos' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, NextPos) == 0x000014, "Member 'FFakeMoverState::NextPos' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, PrevSurfaceNormal) == 0x000020, "Member 'FFakeMoverState::PrevSurfaceNormal' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, NextSurfaceNormal) == 0x00002C, "Member 'FFakeMoverState::NextSurfaceNormal' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, AccumulatedTime) == 0x000038, "Member 'FFakeMoverState::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, Target) == 0x000040, "Member 'FFakeMoverState::Target' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, Velocity) == 0x000048, "Member 'FFakeMoverState::Velocity' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, NearSurface) == 0x000054, "Member 'FFakeMoverState::NearSurface' has a wrong offset!");
static_assert(offsetof(FFakeMoverState, SignedDistToSurface) == 0x000058, "Member 'FFakeMoverState::SignedDistToSurface' has a wrong offset!");

// ScriptStruct FSD.PawnAfflictionItem
// 0x0018 (0x0018 - 0x0000)
struct FPawnAfflictionItem final
{
public:
	uint8                                         Pad_172C[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAfflictionEffect*>              Afflictions;                                       // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnAfflictionItem) == 0x000008, "Wrong alignment on FPawnAfflictionItem");
static_assert(sizeof(FPawnAfflictionItem) == 0x000018, "Wrong size on FPawnAfflictionItem");
static_assert(offsetof(FPawnAfflictionItem, Afflictions) == 0x000008, "Member 'FPawnAfflictionItem::Afflictions' has a wrong offset!");

// ScriptStruct FSD.PropHuntContestantState
// 0x0018 (0x0018 - 0x0000)
struct FPropHuntContestantState final
{
public:
	EPropHuntRole                                 Role;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172D[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DisguiseSize;                                      // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerCharacter>        PlayerCharacter;                                   // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lives;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropHuntContestantState) == 0x000004, "Wrong alignment on FPropHuntContestantState");
static_assert(sizeof(FPropHuntContestantState) == 0x000018, "Wrong size on FPropHuntContestantState");
static_assert(offsetof(FPropHuntContestantState, Role) == 0x000000, "Member 'FPropHuntContestantState::Role' has a wrong offset!");
static_assert(offsetof(FPropHuntContestantState, DisguiseSize) == 0x000004, "Member 'FPropHuntContestantState::DisguiseSize' has a wrong offset!");
static_assert(offsetof(FPropHuntContestantState, PlayerCharacter) == 0x00000C, "Member 'FPropHuntContestantState::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FPropHuntContestantState, Lives) == 0x000014, "Member 'FPropHuntContestantState::Lives' has a wrong offset!");

// ScriptStruct FSD.WeightedLinePoint
// 0x001C (0x001C - 0x0000)
struct FWeightedLinePoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseRange;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkewFactor;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FillAmount;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedLinePoint) == 0x000004, "Wrong alignment on FWeightedLinePoint");
static_assert(sizeof(FWeightedLinePoint) == 0x00001C, "Wrong size on FWeightedLinePoint");
static_assert(offsetof(FWeightedLinePoint, Location) == 0x000000, "Member 'FWeightedLinePoint::Location' has a wrong offset!");
static_assert(offsetof(FWeightedLinePoint, Range) == 0x00000C, "Member 'FWeightedLinePoint::Range' has a wrong offset!");
static_assert(offsetof(FWeightedLinePoint, NoiseRange) == 0x000010, "Member 'FWeightedLinePoint::NoiseRange' has a wrong offset!");
static_assert(offsetof(FWeightedLinePoint, SkewFactor) == 0x000014, "Member 'FWeightedLinePoint::SkewFactor' has a wrong offset!");
static_assert(offsetof(FWeightedLinePoint, FillAmount) == 0x000018, "Member 'FWeightedLinePoint::FillAmount' has a wrong offset!");

// ScriptStruct FSD.PropHuntManagerState
// 0x0008 (0x0008 - 0x0000)
struct FPropHuntManagerState final
{
public:
	int32                                         ActiveProps;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveHunters;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropHuntManagerState) == 0x000004, "Wrong alignment on FPropHuntManagerState");
static_assert(sizeof(FPropHuntManagerState) == 0x000008, "Wrong size on FPropHuntManagerState");
static_assert(offsetof(FPropHuntManagerState, ActiveProps) == 0x000000, "Member 'FPropHuntManagerState::ActiveProps' has a wrong offset!");
static_assert(offsetof(FPropHuntManagerState, ActiveHunters) == 0x000004, "Member 'FPropHuntManagerState::ActiveHunters' has a wrong offset!");

// ScriptStruct FSD.CarveWithSTLMeshOperationData
// 0x0070 (0x0070 - 0x0000)
struct FCarveWithSTLMeshOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172E[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USTLMeshCarver*                         STLMeshCarver;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshCarver*                      StaticMeshCarver;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainMaterial*                       Material;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECarveFilterType                              CarveFilter;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPreciousMaterialOptions                      Precious;                                          // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172F[0x2];                                     // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrixWithExactSync                   Transform;                                         // 0x0024(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1730[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelGenerationCarverComponent*        LevelGenerationComponent;                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCarveWithSTLMeshOperationData) == 0x000008, "Wrong alignment on FCarveWithSTLMeshOperationData");
static_assert(sizeof(FCarveWithSTLMeshOperationData) == 0x000070, "Wrong size on FCarveWithSTLMeshOperationData");
static_assert(offsetof(FCarveWithSTLMeshOperationData, OperationNumber) == 0x000000, "Member 'FCarveWithSTLMeshOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FCarveWithSTLMeshOperationData, STLMeshCarver) == 0x000008, "Member 'FCarveWithSTLMeshOperationData::STLMeshCarver' has a wrong offset!");
static_assert(offsetof(FCarveWithSTLMeshOperationData, StaticMeshCarver) == 0x000010, "Member 'FCarveWithSTLMeshOperationData::StaticMeshCarver' has a wrong offset!");
static_assert(offsetof(FCarveWithSTLMeshOperationData, Material) == 0x000018, "Member 'FCarveWithSTLMeshOperationData::Material' has a wrong offset!");
static_assert(offsetof(FCarveWithSTLMeshOperationData, CarveFilter) == 0x000020, "Member 'FCarveWithSTLMeshOperationData::CarveFilter' has a wrong offset!");
static_assert(offsetof(FCarveWithSTLMeshOperationData, Precious) == 0x000021, "Member 'FCarveWithSTLMeshOperationData::Precious' has a wrong offset!");
static_assert(offsetof(FCarveWithSTLMeshOperationData, Transform) == 0x000024, "Member 'FCarveWithSTLMeshOperationData::Transform' has a wrong offset!");
static_assert(offsetof(FCarveWithSTLMeshOperationData, LevelGenerationComponent) == 0x000068, "Member 'FCarveWithSTLMeshOperationData::LevelGenerationComponent' has a wrong offset!");

// ScriptStruct FSD.TrackBuilderPoint
// 0x0028 (0x0028 - 0x0000)
struct FTrackBuilderPoint final
{
public:
	ETrackBuildPlacementState                     PlacementState;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1731[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Location;                                          // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    EulerRotation;                                     // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPointValid;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1732[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UTrackBuilderConnectPoint> ConnectPoint;                                      // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackBuilderPoint) == 0x000004, "Wrong alignment on FTrackBuilderPoint");
static_assert(sizeof(FTrackBuilderPoint) == 0x000028, "Wrong size on FTrackBuilderPoint");
static_assert(offsetof(FTrackBuilderPoint, PlacementState) == 0x000000, "Member 'FTrackBuilderPoint::PlacementState' has a wrong offset!");
static_assert(offsetof(FTrackBuilderPoint, Location) == 0x000004, "Member 'FTrackBuilderPoint::Location' has a wrong offset!");
static_assert(offsetof(FTrackBuilderPoint, EulerRotation) == 0x000010, "Member 'FTrackBuilderPoint::EulerRotation' has a wrong offset!");
static_assert(offsetof(FTrackBuilderPoint, bPointValid) == 0x00001C, "Member 'FTrackBuilderPoint::bPointValid' has a wrong offset!");
static_assert(offsetof(FTrackBuilderPoint, ConnectPoint) == 0x000020, "Member 'FTrackBuilderPoint::ConnectPoint' has a wrong offset!");

// ScriptStruct FSD.GeneratedDebrisItem
// 0x0010 (0x0010 - 0x0000)
struct FGeneratedDebrisItem final
{
public:
	class UDebrisBase*                            Debris;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Influencer;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneratedDebrisItem) == 0x000008, "Wrong alignment on FGeneratedDebrisItem");
static_assert(sizeof(FGeneratedDebrisItem) == 0x000010, "Wrong size on FGeneratedDebrisItem");
static_assert(offsetof(FGeneratedDebrisItem, Debris) == 0x000000, "Member 'FGeneratedDebrisItem::Debris' has a wrong offset!");
static_assert(offsetof(FGeneratedDebrisItem, Influencer) == 0x000008, "Member 'FGeneratedDebrisItem::Influencer' has a wrong offset!");

// ScriptStruct FSD.ActiveOutline
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FActiveOutline final
{
public:
	uint8                                         Pad_1733[0xC];                                     // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveOutline) == 0x000004, "Wrong alignment on FActiveOutline");
static_assert(sizeof(FActiveOutline) == 0x00000C, "Wrong size on FActiveOutline");

// ScriptStruct FSD.DeepDiveRewardItem
// 0x0010 (0x0010 - 0x0000)
struct FDeepDiveRewardItem final
{
public:
	class USchematic*                             Schematic;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasAlreadyGiven;                                   // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1734[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeepDiveRewardItem) == 0x000008, "Wrong alignment on FDeepDiveRewardItem");
static_assert(sizeof(FDeepDiveRewardItem) == 0x000010, "Wrong size on FDeepDiveRewardItem");
static_assert(offsetof(FDeepDiveRewardItem, Schematic) == 0x000000, "Member 'FDeepDiveRewardItem::Schematic' has a wrong offset!");
static_assert(offsetof(FDeepDiveRewardItem, Stage) == 0x000008, "Member 'FDeepDiveRewardItem::Stage' has a wrong offset!");
static_assert(offsetof(FDeepDiveRewardItem, WasAlreadyGiven) == 0x00000C, "Member 'FDeepDiveRewardItem::WasAlreadyGiven' has a wrong offset!");

// ScriptStruct FSD.HUDVisibilityRegisteredWidget
// 0x000C (0x000C - 0x0000)
struct FHUDVisibilityRegisteredWidget final
{
public:
	TWeakObjectPtr<class UWidget>                 Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1735[0x4];                                     // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHUDVisibilityRegisteredWidget) == 0x000004, "Wrong alignment on FHUDVisibilityRegisteredWidget");
static_assert(sizeof(FHUDVisibilityRegisteredWidget) == 0x00000C, "Wrong size on FHUDVisibilityRegisteredWidget");
static_assert(offsetof(FHUDVisibilityRegisteredWidget, Widget) == 0x000000, "Member 'FHUDVisibilityRegisteredWidget::Widget' has a wrong offset!");

// ScriptStruct FSD.YesNoPromptSettings
// 0x0040 (0x0040 - 0x0000)
struct FYesNoPromptSettings final
{
public:
	TSubclassOf<class UYesNoPromptWidget>         WidgetClass;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1736[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FYesNoPromptSettings) == 0x000008, "Wrong alignment on FYesNoPromptSettings");
static_assert(sizeof(FYesNoPromptSettings) == 0x000040, "Wrong size on FYesNoPromptSettings");
static_assert(offsetof(FYesNoPromptSettings, WidgetClass) == 0x000000, "Member 'FYesNoPromptSettings::WidgetClass' has a wrong offset!");
static_assert(offsetof(FYesNoPromptSettings, ZOrder) == 0x000008, "Member 'FYesNoPromptSettings::ZOrder' has a wrong offset!");
static_assert(offsetof(FYesNoPromptSettings, Title) == 0x000010, "Member 'FYesNoPromptSettings::Title' has a wrong offset!");
static_assert(offsetof(FYesNoPromptSettings, Message) == 0x000028, "Member 'FYesNoPromptSettings::Message' has a wrong offset!");

// ScriptStruct FSD.AssetsToLoadSettings
// 0x0010 (0x0010 - 0x0000)
struct FAssetsToLoadSettings final
{
public:
	TArray<TSoftClassPtr<class UClass>>           ActorsPermanently;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssetsToLoadSettings) == 0x000008, "Wrong alignment on FAssetsToLoadSettings");
static_assert(sizeof(FAssetsToLoadSettings) == 0x000010, "Wrong size on FAssetsToLoadSettings");
static_assert(offsetof(FAssetsToLoadSettings, ActorsPermanently) == 0x000000, "Member 'FAssetsToLoadSettings::ActorsPermanently' has a wrong offset!");

// ScriptStruct FSD.DailyDeal
// 0x0018 (0x0018 - 0x0000)
struct FDailyDeal final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDealType                                     DealType;                                          // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1737[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResourceAmount;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Credits;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangePercent;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyDeal) == 0x000008, "Wrong alignment on FDailyDeal");
static_assert(sizeof(FDailyDeal) == 0x000018, "Wrong size on FDailyDeal");
static_assert(offsetof(FDailyDeal, Resource) == 0x000000, "Member 'FDailyDeal::Resource' has a wrong offset!");
static_assert(offsetof(FDailyDeal, DealType) == 0x000008, "Member 'FDailyDeal::DealType' has a wrong offset!");
static_assert(offsetof(FDailyDeal, ResourceAmount) == 0x00000C, "Member 'FDailyDeal::ResourceAmount' has a wrong offset!");
static_assert(offsetof(FDailyDeal, Credits) == 0x000010, "Member 'FDailyDeal::Credits' has a wrong offset!");
static_assert(offsetof(FDailyDeal, ChangePercent) == 0x000014, "Member 'FDailyDeal::ChangePercent' has a wrong offset!");

// ScriptStruct FSD.MultiHitscanHit
// 0x0020 (0x0020 - 0x0000)
struct FMultiHitscanHit final
{
public:
	uint8                                         TargetComponentIndex;                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PhysicalMaterialIndex;                             // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1738[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    HitLocation;                                       // 0x0004(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0010(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BoneIndex;                                         // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayImpactSound;                                   // 0x001D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpawnDecal;                                        // 0x001E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1739[0x1];                                     // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMultiHitscanHit) == 0x000004, "Wrong alignment on FMultiHitscanHit");
static_assert(sizeof(FMultiHitscanHit) == 0x000020, "Wrong size on FMultiHitscanHit");
static_assert(offsetof(FMultiHitscanHit, TargetComponentIndex) == 0x000000, "Member 'FMultiHitscanHit::TargetComponentIndex' has a wrong offset!");
static_assert(offsetof(FMultiHitscanHit, PhysicalMaterialIndex) == 0x000001, "Member 'FMultiHitscanHit::PhysicalMaterialIndex' has a wrong offset!");
static_assert(offsetof(FMultiHitscanHit, HitLocation) == 0x000004, "Member 'FMultiHitscanHit::HitLocation' has a wrong offset!");
static_assert(offsetof(FMultiHitscanHit, ImpactNormal) == 0x000010, "Member 'FMultiHitscanHit::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FMultiHitscanHit, BoneIndex) == 0x00001C, "Member 'FMultiHitscanHit::BoneIndex' has a wrong offset!");
static_assert(offsetof(FMultiHitscanHit, PlayImpactSound) == 0x00001D, "Member 'FMultiHitscanHit::PlayImpactSound' has a wrong offset!");
static_assert(offsetof(FMultiHitscanHit, SpawnDecal) == 0x00001E, "Member 'FMultiHitscanHit::SpawnDecal' has a wrong offset!");

// ScriptStruct FSD.MultiHitScanHits
// 0x0030 (0x0030 - 0x0000)
struct FMultiHitScanHits final
{
public:
	TArray<struct FMultiHitscanHit>               Hits;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            Components;                                        // 0x0010(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UFSDPhysicalMaterial*>           PhysicalMaterials;                                 // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiHitScanHits) == 0x000008, "Wrong alignment on FMultiHitScanHits");
static_assert(sizeof(FMultiHitScanHits) == 0x000030, "Wrong size on FMultiHitScanHits");
static_assert(offsetof(FMultiHitScanHits, Hits) == 0x000000, "Member 'FMultiHitScanHits::Hits' has a wrong offset!");
static_assert(offsetof(FMultiHitScanHits, Components) == 0x000010, "Member 'FMultiHitScanHits::Components' has a wrong offset!");
static_assert(offsetof(FMultiHitScanHits, PhysicalMaterials) == 0x000020, "Member 'FMultiHitScanHits::PhysicalMaterials' has a wrong offset!");

// ScriptStruct FSD.BulletPathSegment
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FBulletPathSegment final
{
public:
	uint8                                         Pad_173A[0x1C];                                    // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletPathSegment) == 0x000004, "Wrong alignment on FBulletPathSegment");
static_assert(sizeof(FBulletPathSegment) == 0x00001C, "Wrong size on FBulletPathSegment");

// ScriptStruct FSD.AudioWithCooldown
// 0x0010 (0x0010 - 0x0000)
struct FAudioWithCooldown final
{
public:
	class USoundCue*                              Audio;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoolDown;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_173B[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioWithCooldown) == 0x000008, "Wrong alignment on FAudioWithCooldown");
static_assert(sizeof(FAudioWithCooldown) == 0x000010, "Wrong size on FAudioWithCooldown");
static_assert(offsetof(FAudioWithCooldown, Audio) == 0x000000, "Member 'FAudioWithCooldown::Audio' has a wrong offset!");
static_assert(offsetof(FAudioWithCooldown, CoolDown) == 0x000008, "Member 'FAudioWithCooldown::CoolDown' has a wrong offset!");

// ScriptStruct FSD.TracerData
// 0x0030 (0x0030 - 0x0000)
struct FTracerData final
{
public:
	class UFXSystemAsset*                         MainParticle;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TrailParticle;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173C[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              WhizbySound;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhizBySoundCooldown;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173D[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTracerData) == 0x000008, "Wrong alignment on FTracerData");
static_assert(sizeof(FTracerData) == 0x000030, "Wrong size on FTracerData");
static_assert(offsetof(FTracerData, MainParticle) == 0x000000, "Member 'FTracerData::MainParticle' has a wrong offset!");
static_assert(offsetof(FTracerData, TrailParticle) == 0x000008, "Member 'FTracerData::TrailParticle' has a wrong offset!");
static_assert(offsetof(FTracerData, Speed) == 0x000010, "Member 'FTracerData::Speed' has a wrong offset!");
static_assert(offsetof(FTracerData, WhizbySound) == 0x000018, "Member 'FTracerData::WhizbySound' has a wrong offset!");
static_assert(offsetof(FTracerData, WhizBySoundCooldown) == 0x000020, "Member 'FTracerData::WhizBySoundCooldown' has a wrong offset!");
static_assert(offsetof(FTracerData, Offset) == 0x000024, "Member 'FTracerData::Offset' has a wrong offset!");
static_assert(offsetof(FTracerData, MinDistance) == 0x000028, "Member 'FTracerData::MinDistance' has a wrong offset!");

// ScriptStruct FSD.MinersManualDescription
// 0x0040 (0x0040 - 0x0000)
struct FMinersManualDescription final
{
public:
	class FText                                   Headline;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RichDescription;                                   // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             ImageFront;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ImageBackground;                                   // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinersManualDescription) == 0x000008, "Wrong alignment on FMinersManualDescription");
static_assert(sizeof(FMinersManualDescription) == 0x000040, "Wrong size on FMinersManualDescription");
static_assert(offsetof(FMinersManualDescription, Headline) == 0x000000, "Member 'FMinersManualDescription::Headline' has a wrong offset!");
static_assert(offsetof(FMinersManualDescription, RichDescription) == 0x000018, "Member 'FMinersManualDescription::RichDescription' has a wrong offset!");
static_assert(offsetof(FMinersManualDescription, ImageFront) == 0x000030, "Member 'FMinersManualDescription::ImageFront' has a wrong offset!");
static_assert(offsetof(FMinersManualDescription, ImageBackground) == 0x000038, "Member 'FMinersManualDescription::ImageBackground' has a wrong offset!");

// ScriptStruct FSD.WaveEntry
// 0x0030 (0x0030 - 0x0000)
struct FWaveEntry final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173E[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WaveController;                                    // 0x0008(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWaveEntry) == 0x000008, "Wrong alignment on FWaveEntry");
static_assert(sizeof(FWaveEntry) == 0x000030, "Wrong size on FWaveEntry");
static_assert(offsetof(FWaveEntry, Weight) == 0x000000, "Member 'FWaveEntry::Weight' has a wrong offset!");
static_assert(offsetof(FWaveEntry, WaveController) == 0x000008, "Member 'FWaveEntry::WaveController' has a wrong offset!");

// ScriptStruct FSD.TipsTableRow
// 0x0068 (0x0070 - 0x0008)
struct FTipsTableRow final : public FTableRowBase
{
public:
	class FText                                   Header;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   InputText;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   InputTextControllerOverride;                       // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         TimeToDisplay;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173F[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTipsTableRow) == 0x000008, "Wrong alignment on FTipsTableRow");
static_assert(sizeof(FTipsTableRow) == 0x000070, "Wrong size on FTipsTableRow");
static_assert(offsetof(FTipsTableRow, Header) == 0x000008, "Member 'FTipsTableRow::Header' has a wrong offset!");
static_assert(offsetof(FTipsTableRow, Description) == 0x000020, "Member 'FTipsTableRow::Description' has a wrong offset!");
static_assert(offsetof(FTipsTableRow, InputText) == 0x000038, "Member 'FTipsTableRow::InputText' has a wrong offset!");
static_assert(offsetof(FTipsTableRow, InputTextControllerOverride) == 0x000050, "Member 'FTipsTableRow::InputTextControllerOverride' has a wrong offset!");
static_assert(offsetof(FTipsTableRow, TimeToDisplay) == 0x000068, "Member 'FTipsTableRow::TimeToDisplay' has a wrong offset!");

// ScriptStruct FSD.ProjectileSwitch
// 0x0010 (0x0010 - 0x0000)
struct FProjectileSwitch final
{
public:
	TSubclassOf<class AProjectileBase>            ProjectileClass;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileSwitchCriteria                     CriteriaType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1740[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CriteriaThreshhold;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileSwitch) == 0x000008, "Wrong alignment on FProjectileSwitch");
static_assert(sizeof(FProjectileSwitch) == 0x000010, "Wrong size on FProjectileSwitch");
static_assert(offsetof(FProjectileSwitch, ProjectileClass) == 0x000000, "Member 'FProjectileSwitch::ProjectileClass' has a wrong offset!");
static_assert(offsetof(FProjectileSwitch, CriteriaType) == 0x000008, "Member 'FProjectileSwitch::CriteriaType' has a wrong offset!");
static_assert(offsetof(FProjectileSwitch, CriteriaThreshhold) == 0x00000C, "Member 'FProjectileSwitch::CriteriaThreshhold' has a wrong offset!");

// ScriptStruct FSD.HealthRegenerationParams
// 0x0010 (0x0010 - 0x0000)
struct FHealthRegenerationParams final
{
public:
	bool                                          bIsRegenerating;                                   // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1741[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayAfterDamage;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPerSecond;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHealthRatio;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealthRegenerationParams) == 0x000004, "Wrong alignment on FHealthRegenerationParams");
static_assert(sizeof(FHealthRegenerationParams) == 0x000010, "Wrong size on FHealthRegenerationParams");
static_assert(offsetof(FHealthRegenerationParams, bIsRegenerating) == 0x000000, "Member 'FHealthRegenerationParams::bIsRegenerating' has a wrong offset!");
static_assert(offsetof(FHealthRegenerationParams, DelayAfterDamage) == 0x000004, "Member 'FHealthRegenerationParams::DelayAfterDamage' has a wrong offset!");
static_assert(offsetof(FHealthRegenerationParams, HealthPerSecond) == 0x000008, "Member 'FHealthRegenerationParams::HealthPerSecond' has a wrong offset!");
static_assert(offsetof(FHealthRegenerationParams, TargetHealthRatio) == 0x00000C, "Member 'FHealthRegenerationParams::TargetHealthRatio' has a wrong offset!");

// ScriptStruct FSD.HackingUsableState
// 0x0014 (0x0014 - 0x0000)
struct FHackingUsableState final
{
public:
	bool                                          bIsHacked;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1742[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHackingToolItem>        BeingHackedByItem;                                 // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerCharacter>        HackedBy;                                          // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHackingUsableState) == 0x000004, "Wrong alignment on FHackingUsableState");
static_assert(sizeof(FHackingUsableState) == 0x000014, "Wrong size on FHackingUsableState");
static_assert(offsetof(FHackingUsableState, bIsHacked) == 0x000000, "Member 'FHackingUsableState::bIsHacked' has a wrong offset!");
static_assert(offsetof(FHackingUsableState, BeingHackedByItem) == 0x000004, "Member 'FHackingUsableState::BeingHackedByItem' has a wrong offset!");
static_assert(offsetof(FHackingUsableState, HackedBy) == 0x00000C, "Member 'FHackingUsableState::HackedBy' has a wrong offset!");

// ScriptStruct FSD.BoscoAbilityTarget
// 0x0018 (0x0018 - 0x0000)
struct FBoscoAbilityTarget final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1743[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoscoAbilityTarget) == 0x000008, "Wrong alignment on FBoscoAbilityTarget");
static_assert(sizeof(FBoscoAbilityTarget) == 0x000018, "Wrong size on FBoscoAbilityTarget");
static_assert(offsetof(FBoscoAbilityTarget, Location) == 0x000000, "Member 'FBoscoAbilityTarget::Location' has a wrong offset!");
static_assert(offsetof(FBoscoAbilityTarget, Actor) == 0x000010, "Member 'FBoscoAbilityTarget::Actor' has a wrong offset!");

// ScriptStruct FSD.SawFakeMoveState
// 0x0004 (0x0028 - 0x0024)
struct FSawFakeMoveState final : public FFakeMoveState
{
public:
	float                                         GravityTimer;                                      // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSawFakeMoveState) == 0x000004, "Wrong alignment on FSawFakeMoveState");
static_assert(sizeof(FSawFakeMoveState) == 0x000028, "Wrong size on FSawFakeMoveState");
static_assert(offsetof(FSawFakeMoveState, GravityTimer) == 0x000024, "Member 'FSawFakeMoveState::GravityTimer' has a wrong offset!");

// ScriptStruct FSD.LockCounter
// 0x000C (0x000C - 0x0000)
struct FLockCounter final
{
public:
	int32                                         LockCount;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LockedActor;                                       // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLockCounter) == 0x000004, "Wrong alignment on FLockCounter");
static_assert(sizeof(FLockCounter) == 0x00000C, "Wrong size on FLockCounter");
static_assert(offsetof(FLockCounter, LockCount) == 0x000000, "Member 'FLockCounter::LockCount' has a wrong offset!");
static_assert(offsetof(FLockCounter, LockedActor) == 0x000004, "Member 'FLockCounter::LockedActor' has a wrong offset!");

// ScriptStruct FSD.DisplayContent
// 0x0050 (0x0050 - 0x0000)
struct FDisplayContent final
{
public:
	class UAnimationAsset*                        Idle;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        React;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Mesh;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PivotOffset;                                       // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1744[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDisplayContent) == 0x000008, "Wrong alignment on FDisplayContent");
static_assert(sizeof(FDisplayContent) == 0x000050, "Wrong size on FDisplayContent");
static_assert(offsetof(FDisplayContent, Idle) == 0x000000, "Member 'FDisplayContent::Idle' has a wrong offset!");
static_assert(offsetof(FDisplayContent, React) == 0x000008, "Member 'FDisplayContent::React' has a wrong offset!");
static_assert(offsetof(FDisplayContent, Mesh) == 0x000010, "Member 'FDisplayContent::Mesh' has a wrong offset!");
static_assert(offsetof(FDisplayContent, PivotOffset) == 0x000018, "Member 'FDisplayContent::PivotOffset' has a wrong offset!");
static_assert(offsetof(FDisplayContent, RotationOffset) == 0x000024, "Member 'FDisplayContent::RotationOffset' has a wrong offset!");
static_assert(offsetof(FDisplayContent, Scale) == 0x000030, "Member 'FDisplayContent::Scale' has a wrong offset!");
static_assert(offsetof(FDisplayContent, Description) == 0x000040, "Member 'FDisplayContent::Description' has a wrong offset!");

// ScriptStruct FSD.UpgradeCostItem
// 0x0010 (0x0010 - 0x0000)
struct FUpgradeCostItem final
{
public:
	TArray<int32>                                 Amounts;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpgradeCostItem) == 0x000008, "Wrong alignment on FUpgradeCostItem");
static_assert(sizeof(FUpgradeCostItem) == 0x000010, "Wrong size on FUpgradeCostItem");
static_assert(offsetof(FUpgradeCostItem, Amounts) == 0x000000, "Member 'FUpgradeCostItem::Amounts' has a wrong offset!");

// ScriptStruct FSD.EnemySpawnItem
// 0x0010 (0x0010 - 0x0000)
struct FEnemySpawnItem final
{
public:
	class UEnemyDescriptor*                       Enemy;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VeteranComposition;                                // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemySpawnItem) == 0x000008, "Wrong alignment on FEnemySpawnItem");
static_assert(sizeof(FEnemySpawnItem) == 0x000010, "Wrong size on FEnemySpawnItem");
static_assert(offsetof(FEnemySpawnItem, Enemy) == 0x000000, "Member 'FEnemySpawnItem::Enemy' has a wrong offset!");
static_assert(offsetof(FEnemySpawnItem, Count) == 0x000008, "Member 'FEnemySpawnItem::Count' has a wrong offset!");
static_assert(offsetof(FEnemySpawnItem, VeteranComposition) == 0x00000C, "Member 'FEnemySpawnItem::VeteranComposition' has a wrong offset!");

// ScriptStruct FSD.VeinResource
// 0x0030 (0x0030 - 0x0000)
struct FVeinResource final
{
public:
	class UVeinResourceCreator*                   ResourceCreator;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VeinLengthToGenerate;                              // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1745[0x24];                                    // 0x000C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVeinResource) == 0x000008, "Wrong alignment on FVeinResource");
static_assert(sizeof(FVeinResource) == 0x000030, "Wrong size on FVeinResource");
static_assert(offsetof(FVeinResource, ResourceCreator) == 0x000000, "Member 'FVeinResource::ResourceCreator' has a wrong offset!");
static_assert(offsetof(FVeinResource, VeinLengthToGenerate) == 0x000008, "Member 'FVeinResource::VeinLengthToGenerate' has a wrong offset!");

// ScriptStruct FSD.ProjectileImpact
// 0x0038 (0x0038 - 0x0000)
struct FProjectileImpact final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysMat;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockingHit;                                      // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1746[0x3];                                     // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileImpact) == 0x000008, "Wrong alignment on FProjectileImpact");
static_assert(sizeof(FProjectileImpact) == 0x000038, "Wrong size on FProjectileImpact");
static_assert(offsetof(FProjectileImpact, Location) == 0x000000, "Member 'FProjectileImpact::Location' has a wrong offset!");
static_assert(offsetof(FProjectileImpact, Normal) == 0x00000C, "Member 'FProjectileImpact::Normal' has a wrong offset!");
static_assert(offsetof(FProjectileImpact, Actor) == 0x000018, "Member 'FProjectileImpact::Actor' has a wrong offset!");
static_assert(offsetof(FProjectileImpact, Component) == 0x000020, "Member 'FProjectileImpact::Component' has a wrong offset!");
static_assert(offsetof(FProjectileImpact, PhysMat) == 0x000028, "Member 'FProjectileImpact::PhysMat' has a wrong offset!");
static_assert(offsetof(FProjectileImpact, BoneIndex) == 0x000030, "Member 'FProjectileImpact::BoneIndex' has a wrong offset!");
static_assert(offsetof(FProjectileImpact, bBlockingHit) == 0x000034, "Member 'FProjectileImpact::bBlockingHit' has a wrong offset!");

// ScriptStruct FSD.ProjectileState
// 0x0028 (0x0028 - 0x0000)
struct FProjectileState final
{
public:
	struct FVector_NetQuantize                    Velocity;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        HomingTargetComponent;                             // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsSimulating : 1;                                  // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsBouncy : 1;                                      // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsHoming : 1;                                      // 0x0020(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsPenetrating : 1;                                 // 0x0020(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1747[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileState) == 0x000008, "Wrong alignment on FProjectileState");
static_assert(sizeof(FProjectileState) == 0x000028, "Wrong size on FProjectileState");
static_assert(offsetof(FProjectileState, Velocity) == 0x000000, "Member 'FProjectileState::Velocity' has a wrong offset!");
static_assert(offsetof(FProjectileState, Location) == 0x00000C, "Member 'FProjectileState::Location' has a wrong offset!");
static_assert(offsetof(FProjectileState, HomingTargetComponent) == 0x000018, "Member 'FProjectileState::HomingTargetComponent' has a wrong offset!");

// ScriptStruct FSD.ReplicatedObjectives
// 0x0018 (0x0018 - 0x0000)
struct FReplicatedObjectives final
{
public:
	bool                                          HasReplicated;                                     // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1748[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObjective*>                     Objectives;                                        // 0x0008(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedObjectives) == 0x000008, "Wrong alignment on FReplicatedObjectives");
static_assert(sizeof(FReplicatedObjectives) == 0x000018, "Wrong size on FReplicatedObjectives");
static_assert(offsetof(FReplicatedObjectives, HasReplicated) == 0x000000, "Member 'FReplicatedObjectives::HasReplicated' has a wrong offset!");
static_assert(offsetof(FReplicatedObjectives, Objectives) == 0x000008, "Member 'FReplicatedObjectives::Objectives' has a wrong offset!");

// ScriptStruct FSD.SentryGunMuzzleSetup
// 0x0010 (0x0010 - 0x0000)
struct FSentryGunMuzzleSetup final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireMontage;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSentryGunMuzzleSetup) == 0x000008, "Wrong alignment on FSentryGunMuzzleSetup");
static_assert(sizeof(FSentryGunMuzzleSetup) == 0x000010, "Wrong size on FSentryGunMuzzleSetup");
static_assert(offsetof(FSentryGunMuzzleSetup, SocketName) == 0x000000, "Member 'FSentryGunMuzzleSetup::SocketName' has a wrong offset!");
static_assert(offsetof(FSentryGunMuzzleSetup, FireMontage) == 0x000008, "Member 'FSentryGunMuzzleSetup::FireMontage' has a wrong offset!");

// ScriptStruct FSD.ContrailSettings
// 0x0010 (0x0010 - 0x0000)
struct FContrailSettings final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfLenght;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hellfire;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1749[0x1];                                     // 0x000D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Electric;                                          // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174A[0x1];                                     // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContrailSettings) == 0x000004, "Wrong alignment on FContrailSettings");
static_assert(sizeof(FContrailSettings) == 0x000010, "Wrong size on FContrailSettings");
static_assert(offsetof(FContrailSettings, Radius) == 0x000000, "Member 'FContrailSettings::Radius' has a wrong offset!");
static_assert(offsetof(FContrailSettings, HalfLenght) == 0x000004, "Member 'FContrailSettings::HalfLenght' has a wrong offset!");
static_assert(offsetof(FContrailSettings, LifeTime) == 0x000008, "Member 'FContrailSettings::LifeTime' has a wrong offset!");
static_assert(offsetof(FContrailSettings, Hellfire) == 0x00000C, "Member 'FContrailSettings::Hellfire' has a wrong offset!");
static_assert(offsetof(FContrailSettings, Electric) == 0x00000E, "Member 'FContrailSettings::Electric' has a wrong offset!");

// ScriptStruct FSD.BlueprintFriend
// 0x0038 (0x0038 - 0x0000)
struct FBlueprintFriend final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RealName;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFriendOnlineStatusEnum                       OnlineStatus;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174B[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UniqueNetId;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintFriend) == 0x000008, "Wrong alignment on FBlueprintFriend");
static_assert(sizeof(FBlueprintFriend) == 0x000038, "Wrong size on FBlueprintFriend");
static_assert(offsetof(FBlueprintFriend, DisplayName) == 0x000000, "Member 'FBlueprintFriend::DisplayName' has a wrong offset!");
static_assert(offsetof(FBlueprintFriend, RealName) == 0x000010, "Member 'FBlueprintFriend::RealName' has a wrong offset!");
static_assert(offsetof(FBlueprintFriend, OnlineStatus) == 0x000020, "Member 'FBlueprintFriend::OnlineStatus' has a wrong offset!");
static_assert(offsetof(FBlueprintFriend, UniqueNetId) == 0x000028, "Member 'FBlueprintFriend::UniqueNetId' has a wrong offset!");

// ScriptStruct FSD.ActiveAudioItem
// 0x0010 (0x0010 - 0x0000)
struct FActiveAudioItem final
{
public:
	class UAudioComponent*                        Audio;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeoutDuration;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174C[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveAudioItem) == 0x000008, "Wrong alignment on FActiveAudioItem");
static_assert(sizeof(FActiveAudioItem) == 0x000010, "Wrong size on FActiveAudioItem");
static_assert(offsetof(FActiveAudioItem, Audio) == 0x000000, "Member 'FActiveAudioItem::Audio' has a wrong offset!");
static_assert(offsetof(FActiveAudioItem, FadeoutDuration) == 0x000008, "Member 'FActiveAudioItem::FadeoutDuration' has a wrong offset!");

// ScriptStruct FSD.SizeBoxSettings
// 0x0020 (0x0020 - 0x0000)
struct FSizeBoxSettings final
{
public:
	float                                         WidthOverride;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOverride;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredHeight;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDesiredWidth;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDesiredHeight;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAspectRatio;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAspectRatio;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSizeBoxSettings) == 0x000004, "Wrong alignment on FSizeBoxSettings");
static_assert(sizeof(FSizeBoxSettings) == 0x000020, "Wrong size on FSizeBoxSettings");
static_assert(offsetof(FSizeBoxSettings, WidthOverride) == 0x000000, "Member 'FSizeBoxSettings::WidthOverride' has a wrong offset!");
static_assert(offsetof(FSizeBoxSettings, HeightOverride) == 0x000004, "Member 'FSizeBoxSettings::HeightOverride' has a wrong offset!");
static_assert(offsetof(FSizeBoxSettings, MinDesiredWidth) == 0x000008, "Member 'FSizeBoxSettings::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(FSizeBoxSettings, MinDesiredHeight) == 0x00000C, "Member 'FSizeBoxSettings::MinDesiredHeight' has a wrong offset!");
static_assert(offsetof(FSizeBoxSettings, MaxDesiredWidth) == 0x000010, "Member 'FSizeBoxSettings::MaxDesiredWidth' has a wrong offset!");
static_assert(offsetof(FSizeBoxSettings, MaxDesiredHeight) == 0x000014, "Member 'FSizeBoxSettings::MaxDesiredHeight' has a wrong offset!");
static_assert(offsetof(FSizeBoxSettings, MinAspectRatio) == 0x000018, "Member 'FSizeBoxSettings::MinAspectRatio' has a wrong offset!");
static_assert(offsetof(FSizeBoxSettings, MaxAspectRatio) == 0x00001C, "Member 'FSizeBoxSettings::MaxAspectRatio' has a wrong offset!");

// ScriptStruct FSD.FloatPerkRank
// 0x0008 (0x0008 - 0x0000)
struct FFloatPerkRank final
{
public:
	int32                                         Tier;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatPerkRank) == 0x000004, "Wrong alignment on FFloatPerkRank");
static_assert(sizeof(FFloatPerkRank) == 0x000008, "Wrong size on FFloatPerkRank");
static_assert(offsetof(FFloatPerkRank, Tier) == 0x000000, "Member 'FFloatPerkRank::Tier' has a wrong offset!");
static_assert(offsetof(FFloatPerkRank, Cost) == 0x000004, "Member 'FFloatPerkRank::Cost' has a wrong offset!");

// ScriptStruct FSD.PendingRewardsStats
// 0x00B0 (0x00B0 - 0x0000)
struct FPendingRewardsStats final
{
public:
	TMap<class UResourceData*, float>             AllResources;                                      // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TMap<class UResourceData*, float>             CollectedResources;                                // 0x0050(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          PrimaryObjectiveCompleted;                         // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SecondaryObjectiveCompleted;                       // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174D[0x2];                                     // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimePlayed;                                        // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemiesKilled;                                     // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174E[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingRewardsStats) == 0x000008, "Wrong alignment on FPendingRewardsStats");
static_assert(sizeof(FPendingRewardsStats) == 0x0000B0, "Wrong size on FPendingRewardsStats");
static_assert(offsetof(FPendingRewardsStats, AllResources) == 0x000000, "Member 'FPendingRewardsStats::AllResources' has a wrong offset!");
static_assert(offsetof(FPendingRewardsStats, CollectedResources) == 0x000050, "Member 'FPendingRewardsStats::CollectedResources' has a wrong offset!");
static_assert(offsetof(FPendingRewardsStats, PrimaryObjectiveCompleted) == 0x0000A0, "Member 'FPendingRewardsStats::PrimaryObjectiveCompleted' has a wrong offset!");
static_assert(offsetof(FPendingRewardsStats, SecondaryObjectiveCompleted) == 0x0000A1, "Member 'FPendingRewardsStats::SecondaryObjectiveCompleted' has a wrong offset!");
static_assert(offsetof(FPendingRewardsStats, TimePlayed) == 0x0000A4, "Member 'FPendingRewardsStats::TimePlayed' has a wrong offset!");
static_assert(offsetof(FPendingRewardsStats, EnemiesKilled) == 0x0000A8, "Member 'FPendingRewardsStats::EnemiesKilled' has a wrong offset!");

// ScriptStruct FSD.TextCounterEntry
// 0x0028 (0x0028 - 0x0000)
struct FTextCounterEntry final
{
public:
	class UTextBlock*                             TextBlock;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Format;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174F[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextCounterEntry) == 0x000008, "Wrong alignment on FTextCounterEntry");
static_assert(sizeof(FTextCounterEntry) == 0x000028, "Wrong size on FTextCounterEntry");
static_assert(offsetof(FTextCounterEntry, TextBlock) == 0x000000, "Member 'FTextCounterEntry::TextBlock' has a wrong offset!");
static_assert(offsetof(FTextCounterEntry, Format) == 0x000008, "Member 'FTextCounterEntry::Format' has a wrong offset!");
static_assert(offsetof(FTextCounterEntry, Value) == 0x000020, "Member 'FTextCounterEntry::Value' has a wrong offset!");

// ScriptStruct FSD.BarleySpawnItem
// 0x0010 (0x0010 - 0x0000)
struct FBarleySpawnItem final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1750[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBarleySpawnItem) == 0x000008, "Wrong alignment on FBarleySpawnItem");
static_assert(sizeof(FBarleySpawnItem) == 0x000010, "Wrong size on FBarleySpawnItem");
static_assert(offsetof(FBarleySpawnItem, Resource) == 0x000000, "Member 'FBarleySpawnItem::Resource' has a wrong offset!");
static_assert(offsetof(FBarleySpawnItem, Weight) == 0x000008, "Member 'FBarleySpawnItem::Weight' has a wrong offset!");

// ScriptStruct FSD.GameActivitySubTask
// 0x0010 (0x0010 - 0x0000)
struct FGameActivitySubTask final
{
public:
	class FString                                 SubActivityId;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameActivitySubTask) == 0x000008, "Wrong alignment on FGameActivitySubTask");
static_assert(sizeof(FGameActivitySubTask) == 0x000010, "Wrong size on FGameActivitySubTask");
static_assert(offsetof(FGameActivitySubTask, SubActivityId) == 0x000000, "Member 'FGameActivitySubTask::SubActivityId' has a wrong offset!");

// ScriptStruct FSD.OverlapPair
// 0x0010 (0x0010 - 0x0000)
struct FOverlapPair final
{
public:
	class APlayerCharacter*                       Player;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Overlap;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverlapPair) == 0x000008, "Wrong alignment on FOverlapPair");
static_assert(sizeof(FOverlapPair) == 0x000010, "Wrong size on FOverlapPair");
static_assert(offsetof(FOverlapPair, Player) == 0x000000, "Member 'FOverlapPair::Player' has a wrong offset!");
static_assert(offsetof(FOverlapPair, Overlap) == 0x000008, "Member 'FOverlapPair::Overlap' has a wrong offset!");

// ScriptStruct FSD.AttachMeshesAfflictionItem
// 0x0040 (0x0040 - 0x0000)
struct FAttachMeshesAfflictionItem final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1751[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Animation;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshAttachType                               AttachType;                                        // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoopAnimation;                                     // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomRotaiton;                                    // 0x0036(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomScale;                                       // 0x0037(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadows;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1752[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttachMeshesAfflictionItem) == 0x000008, "Wrong alignment on FAttachMeshesAfflictionItem");
static_assert(sizeof(FAttachMeshesAfflictionItem) == 0x000040, "Wrong size on FAttachMeshesAfflictionItem");
static_assert(offsetof(FAttachMeshesAfflictionItem, Offset) == 0x000000, "Member 'FAttachMeshesAfflictionItem::Offset' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, SkeletalMesh) == 0x000010, "Member 'FAttachMeshesAfflictionItem::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, StaticMesh) == 0x000018, "Member 'FAttachMeshesAfflictionItem::StaticMesh' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, Animation) == 0x000020, "Member 'FAttachMeshesAfflictionItem::Animation' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, Scale) == 0x000028, "Member 'FAttachMeshesAfflictionItem::Scale' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, BoneName) == 0x00002C, "Member 'FAttachMeshesAfflictionItem::BoneName' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, AttachType) == 0x000034, "Member 'FAttachMeshesAfflictionItem::AttachType' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, LoopAnimation) == 0x000035, "Member 'FAttachMeshesAfflictionItem::LoopAnimation' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, RandomRotaiton) == 0x000036, "Member 'FAttachMeshesAfflictionItem::RandomRotaiton' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, RandomScale) == 0x000037, "Member 'FAttachMeshesAfflictionItem::RandomScale' has a wrong offset!");
static_assert(offsetof(FAttachMeshesAfflictionItem, CastShadows) == 0x000038, "Member 'FAttachMeshesAfflictionItem::CastShadows' has a wrong offset!");

// ScriptStruct FSD.ScaledMeshAfflictionTypeItem
// 0x0058 (0x0058 - 0x0000)
struct FScaledMeshAfflictionTypeItem final
{
public:
	TArray<struct FRuntimeFloatCurve>             Scalers;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    Meshes;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRandRange                             ScaleDelay;                                        // 0x0020(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class USoundCue*                              StartingSound;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EndSound;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFXSystemAsset*>                 StartParticles;                                    // 0x0038(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFXSystemAsset*>                 EndParticles;                                      // 0x0048(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FScaledMeshAfflictionTypeItem) == 0x000008, "Wrong alignment on FScaledMeshAfflictionTypeItem");
static_assert(sizeof(FScaledMeshAfflictionTypeItem) == 0x000058, "Wrong size on FScaledMeshAfflictionTypeItem");
static_assert(offsetof(FScaledMeshAfflictionTypeItem, Scalers) == 0x000000, "Member 'FScaledMeshAfflictionTypeItem::Scalers' has a wrong offset!");
static_assert(offsetof(FScaledMeshAfflictionTypeItem, Meshes) == 0x000010, "Member 'FScaledMeshAfflictionTypeItem::Meshes' has a wrong offset!");
static_assert(offsetof(FScaledMeshAfflictionTypeItem, ScaleDelay) == 0x000020, "Member 'FScaledMeshAfflictionTypeItem::ScaleDelay' has a wrong offset!");
static_assert(offsetof(FScaledMeshAfflictionTypeItem, StartingSound) == 0x000028, "Member 'FScaledMeshAfflictionTypeItem::StartingSound' has a wrong offset!");
static_assert(offsetof(FScaledMeshAfflictionTypeItem, EndSound) == 0x000030, "Member 'FScaledMeshAfflictionTypeItem::EndSound' has a wrong offset!");
static_assert(offsetof(FScaledMeshAfflictionTypeItem, StartParticles) == 0x000038, "Member 'FScaledMeshAfflictionTypeItem::StartParticles' has a wrong offset!");
static_assert(offsetof(FScaledMeshAfflictionTypeItem, EndParticles) == 0x000048, "Member 'FScaledMeshAfflictionTypeItem::EndParticles' has a wrong offset!");

// ScriptStruct FSD.CompositeArmorItem
// 0x0010 (0x0010 - 0x0000)
struct FCompositeArmorItem final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideAffectedByArmorBreak;                      // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MyAffectedByAmorBreak;                             // 0x000D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1753[0x2];                                     // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompositeArmorItem) == 0x000008, "Wrong alignment on FCompositeArmorItem");
static_assert(sizeof(FCompositeArmorItem) == 0x000010, "Wrong size on FCompositeArmorItem");
static_assert(offsetof(FCompositeArmorItem, Component) == 0x000000, "Member 'FCompositeArmorItem::Component' has a wrong offset!");
static_assert(offsetof(FCompositeArmorItem, Health) == 0x000008, "Member 'FCompositeArmorItem::Health' has a wrong offset!");
static_assert(offsetof(FCompositeArmorItem, OverrideAffectedByArmorBreak) == 0x00000C, "Member 'FCompositeArmorItem::OverrideAffectedByArmorBreak' has a wrong offset!");
static_assert(offsetof(FCompositeArmorItem, MyAffectedByAmorBreak) == 0x00000D, "Member 'FCompositeArmorItem::MyAffectedByAmorBreak' has a wrong offset!");

// ScriptStruct FSD.DestructableBodypartItem
// 0x0018 (0x0018 - 0x0000)
struct FDestructableBodypartItem final
{
public:
	uint8                                         MaterialIndex;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1754[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ArmorBones;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructableBodypartItem) == 0x000008, "Wrong alignment on FDestructableBodypartItem");
static_assert(sizeof(FDestructableBodypartItem) == 0x000018, "Wrong size on FDestructableBodypartItem");
static_assert(offsetof(FDestructableBodypartItem, MaterialIndex) == 0x000000, "Member 'FDestructableBodypartItem::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FDestructableBodypartItem, ArmorBones) == 0x000008, "Member 'FDestructableBodypartItem::ArmorBones' has a wrong offset!");

// ScriptStruct FSD.ArmorDamageInfo
// 0x0008 (0x0008 - 0x0000)
struct FArmorDamageInfo final
{
public:
	int32                                         ArmorIndexMask;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArmorDamageType                              BreakType;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1755[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmorDamageInfo) == 0x000004, "Wrong alignment on FArmorDamageInfo");
static_assert(sizeof(FArmorDamageInfo) == 0x000008, "Wrong size on FArmorDamageInfo");
static_assert(offsetof(FArmorDamageInfo, ArmorIndexMask) == 0x000000, "Member 'FArmorDamageInfo::ArmorIndexMask' has a wrong offset!");
static_assert(offsetof(FArmorDamageInfo, BreakType) == 0x000004, "Member 'FArmorDamageInfo::BreakType' has a wrong offset!");

// ScriptStruct FSD.ArmorDamageEffects
// 0x0030 (0x0030 - 0x0000)
struct FArmorDamageEffects final
{
public:
	TArray<class UFXSystemAsset*>                 ArmorBreakParticles;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFXSystemAsset*>                 DissolveParticles;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFXSystemAsset*>                 BeamParticles;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorDamageEffects) == 0x000008, "Wrong alignment on FArmorDamageEffects");
static_assert(sizeof(FArmorDamageEffects) == 0x000030, "Wrong size on FArmorDamageEffects");
static_assert(offsetof(FArmorDamageEffects, ArmorBreakParticles) == 0x000000, "Member 'FArmorDamageEffects::ArmorBreakParticles' has a wrong offset!");
static_assert(offsetof(FArmorDamageEffects, DissolveParticles) == 0x000010, "Member 'FArmorDamageEffects::DissolveParticles' has a wrong offset!");
static_assert(offsetof(FArmorDamageEffects, BeamParticles) == 0x000020, "Member 'FArmorDamageEffects::BeamParticles' has a wrong offset!");

// ScriptStruct FSD.AttackCooldown
// 0x0010 (0x0010 - 0x0000)
struct FAttackCooldown final
{
public:
	class FName                                   AttackName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolDown;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1756[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackCooldown) == 0x000004, "Wrong alignment on FAttackCooldown");
static_assert(sizeof(FAttackCooldown) == 0x000010, "Wrong size on FAttackCooldown");
static_assert(offsetof(FAttackCooldown, AttackName) == 0x000000, "Member 'FAttackCooldown::AttackName' has a wrong offset!");
static_assert(offsetof(FAttackCooldown, CoolDown) == 0x000008, "Member 'FAttackCooldown::CoolDown' has a wrong offset!");

// ScriptStruct FSD.AttackerInfo
// 0x0010 (0x0010 - 0x0000)
struct FAttackerInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Attacker;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PositionIndex;                                     // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackerRadius;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackerInfo) == 0x000004, "Wrong alignment on FAttackerInfo");
static_assert(sizeof(FAttackerInfo) == 0x000010, "Wrong size on FAttackerInfo");
static_assert(offsetof(FAttackerInfo, Attacker) == 0x000000, "Member 'FAttackerInfo::Attacker' has a wrong offset!");
static_assert(offsetof(FAttackerInfo, PositionIndex) == 0x000008, "Member 'FAttackerInfo::PositionIndex' has a wrong offset!");
static_assert(offsetof(FAttackerInfo, AttackerRadius) == 0x00000C, "Member 'FAttackerInfo::AttackerRadius' has a wrong offset!");

// ScriptStruct FSD.BEETemplateItem
// 0x0028 (0x0028 - 0x0000)
struct FBEETemplateItem final
{
public:
	class UMissionTemplate*                       Mission;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMissionDuration*>               AllowedDurations;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMissionComplexity*>             AllowedComplexities;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBEETemplateItem) == 0x000008, "Wrong alignment on FBEETemplateItem");
static_assert(sizeof(FBEETemplateItem) == 0x000028, "Wrong size on FBEETemplateItem");
static_assert(offsetof(FBEETemplateItem, Mission) == 0x000000, "Member 'FBEETemplateItem::Mission' has a wrong offset!");
static_assert(offsetof(FBEETemplateItem, AllowedDurations) == 0x000008, "Member 'FBEETemplateItem::AllowedDurations' has a wrong offset!");
static_assert(offsetof(FBEETemplateItem, AllowedComplexities) == 0x000018, "Member 'FBEETemplateItem::AllowedComplexities' has a wrong offset!");

// ScriptStruct FSD.BEELoaderSequence
// 0x0028 (0x0028 - 0x0000)
struct FBEELoaderSequence final
{
public:
	TSoftObjectPtr<class ULevelSequence>          LevelSequence;                                     // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBEELoaderSequence) == 0x000008, "Wrong alignment on FBEELoaderSequence");
static_assert(sizeof(FBEELoaderSequence) == 0x000028, "Wrong size on FBEELoaderSequence");
static_assert(offsetof(FBEELoaderSequence, LevelSequence) == 0x000000, "Member 'FBEELoaderSequence::LevelSequence' has a wrong offset!");

// ScriptStruct FSD.BiomeNoiseItem
// 0x0038 (0x0038 - 0x0000)
struct FBiomeNoiseItem final
{
public:
	class UFloodFillSettings*                     CeilingNoise;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDetailNoise*                           CeilingDetailNoise;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloodFillSettings*                     WallNoise;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDetailNoise*                           WallDetailNoise;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloodFillSettings*                     FloorNoise;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDetailNoise*                           FloorDetailNoise;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1757[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBiomeNoiseItem) == 0x000008, "Wrong alignment on FBiomeNoiseItem");
static_assert(sizeof(FBiomeNoiseItem) == 0x000038, "Wrong size on FBiomeNoiseItem");
static_assert(offsetof(FBiomeNoiseItem, CeilingNoise) == 0x000000, "Member 'FBiomeNoiseItem::CeilingNoise' has a wrong offset!");
static_assert(offsetof(FBiomeNoiseItem, CeilingDetailNoise) == 0x000008, "Member 'FBiomeNoiseItem::CeilingDetailNoise' has a wrong offset!");
static_assert(offsetof(FBiomeNoiseItem, WallNoise) == 0x000010, "Member 'FBiomeNoiseItem::WallNoise' has a wrong offset!");
static_assert(offsetof(FBiomeNoiseItem, WallDetailNoise) == 0x000018, "Member 'FBiomeNoiseItem::WallDetailNoise' has a wrong offset!");
static_assert(offsetof(FBiomeNoiseItem, FloorNoise) == 0x000020, "Member 'FBiomeNoiseItem::FloorNoise' has a wrong offset!");
static_assert(offsetof(FBiomeNoiseItem, FloorDetailNoise) == 0x000028, "Member 'FBiomeNoiseItem::FloorDetailNoise' has a wrong offset!");
static_assert(offsetof(FBiomeNoiseItem, Weight) == 0x000030, "Member 'FBiomeNoiseItem::Weight' has a wrong offset!");

// ScriptStruct FSD.BoscoLightSetting
// 0x000C (0x000C - 0x0000)
struct FBoscoLightSetting final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoscoLightSetting) == 0x000004, "Wrong alignment on FBoscoLightSetting");
static_assert(sizeof(FBoscoLightSetting) == 0x00000C, "Wrong size on FBoscoLightSetting");
static_assert(offsetof(FBoscoLightSetting, Color) == 0x000000, "Member 'FBoscoLightSetting::Color' has a wrong offset!");
static_assert(offsetof(FBoscoLightSetting, Intensity) == 0x000004, "Member 'FBoscoLightSetting::Intensity' has a wrong offset!");
static_assert(offsetof(FBoscoLightSetting, Radius) == 0x000008, "Member 'FBoscoLightSetting::Radius' has a wrong offset!");

// ScriptStruct FSD.BossFight
// 0x0018 (0x0018 - 0x0000)
struct FBossFight final
{
public:
	TWeakObjectPtr<class AActor>                  BossActor;                                         // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UEnemyComponent>         EnemyComponent;                                    // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UEnemyHealthComponent>   HealthComponent;                                   // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBossFight) == 0x000004, "Wrong alignment on FBossFight");
static_assert(sizeof(FBossFight) == 0x000018, "Wrong size on FBossFight");
static_assert(offsetof(FBossFight, BossActor) == 0x000000, "Member 'FBossFight::BossActor' has a wrong offset!");
static_assert(offsetof(FBossFight, EnemyComponent) == 0x000008, "Member 'FBossFight::EnemyComponent' has a wrong offset!");
static_assert(offsetof(FBossFight, HealthComponent) == 0x000010, "Member 'FBossFight::HealthComponent' has a wrong offset!");

// ScriptStruct FSD.BoomerangMover
// 0x0060 (0x0060 - 0x0000)
struct FBoomerangMover final
{
public:
	struct FRotator                               StartRotation;                                     // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PrevPos;                                           // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextPos;                                           // 0x0018(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0024(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScale;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickRate;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickTime;                                          // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSmoothTime;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1758[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           ArcCurve;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGoingBack;                                       // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1759[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoomerangMover) == 0x000008, "Wrong alignment on FBoomerangMover");
static_assert(sizeof(FBoomerangMover) == 0x000060, "Wrong size on FBoomerangMover");
static_assert(offsetof(FBoomerangMover, StartRotation) == 0x000000, "Member 'FBoomerangMover::StartRotation' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, PrevPos) == 0x00000C, "Member 'FBoomerangMover::PrevPos' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, NextPos) == 0x000018, "Member 'FBoomerangMover::NextPos' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, Velocity) == 0x000024, "Member 'FBoomerangMover::Velocity' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, Speed) == 0x000030, "Member 'FBoomerangMover::Speed' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, TimeScale) == 0x000034, "Member 'FBoomerangMover::TimeScale' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, TickRate) == 0x000038, "Member 'FBoomerangMover::TickRate' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, TickTime) == 0x00003C, "Member 'FBoomerangMover::TickTime' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, AccumulatedTime) == 0x000040, "Member 'FBoomerangMover::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, TotalTime) == 0x000044, "Member 'FBoomerangMover::TotalTime' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, StartSmoothTime) == 0x000048, "Member 'FBoomerangMover::StartSmoothTime' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, ArcCurve) == 0x000050, "Member 'FBoomerangMover::ArcCurve' has a wrong offset!");
static_assert(offsetof(FBoomerangMover, IsGoingBack) == 0x000058, "Member 'FBoomerangMover::IsGoingBack' has a wrong offset!");

// ScriptStruct FSD.BoomerangSyncer
// 0x002C (0x002C - 0x0000)
struct FBoomerangSyncer final
{
public:
	struct FVector                                PrevPos;                                           // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextPos;                                           // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0018(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGoingBack;                                       // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175A[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalTime;                                         // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoomerangSyncer) == 0x000004, "Wrong alignment on FBoomerangSyncer");
static_assert(sizeof(FBoomerangSyncer) == 0x00002C, "Wrong size on FBoomerangSyncer");
static_assert(offsetof(FBoomerangSyncer, PrevPos) == 0x000000, "Member 'FBoomerangSyncer::PrevPos' has a wrong offset!");
static_assert(offsetof(FBoomerangSyncer, NextPos) == 0x00000C, "Member 'FBoomerangSyncer::NextPos' has a wrong offset!");
static_assert(offsetof(FBoomerangSyncer, Velocity) == 0x000018, "Member 'FBoomerangSyncer::Velocity' has a wrong offset!");
static_assert(offsetof(FBoomerangSyncer, IsGoingBack) == 0x000024, "Member 'FBoomerangSyncer::IsGoingBack' has a wrong offset!");
static_assert(offsetof(FBoomerangSyncer, TotalTime) == 0x000028, "Member 'FBoomerangSyncer::TotalTime' has a wrong offset!");

// ScriptStruct FSD.LevelGenerationCarver
// 0x0080 (0x0080 - 0x0000)
struct FLevelGenerationCarver final
{
public:
	struct FMatrixWithExactSync                   Transform;                                         // 0x0000(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	class USTLMeshCarver*                         MeshCarver;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ConvexCarver;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshCarver*                      StaticMeshCarver;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConvexExpensiveNoise;                              // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175B[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelGenerationCarverComponent*        Componenet;                                        // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECarveOptionsCellSize                         CarveCellSize;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175C[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTerrainMaterial*                       TerrainMaterial;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECarveFilterType                              Filter;                                            // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ToBeDiscarded;                                     // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175D[0x6];                                     // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelGenerationCarver) == 0x000008, "Wrong alignment on FLevelGenerationCarver");
static_assert(sizeof(FLevelGenerationCarver) == 0x000080, "Wrong size on FLevelGenerationCarver");
static_assert(offsetof(FLevelGenerationCarver, Transform) == 0x000000, "Member 'FLevelGenerationCarver::Transform' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, MeshCarver) == 0x000040, "Member 'FLevelGenerationCarver::MeshCarver' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, ConvexCarver) == 0x000048, "Member 'FLevelGenerationCarver::ConvexCarver' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, StaticMeshCarver) == 0x000050, "Member 'FLevelGenerationCarver::StaticMeshCarver' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, ConvexExpensiveNoise) == 0x000058, "Member 'FLevelGenerationCarver::ConvexExpensiveNoise' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, Componenet) == 0x000060, "Member 'FLevelGenerationCarver::Componenet' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, CarveCellSize) == 0x000068, "Member 'FLevelGenerationCarver::CarveCellSize' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, TerrainMaterial) == 0x000070, "Member 'FLevelGenerationCarver::TerrainMaterial' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, Filter) == 0x000078, "Member 'FLevelGenerationCarver::Filter' has a wrong offset!");
static_assert(offsetof(FLevelGenerationCarver, ToBeDiscarded) == 0x000079, "Member 'FLevelGenerationCarver::ToBeDiscarded' has a wrong offset!");

// ScriptStruct FSD.CaveInfluence
// 0x0010 (0x0010 - 0x0000)
struct FCaveInfluence final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCaveInfluence) == 0x000004, "Wrong alignment on FCaveInfluence");
static_assert(sizeof(FCaveInfluence) == 0x000010, "Wrong size on FCaveInfluence");
static_assert(offsetof(FCaveInfluence, Center) == 0x000000, "Member 'FCaveInfluence::Center' has a wrong offset!");
static_assert(offsetof(FCaveInfluence, Range) == 0x00000C, "Member 'FCaveInfluence::Range' has a wrong offset!");

// ScriptStruct FSD.CustomUsable
// 0x0010 (0x0010 - 0x0000)
struct FCustomUsable final
{
public:
	class UUsableComponentBase*                   Usable;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomUsableType                             TerminationType;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175E[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomUsable) == 0x000008, "Wrong alignment on FCustomUsable");
static_assert(sizeof(FCustomUsable) == 0x000010, "Wrong size on FCustomUsable");
static_assert(offsetof(FCustomUsable, Usable) == 0x000000, "Member 'FCustomUsable::Usable' has a wrong offset!");
static_assert(offsetof(FCustomUsable, TerminationType) == 0x000008, "Member 'FCustomUsable::TerminationType' has a wrong offset!");

// ScriptStruct FSD.FSDServerListEntryModModel
// 0x0028 (0x0028 - 0x0000)
struct FFSDServerListEntryModModel final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Category;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175F[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Version;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDServerListEntryModModel) == 0x000008, "Wrong alignment on FFSDServerListEntryModModel");
static_assert(sizeof(FFSDServerListEntryModModel) == 0x000028, "Wrong size on FFSDServerListEntryModModel");
static_assert(offsetof(FFSDServerListEntryModModel, Name) == 0x000000, "Member 'FFSDServerListEntryModModel::Name' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModModel, Category) == 0x000010, "Member 'FFSDServerListEntryModModel::Category' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModModel, Version) == 0x000018, "Member 'FFSDServerListEntryModModel::Version' has a wrong offset!");

// ScriptStruct FSD.CharacterUseState
// 0x0010 (0x0010 - 0x0000)
struct FCharacterUseState final
{
public:
	class UUsableComponentBase*                   ActiveUsable;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputKeys                                    Key;                                               // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1760[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseId;                                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterUseState) == 0x000008, "Wrong alignment on FCharacterUseState");
static_assert(sizeof(FCharacterUseState) == 0x000010, "Wrong size on FCharacterUseState");
static_assert(offsetof(FCharacterUseState, ActiveUsable) == 0x000000, "Member 'FCharacterUseState::ActiveUsable' has a wrong offset!");
static_assert(offsetof(FCharacterUseState, Key) == 0x000008, "Member 'FCharacterUseState::Key' has a wrong offset!");
static_assert(offsetof(FCharacterUseState, UseId) == 0x00000C, "Member 'FCharacterUseState::UseId' has a wrong offset!");

// ScriptStruct FSD.SeasonalEventEntryChance
// 0x0030 (0x0030 - 0x0000)
struct FSeasonalEventEntryChance final
{
public:
	class USpecialEvent*                          SpecialEvent;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnChance;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1761[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMissionTemplate*>               BannedMissions;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMutator*>                       BannedMutators;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonalEventEntryChance) == 0x000008, "Wrong alignment on FSeasonalEventEntryChance");
static_assert(sizeof(FSeasonalEventEntryChance) == 0x000030, "Wrong size on FSeasonalEventEntryChance");
static_assert(offsetof(FSeasonalEventEntryChance, SpecialEvent) == 0x000000, "Member 'FSeasonalEventEntryChance::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FSeasonalEventEntryChance, SpawnChance) == 0x000008, "Member 'FSeasonalEventEntryChance::SpawnChance' has a wrong offset!");
static_assert(offsetof(FSeasonalEventEntryChance, BannedMissions) == 0x000010, "Member 'FSeasonalEventEntryChance::BannedMissions' has a wrong offset!");
static_assert(offsetof(FSeasonalEventEntryChance, BannedMutators) == 0x000020, "Member 'FSeasonalEventEntryChance::BannedMutators' has a wrong offset!");

// ScriptStruct FSD.CloudSaveRequest
// 0x0048 (0x0048 - 0x0000)
struct FCloudSaveRequest final
{
public:
	class FString                                 SteamTicket;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSTicket;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRank;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveToDiskCounter;                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RawData;                                           // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Branch;                                            // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudSaveRequest) == 0x000008, "Wrong alignment on FCloudSaveRequest");
static_assert(sizeof(FCloudSaveRequest) == 0x000048, "Wrong size on FCloudSaveRequest");
static_assert(offsetof(FCloudSaveRequest, SteamTicket) == 0x000000, "Member 'FCloudSaveRequest::SteamTicket' has a wrong offset!");
static_assert(offsetof(FCloudSaveRequest, PSTicket) == 0x000010, "Member 'FCloudSaveRequest::PSTicket' has a wrong offset!");
static_assert(offsetof(FCloudSaveRequest, PlayerRank) == 0x000020, "Member 'FCloudSaveRequest::PlayerRank' has a wrong offset!");
static_assert(offsetof(FCloudSaveRequest, SaveToDiskCounter) == 0x000024, "Member 'FCloudSaveRequest::SaveToDiskCounter' has a wrong offset!");
static_assert(offsetof(FCloudSaveRequest, RawData) == 0x000028, "Member 'FCloudSaveRequest::RawData' has a wrong offset!");
static_assert(offsetof(FCloudSaveRequest, Branch) == 0x000038, "Member 'FCloudSaveRequest::Branch' has a wrong offset!");

// ScriptStruct FSD.CloudLoadEntry
// 0x0020 (0x0020 - 0x0000)
struct FCloudLoadEntry final
{
public:
	class FString                                 RawData;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeUTC;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudLoadEntry) == 0x000008, "Wrong alignment on FCloudLoadEntry");
static_assert(sizeof(FCloudLoadEntry) == 0x000020, "Wrong size on FCloudLoadEntry");
static_assert(offsetof(FCloudLoadEntry, RawData) == 0x000000, "Member 'FCloudLoadEntry::RawData' has a wrong offset!");
static_assert(offsetof(FCloudLoadEntry, TimeUTC) == 0x000010, "Member 'FCloudLoadEntry::TimeUTC' has a wrong offset!");

// ScriptStruct FSD.CloudLoadAllResponse
// 0x0010 (0x0010 - 0x0000)
struct FCloudLoadAllResponse final
{
public:
	TArray<struct FCloudLoadEntry>                Savegames;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudLoadAllResponse) == 0x000008, "Wrong alignment on FCloudLoadAllResponse");
static_assert(sizeof(FCloudLoadAllResponse) == 0x000010, "Wrong size on FCloudLoadAllResponse");
static_assert(offsetof(FCloudLoadAllResponse, Savegames) == 0x000000, "Member 'FCloudLoadAllResponse::Savegames' has a wrong offset!");

// ScriptStruct FSD.CloudLoadRequest
// 0x0038 (0x0038 - 0x0000)
struct FCloudLoadRequest final
{
public:
	class FString                                 SteamTicket;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSTicket;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Branch;                                            // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offset;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1762[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCloudLoadRequest) == 0x000008, "Wrong alignment on FCloudLoadRequest");
static_assert(sizeof(FCloudLoadRequest) == 0x000038, "Wrong size on FCloudLoadRequest");
static_assert(offsetof(FCloudLoadRequest, SteamTicket) == 0x000000, "Member 'FCloudLoadRequest::SteamTicket' has a wrong offset!");
static_assert(offsetof(FCloudLoadRequest, PSTicket) == 0x000010, "Member 'FCloudLoadRequest::PSTicket' has a wrong offset!");
static_assert(offsetof(FCloudLoadRequest, Branch) == 0x000020, "Member 'FCloudLoadRequest::Branch' has a wrong offset!");
static_assert(offsetof(FCloudLoadRequest, Offset) == 0x000030, "Member 'FCloudLoadRequest::Offset' has a wrong offset!");

// ScriptStruct FSD.FSDServerListEntryModel
// 0x00D8 (0x00D8 - 0x0000)
struct FFSDServerListEntryModel final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DRG_SERVERNAME;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DRG_SERVERNAME_SAN;                                // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_GLOBALMISSION_SEED;                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_MISSION_SEED;                                  // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_DIFF;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_GAMESTATE;                                     // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_PWREQUIRED;                                    // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_PRIVATE;                                       // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_NUMPLAYERS;                                    // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1763[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DRG_CLASSES;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_CLASSLOCK;                                     // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_FULL;                                          // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DRG_REGION;                                        // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DRG_START;                                         // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_VERSION;                                       // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1764[0x4];                                     // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HostUserID;                                        // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DRG_MISSIONSTRUCTURE;                              // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 P2PAddr;                                           // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P2PPORT;                                           // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFSDServerListEntryModModel>    Mods;                                              // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDServerListEntryModel) == 0x000008, "Wrong alignment on FFSDServerListEntryModel");
static_assert(sizeof(FFSDServerListEntryModel) == 0x0000D8, "Wrong size on FFSDServerListEntryModel");
static_assert(offsetof(FFSDServerListEntryModel, ID) == 0x000000, "Member 'FFSDServerListEntryModel::ID' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_SERVERNAME) == 0x000010, "Member 'FFSDServerListEntryModel::DRG_SERVERNAME' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_SERVERNAME_SAN) == 0x000020, "Member 'FFSDServerListEntryModel::DRG_SERVERNAME_SAN' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_GLOBALMISSION_SEED) == 0x000030, "Member 'FFSDServerListEntryModel::DRG_GLOBALMISSION_SEED' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_MISSION_SEED) == 0x000034, "Member 'FFSDServerListEntryModel::DRG_MISSION_SEED' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_DIFF) == 0x000038, "Member 'FFSDServerListEntryModel::DRG_DIFF' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_GAMESTATE) == 0x00003C, "Member 'FFSDServerListEntryModel::DRG_GAMESTATE' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_PWREQUIRED) == 0x000040, "Member 'FFSDServerListEntryModel::DRG_PWREQUIRED' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_PRIVATE) == 0x000044, "Member 'FFSDServerListEntryModel::DRG_PRIVATE' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_NUMPLAYERS) == 0x000048, "Member 'FFSDServerListEntryModel::DRG_NUMPLAYERS' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_CLASSES) == 0x000050, "Member 'FFSDServerListEntryModel::DRG_CLASSES' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_CLASSLOCK) == 0x000060, "Member 'FFSDServerListEntryModel::DRG_CLASSLOCK' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_FULL) == 0x000064, "Member 'FFSDServerListEntryModel::DRG_FULL' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_REGION) == 0x000068, "Member 'FFSDServerListEntryModel::DRG_REGION' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_START) == 0x000078, "Member 'FFSDServerListEntryModel::DRG_START' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_VERSION) == 0x000088, "Member 'FFSDServerListEntryModel::DRG_VERSION' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, HostUserID) == 0x000090, "Member 'FFSDServerListEntryModel::HostUserID' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, DRG_MISSIONSTRUCTURE) == 0x0000A0, "Member 'FFSDServerListEntryModel::DRG_MISSIONSTRUCTURE' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, P2PAddr) == 0x0000B0, "Member 'FFSDServerListEntryModel::P2PAddr' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, P2PPORT) == 0x0000C0, "Member 'FFSDServerListEntryModel::P2PPORT' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, Distance) == 0x0000C4, "Member 'FFSDServerListEntryModel::Distance' has a wrong offset!");
static_assert(offsetof(FFSDServerListEntryModel, Mods) == 0x0000C8, "Member 'FFSDServerListEntryModel::Mods' has a wrong offset!");

// ScriptStruct FSD.FSDServerListResponse
// 0x0010 (0x0010 - 0x0000)
struct FFSDServerListResponse final
{
public:
	TArray<struct FFSDServerListEntryModel>       Lobbies;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDServerListResponse) == 0x000008, "Wrong alignment on FFSDServerListResponse");
static_assert(sizeof(FFSDServerListResponse) == 0x000010, "Wrong size on FFSDServerListResponse");
static_assert(offsetof(FFSDServerListResponse, Lobbies) == 0x000000, "Member 'FFSDServerListResponse::Lobbies' has a wrong offset!");

// ScriptStruct FSD.ExampleStruct
// 0x0004 (0x0004 - 0x0000)
struct FExampleStruct final
{
public:
	float                                         Field;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExampleStruct) == 0x000004, "Wrong alignment on FExampleStruct");
static_assert(sizeof(FExampleStruct) == 0x000004, "Wrong size on FExampleStruct");
static_assert(offsetof(FExampleStruct, Field) == 0x000000, "Member 'FExampleStruct::Field' has a wrong offset!");

// ScriptStruct FSD.CoilgunCoil
// 0x0008 (0x0008 - 0x0000)
struct FCoilgunCoil final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoilgunCoil) == 0x000004, "Wrong alignment on FCoilgunCoil");
static_assert(sizeof(FCoilgunCoil) == 0x000008, "Wrong size on FCoilgunCoil");
static_assert(offsetof(FCoilgunCoil, Angle) == 0x000000, "Member 'FCoilgunCoil::Angle' has a wrong offset!");
static_assert(offsetof(FCoilgunCoil, Speed) == 0x000004, "Member 'FCoilgunCoil::Speed' has a wrong offset!");

// ScriptStruct FSD.CoilgunAfflictionEntry
// 0x0020 (0x0020 - 0x0000)
struct FCoilgunAfflictionEntry final
{
public:
	TArray<TSubclassOf<class UStatusEffect>>      PushedAfflictions;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	class UStatusEffectsComponent*                Target;                                            // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1765[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoilgunAfflictionEntry) == 0x000008, "Wrong alignment on FCoilgunAfflictionEntry");
static_assert(sizeof(FCoilgunAfflictionEntry) == 0x000020, "Wrong size on FCoilgunAfflictionEntry");
static_assert(offsetof(FCoilgunAfflictionEntry, PushedAfflictions) == 0x000000, "Member 'FCoilgunAfflictionEntry::PushedAfflictions' has a wrong offset!");
static_assert(offsetof(FCoilgunAfflictionEntry, Target) == 0x000010, "Member 'FCoilgunAfflictionEntry::Target' has a wrong offset!");

// ScriptStruct FSD.EliteEnemyEntry
// 0x0040 (0x0040 - 0x0000)
struct FEliteEnemyEntry final
{
public:
	float                                         HeroChance;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1766[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              StatusEffect;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UActorComponent>>    ComponentsToAdd;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          OverrideHealthScaling;                             // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1767[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEliteEnemyBan>                 Bans;                                              // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EEnemyHealthScaling                           HealthScalingOverride;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1768[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEliteEnemyEntry) == 0x000008, "Wrong alignment on FEliteEnemyEntry");
static_assert(sizeof(FEliteEnemyEntry) == 0x000040, "Wrong size on FEliteEnemyEntry");
static_assert(offsetof(FEliteEnemyEntry, HeroChance) == 0x000000, "Member 'FEliteEnemyEntry::HeroChance' has a wrong offset!");
static_assert(offsetof(FEliteEnemyEntry, StatusEffect) == 0x000008, "Member 'FEliteEnemyEntry::StatusEffect' has a wrong offset!");
static_assert(offsetof(FEliteEnemyEntry, ComponentsToAdd) == 0x000010, "Member 'FEliteEnemyEntry::ComponentsToAdd' has a wrong offset!");
static_assert(offsetof(FEliteEnemyEntry, OverrideHealthScaling) == 0x000020, "Member 'FEliteEnemyEntry::OverrideHealthScaling' has a wrong offset!");
static_assert(offsetof(FEliteEnemyEntry, Bans) == 0x000028, "Member 'FEliteEnemyEntry::Bans' has a wrong offset!");
static_assert(offsetof(FEliteEnemyEntry, HealthScalingOverride) == 0x000038, "Member 'FEliteEnemyEntry::HealthScalingOverride' has a wrong offset!");

// ScriptStruct FSD.CoilMaterial
// 0x0010 (0x0010 - 0x0000)
struct FCoilMaterial final
{
public:
	class UMaterialInstanceDynamic*               Material;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1769[0x8];                                     // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoilMaterial) == 0x000008, "Wrong alignment on FCoilMaterial");
static_assert(sizeof(FCoilMaterial) == 0x000010, "Wrong size on FCoilMaterial");
static_assert(offsetof(FCoilMaterial, Material) == 0x000000, "Member 'FCoilMaterial::Material' has a wrong offset!");

// ScriptStruct FSD.ShotMultiplier
// 0x000C (0x000C - 0x0000)
struct FShotMultiplier final
{
public:
	float                                         Undercharge;                                       // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Overcharge;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriBurst;                                          // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176A[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShotMultiplier) == 0x000004, "Wrong alignment on FShotMultiplier");
static_assert(sizeof(FShotMultiplier) == 0x00000C, "Wrong size on FShotMultiplier");
static_assert(offsetof(FShotMultiplier, Undercharge) == 0x000000, "Member 'FShotMultiplier::Undercharge' has a wrong offset!");
static_assert(offsetof(FShotMultiplier, Overcharge) == 0x000004, "Member 'FShotMultiplier::Overcharge' has a wrong offset!");
static_assert(offsetof(FShotMultiplier, TriBurst) == 0x000008, "Member 'FShotMultiplier::TriBurst' has a wrong offset!");

// ScriptStruct FSD.CharacterShouts
// 0x00D8 (0x00D8 - 0x0000)
struct FCharacterShouts final
{
public:
	class UDialogDataAsset*                       Attention;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Follow;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       StandingDown;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Downed;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       RequestRevive;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Revived;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Resupply;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       FriendlyFire;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       KillCry;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Dead;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Cheating;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       ResourceFull;                                      // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       ResourceFullNoDonkey;                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       CallDonkey;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       CallDonkey_NotInMission;                           // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Depositing;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DepositingNoDonkey;                                // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OutOfAmmo;                                         // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Reloading;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       CharacterSelected;                                 // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       UpgradeBought;                                     // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       WaitingInDropPod;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Carrying;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       WaitingInEscapePod;                                // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Salute;                                            // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Salute_Spacerig;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Drink;                                             // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterShouts) == 0x000008, "Wrong alignment on FCharacterShouts");
static_assert(sizeof(FCharacterShouts) == 0x0000D8, "Wrong size on FCharacterShouts");
static_assert(offsetof(FCharacterShouts, Attention) == 0x000000, "Member 'FCharacterShouts::Attention' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Follow) == 0x000008, "Member 'FCharacterShouts::Follow' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, StandingDown) == 0x000010, "Member 'FCharacterShouts::StandingDown' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Downed) == 0x000018, "Member 'FCharacterShouts::Downed' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, RequestRevive) == 0x000020, "Member 'FCharacterShouts::RequestRevive' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Revived) == 0x000028, "Member 'FCharacterShouts::Revived' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Resupply) == 0x000030, "Member 'FCharacterShouts::Resupply' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, FriendlyFire) == 0x000038, "Member 'FCharacterShouts::FriendlyFire' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, KillCry) == 0x000040, "Member 'FCharacterShouts::KillCry' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Dead) == 0x000048, "Member 'FCharacterShouts::Dead' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Cheating) == 0x000050, "Member 'FCharacterShouts::Cheating' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, ResourceFull) == 0x000058, "Member 'FCharacterShouts::ResourceFull' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, ResourceFullNoDonkey) == 0x000060, "Member 'FCharacterShouts::ResourceFullNoDonkey' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, CallDonkey) == 0x000068, "Member 'FCharacterShouts::CallDonkey' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, CallDonkey_NotInMission) == 0x000070, "Member 'FCharacterShouts::CallDonkey_NotInMission' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Depositing) == 0x000078, "Member 'FCharacterShouts::Depositing' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, DepositingNoDonkey) == 0x000080, "Member 'FCharacterShouts::DepositingNoDonkey' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, OutOfAmmo) == 0x000088, "Member 'FCharacterShouts::OutOfAmmo' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Reloading) == 0x000090, "Member 'FCharacterShouts::Reloading' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, CharacterSelected) == 0x000098, "Member 'FCharacterShouts::CharacterSelected' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, UpgradeBought) == 0x0000A0, "Member 'FCharacterShouts::UpgradeBought' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, WaitingInDropPod) == 0x0000A8, "Member 'FCharacterShouts::WaitingInDropPod' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Carrying) == 0x0000B0, "Member 'FCharacterShouts::Carrying' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, WaitingInEscapePod) == 0x0000B8, "Member 'FCharacterShouts::WaitingInEscapePod' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Salute) == 0x0000C0, "Member 'FCharacterShouts::Salute' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Salute_Spacerig) == 0x0000C8, "Member 'FCharacterShouts::Salute_Spacerig' has a wrong offset!");
static_assert(offsetof(FCharacterShouts, Drink) == 0x0000D0, "Member 'FCharacterShouts::Drink' has a wrong offset!");

// ScriptStruct FSD.PickaxeSet
// 0x0038 (0x0038 - 0x0000)
struct FPickaxeSet final
{
public:
	class UPickaxePart*                           BladeFront;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPickaxePart*                           OptionalBladeBack;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPickaxePart*                           Pommel;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPickaxePart*                           Handle;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPickaxePart*                           Shaft;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPickaxePart*                           Head;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPickaxePart*                           Material;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickaxeSet) == 0x000008, "Wrong alignment on FPickaxeSet");
static_assert(sizeof(FPickaxeSet) == 0x000038, "Wrong size on FPickaxeSet");
static_assert(offsetof(FPickaxeSet, BladeFront) == 0x000000, "Member 'FPickaxeSet::BladeFront' has a wrong offset!");
static_assert(offsetof(FPickaxeSet, OptionalBladeBack) == 0x000008, "Member 'FPickaxeSet::OptionalBladeBack' has a wrong offset!");
static_assert(offsetof(FPickaxeSet, Pommel) == 0x000010, "Member 'FPickaxeSet::Pommel' has a wrong offset!");
static_assert(offsetof(FPickaxeSet, Handle) == 0x000018, "Member 'FPickaxeSet::Handle' has a wrong offset!");
static_assert(offsetof(FPickaxeSet, Shaft) == 0x000020, "Member 'FPickaxeSet::Shaft' has a wrong offset!");
static_assert(offsetof(FPickaxeSet, Head) == 0x000028, "Member 'FPickaxeSet::Head' has a wrong offset!");
static_assert(offsetof(FPickaxeSet, Material) == 0x000030, "Member 'FPickaxeSet::Material' has a wrong offset!");

// ScriptStruct FSD.GenerateIconInfo
// 0x0078 (0x0078 - 0x0000)
struct FGenerateIconInfo final
{
public:
	EGeneratorIconType                            IconType;                                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176B[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPickaxePart*                           PickaxePart;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPickaxeSet                            PickaxeSet;                                        // 0x0010(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	EPickaxePartLocation                          PickaxePartLocation;                               // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176C[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemSkin*                              ItemSkin;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVanityItem*                            Item;                                              // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerCharacterID*                     Character;                                         // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCloseUp;                                      // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176D[0x7];                                     // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenerateIconInfo) == 0x000008, "Wrong alignment on FGenerateIconInfo");
static_assert(sizeof(FGenerateIconInfo) == 0x000078, "Wrong size on FGenerateIconInfo");
static_assert(offsetof(FGenerateIconInfo, IconType) == 0x000000, "Member 'FGenerateIconInfo::IconType' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, PickaxePart) == 0x000008, "Member 'FGenerateIconInfo::PickaxePart' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, PickaxeSet) == 0x000010, "Member 'FGenerateIconInfo::PickaxeSet' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, PickaxePartLocation) == 0x000048, "Member 'FGenerateIconInfo::PickaxePartLocation' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, ItemSkin) == 0x000050, "Member 'FGenerateIconInfo::ItemSkin' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, Item) == 0x000058, "Member 'FGenerateIconInfo::Item' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, Character) == 0x000060, "Member 'FGenerateIconInfo::Character' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, Size) == 0x000068, "Member 'FGenerateIconInfo::Size' has a wrong offset!");
static_assert(offsetof(FGenerateIconInfo, bShowCloseUp) == 0x000070, "Member 'FGenerateIconInfo::bShowCloseUp' has a wrong offset!");

// ScriptStruct FSD.CommunityReward
// 0x0010 (0x0010 - 0x0000)
struct FCommunityReward final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176E[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommunityReward) == 0x000008, "Wrong alignment on FCommunityReward");
static_assert(sizeof(FCommunityReward) == 0x000010, "Wrong size on FCommunityReward");
static_assert(offsetof(FCommunityReward, Resource) == 0x000000, "Member 'FCommunityReward::Resource' has a wrong offset!");
static_assert(offsetof(FCommunityReward, Value) == 0x000008, "Member 'FCommunityReward::Value' has a wrong offset!");

// ScriptStruct FSD.CommunityFactionData
// 0x0038 (0x0038 - 0x0000)
struct FCommunityFactionData final
{
public:
	bool                                          IsValid;                                           // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176F[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Goals;                                             // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Values;                                            // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Members;                                           // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityFactionData) == 0x000008, "Wrong alignment on FCommunityFactionData");
static_assert(sizeof(FCommunityFactionData) == 0x000038, "Wrong size on FCommunityFactionData");
static_assert(offsetof(FCommunityFactionData, IsValid) == 0x000000, "Member 'FCommunityFactionData::IsValid' has a wrong offset!");
static_assert(offsetof(FCommunityFactionData, Goals) == 0x000008, "Member 'FCommunityFactionData::Goals' has a wrong offset!");
static_assert(offsetof(FCommunityFactionData, Values) == 0x000018, "Member 'FCommunityFactionData::Values' has a wrong offset!");
static_assert(offsetof(FCommunityFactionData, Members) == 0x000028, "Member 'FCommunityFactionData::Members' has a wrong offset!");

// ScriptStruct FSD.GuntowerModuleLevel
// 0x0018 (0x0018 - 0x0000)
struct FGuntowerModuleLevel final
{
public:
	TArray<TSubclassOf<class AGuntowerModule>>    PossibleModules;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          PreventDuplication;                                // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1770[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuntowerModuleLevel) == 0x000008, "Wrong alignment on FGuntowerModuleLevel");
static_assert(sizeof(FGuntowerModuleLevel) == 0x000018, "Wrong size on FGuntowerModuleLevel");
static_assert(offsetof(FGuntowerModuleLevel, PossibleModules) == 0x000000, "Member 'FGuntowerModuleLevel::PossibleModules' has a wrong offset!");
static_assert(offsetof(FGuntowerModuleLevel, PreventDuplication) == 0x000010, "Member 'FGuntowerModuleLevel::PreventDuplication' has a wrong offset!");

// ScriptStruct FSD.CommunityGoalStateData
// 0x0010 (0x0010 - 0x0000)
struct FCommunityGoalStateData final
{
public:
	bool                                          IsGoal;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRecruitment;                                     // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1771[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLeftSeconds;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentGoalPeriodID;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1772[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommunityGoalStateData) == 0x000004, "Wrong alignment on FCommunityGoalStateData");
static_assert(sizeof(FCommunityGoalStateData) == 0x000010, "Wrong size on FCommunityGoalStateData");
static_assert(offsetof(FCommunityGoalStateData, IsGoal) == 0x000000, "Member 'FCommunityGoalStateData::IsGoal' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateData, IsRecruitment) == 0x000001, "Member 'FCommunityGoalStateData::IsRecruitment' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateData, TimeLeftSeconds) == 0x000004, "Member 'FCommunityGoalStateData::TimeLeftSeconds' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateData, CurrentGoalPeriodID) == 0x000008, "Member 'FCommunityGoalStateData::CurrentGoalPeriodID' has a wrong offset!");

// ScriptStruct FSD.CommunityRewardNotification
// 0x0040 (0x0040 - 0x0000)
struct FCommunityRewardNotification final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColor;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityRewardNotification) == 0x000008, "Wrong alignment on FCommunityRewardNotification");
static_assert(sizeof(FCommunityRewardNotification) == 0x000040, "Wrong size on FCommunityRewardNotification");
static_assert(offsetof(FCommunityRewardNotification, Text) == 0x000000, "Member 'FCommunityRewardNotification::Text' has a wrong offset!");
static_assert(offsetof(FCommunityRewardNotification, Icon) == 0x000018, "Member 'FCommunityRewardNotification::Icon' has a wrong offset!");
static_assert(offsetof(FCommunityRewardNotification, IconColor) == 0x000020, "Member 'FCommunityRewardNotification::IconColor' has a wrong offset!");
static_assert(offsetof(FCommunityRewardNotification, ID) == 0x000030, "Member 'FCommunityRewardNotification::ID' has a wrong offset!");

// ScriptStruct FSD.FSDTagsAttitude
// 0x0018 (0x0018 - 0x0000)
struct FFSDTagsAttitude final
{
public:
	struct FGameplayTag                           Friendly;                                          // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Neutral;                                           // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Hostile;                                           // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDTagsAttitude) == 0x000004, "Wrong alignment on FFSDTagsAttitude");
static_assert(sizeof(FFSDTagsAttitude) == 0x000018, "Wrong size on FFSDTagsAttitude");
static_assert(offsetof(FFSDTagsAttitude, Friendly) == 0x000000, "Member 'FFSDTagsAttitude::Friendly' has a wrong offset!");
static_assert(offsetof(FFSDTagsAttitude, Neutral) == 0x000008, "Member 'FFSDTagsAttitude::Neutral' has a wrong offset!");
static_assert(offsetof(FFSDTagsAttitude, Hostile) == 0x000010, "Member 'FFSDTagsAttitude::Hostile' has a wrong offset!");

// ScriptStruct FSD.CommunityFactionResponse
// 0x0030 (0x0030 - 0x0000)
struct FCommunityFactionResponse final
{
public:
	TArray<class FString>                         Goals;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Values;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Members;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityFactionResponse) == 0x000008, "Wrong alignment on FCommunityFactionResponse");
static_assert(sizeof(FCommunityFactionResponse) == 0x000030, "Wrong size on FCommunityFactionResponse");
static_assert(offsetof(FCommunityFactionResponse, Goals) == 0x000000, "Member 'FCommunityFactionResponse::Goals' has a wrong offset!");
static_assert(offsetof(FCommunityFactionResponse, Values) == 0x000010, "Member 'FCommunityFactionResponse::Values' has a wrong offset!");
static_assert(offsetof(FCommunityFactionResponse, Members) == 0x000020, "Member 'FCommunityFactionResponse::Members' has a wrong offset!");

// ScriptStruct FSD.CommunityGoalStateResponse
// 0x0010 (0x0010 - 0x0000)
struct FCommunityGoalStateResponse final
{
public:
	bool                                          IsGoal;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRecruitment;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FreeBeers;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1773[0x1];                                     // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLeftSeconds;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastUpdateGoalsID;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentGoalPeriodID;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityGoalStateResponse) == 0x000004, "Wrong alignment on FCommunityGoalStateResponse");
static_assert(sizeof(FCommunityGoalStateResponse) == 0x000010, "Wrong size on FCommunityGoalStateResponse");
static_assert(offsetof(FCommunityGoalStateResponse, IsGoal) == 0x000000, "Member 'FCommunityGoalStateResponse::IsGoal' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateResponse, IsRecruitment) == 0x000001, "Member 'FCommunityGoalStateResponse::IsRecruitment' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateResponse, FreeBeers) == 0x000002, "Member 'FCommunityGoalStateResponse::FreeBeers' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateResponse, TimeLeftSeconds) == 0x000004, "Member 'FCommunityGoalStateResponse::TimeLeftSeconds' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateResponse, LastUpdateGoalsID) == 0x000008, "Member 'FCommunityGoalStateResponse::LastUpdateGoalsID' has a wrong offset!");
static_assert(offsetof(FCommunityGoalStateResponse, CurrentGoalPeriodID) == 0x00000C, "Member 'FCommunityGoalStateResponse::CurrentGoalPeriodID' has a wrong offset!");

// ScriptStruct FSD.NewPlayerMutator
// 0x0018 (0x0018 - 0x0000)
struct FNewPlayerMutator final
{
public:
	int32                                         MinCampaignProgress;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCampaignProgress;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMutator*>                       Mutators;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNewPlayerMutator) == 0x000008, "Wrong alignment on FNewPlayerMutator");
static_assert(sizeof(FNewPlayerMutator) == 0x000018, "Wrong size on FNewPlayerMutator");
static_assert(offsetof(FNewPlayerMutator, MinCampaignProgress) == 0x000000, "Member 'FNewPlayerMutator::MinCampaignProgress' has a wrong offset!");
static_assert(offsetof(FNewPlayerMutator, MaxCampaignProgress) == 0x000004, "Member 'FNewPlayerMutator::MaxCampaignProgress' has a wrong offset!");
static_assert(offsetof(FNewPlayerMutator, Mutators) == 0x000008, "Member 'FNewPlayerMutator::Mutators' has a wrong offset!");

// ScriptStruct FSD.CommunityGoalTierResponse
// 0x0028 (0x0028 - 0x0000)
struct FCommunityGoalTierResponse final
{
public:
	bool                                          Found;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1774[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GoalID;                                            // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstTierGoal;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondTierGoal;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdTierGoal;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1775[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommunityGoalTierResponse) == 0x000008, "Wrong alignment on FCommunityGoalTierResponse");
static_assert(sizeof(FCommunityGoalTierResponse) == 0x000028, "Wrong size on FCommunityGoalTierResponse");
static_assert(offsetof(FCommunityGoalTierResponse, Found) == 0x000000, "Member 'FCommunityGoalTierResponse::Found' has a wrong offset!");
static_assert(offsetof(FCommunityGoalTierResponse, GoalID) == 0x000008, "Member 'FCommunityGoalTierResponse::GoalID' has a wrong offset!");
static_assert(offsetof(FCommunityGoalTierResponse, FirstTierGoal) == 0x000018, "Member 'FCommunityGoalTierResponse::FirstTierGoal' has a wrong offset!");
static_assert(offsetof(FCommunityGoalTierResponse, SecondTierGoal) == 0x00001C, "Member 'FCommunityGoalTierResponse::SecondTierGoal' has a wrong offset!");
static_assert(offsetof(FCommunityGoalTierResponse, ThirdTierGoal) == 0x000020, "Member 'FCommunityGoalTierResponse::ThirdTierGoal' has a wrong offset!");

// ScriptStruct FSD.CommunityGoalIncrementResponse
// 0x0001 (0x0001 - 0x0000)
struct FCommunityGoalIncrementResponse final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityGoalIncrementResponse) == 0x000001, "Wrong alignment on FCommunityGoalIncrementResponse");
static_assert(sizeof(FCommunityGoalIncrementResponse) == 0x000001, "Wrong size on FCommunityGoalIncrementResponse");
static_assert(offsetof(FCommunityGoalIncrementResponse, Success) == 0x000000, "Member 'FCommunityGoalIncrementResponse::Success' has a wrong offset!");

// ScriptStruct FSD.CommunityGoalRequest
// 0x0038 (0x0038 - 0x0000)
struct FCommunityGoalRequest final
{
public:
	class FString                                 GoalID;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FactionID;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SteamTicket;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Branch;                                            // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommunityGoalRequest) == 0x000008, "Wrong alignment on FCommunityGoalRequest");
static_assert(sizeof(FCommunityGoalRequest) == 0x000038, "Wrong size on FCommunityGoalRequest");
static_assert(offsetof(FCommunityGoalRequest, GoalID) == 0x000000, "Member 'FCommunityGoalRequest::GoalID' has a wrong offset!");
static_assert(offsetof(FCommunityGoalRequest, FactionID) == 0x000010, "Member 'FCommunityGoalRequest::FactionID' has a wrong offset!");
static_assert(offsetof(FCommunityGoalRequest, Value) == 0x000014, "Member 'FCommunityGoalRequest::Value' has a wrong offset!");
static_assert(offsetof(FCommunityGoalRequest, SteamTicket) == 0x000018, "Member 'FCommunityGoalRequest::SteamTicket' has a wrong offset!");
static_assert(offsetof(FCommunityGoalRequest, Branch) == 0x000028, "Member 'FCommunityGoalRequest::Branch' has a wrong offset!");

// ScriptStruct FSD.PlatformSpecificEventPopup
// 0x0030 (0x0030 - 0x0000)
struct FPlatformSpecificEventPopup final
{
public:
	EFSDTargetPlatform                            TargetPlatform;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1776[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PopupWidget;                                       // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlatformSpecificEventPopup) == 0x000008, "Wrong alignment on FPlatformSpecificEventPopup");
static_assert(sizeof(FPlatformSpecificEventPopup) == 0x000030, "Wrong size on FPlatformSpecificEventPopup");
static_assert(offsetof(FPlatformSpecificEventPopup, TargetPlatform) == 0x000000, "Member 'FPlatformSpecificEventPopup::TargetPlatform' has a wrong offset!");
static_assert(offsetof(FPlatformSpecificEventPopup, PopupWidget) == 0x000008, "Member 'FPlatformSpecificEventPopup::PopupWidget' has a wrong offset!");

// ScriptStruct FSD.ActionIconMapping
// 0x0028 (0x0028 - 0x0000)
struct FActionIconMapping final
{
public:
	struct FKey                                   ActionKey;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoNotTint;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1777[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionIconMapping) == 0x000008, "Wrong alignment on FActionIconMapping");
static_assert(sizeof(FActionIconMapping) == 0x000028, "Wrong size on FActionIconMapping");
static_assert(offsetof(FActionIconMapping, ActionKey) == 0x000000, "Member 'FActionIconMapping::ActionKey' has a wrong offset!");
static_assert(offsetof(FActionIconMapping, Icon) == 0x000018, "Member 'FActionIconMapping::Icon' has a wrong offset!");
static_assert(offsetof(FActionIconMapping, DoNotTint) == 0x000020, "Member 'FActionIconMapping::DoNotTint' has a wrong offset!");

// ScriptStruct FSD.PricingTierEntry
// 0x0020 (0x0028 - 0x0008)
struct FPricingTierEntry final : public FTableRowBase
{
public:
	struct FIRandRange                            CreditCost;                                        // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FIRandRange                            Material1;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FIRandRange                            Material2;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FIRandRange                            Material3;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPricingTierEntry) == 0x000008, "Wrong alignment on FPricingTierEntry");
static_assert(sizeof(FPricingTierEntry) == 0x000028, "Wrong size on FPricingTierEntry");
static_assert(offsetof(FPricingTierEntry, CreditCost) == 0x000008, "Member 'FPricingTierEntry::CreditCost' has a wrong offset!");
static_assert(offsetof(FPricingTierEntry, Material1) == 0x000010, "Member 'FPricingTierEntry::Material1' has a wrong offset!");
static_assert(offsetof(FPricingTierEntry, Material2) == 0x000018, "Member 'FPricingTierEntry::Material2' has a wrong offset!");
static_assert(offsetof(FPricingTierEntry, Material3) == 0x000020, "Member 'FPricingTierEntry::Material3' has a wrong offset!");

// ScriptStruct FSD.Curve2DAppearance
// 0x0028 (0x0028 - 0x0000)
struct FCurve2DAppearance final
{
public:
	float                                         Thickness;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlineThickness;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutlineTint;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurve2DAppearance) == 0x000004, "Wrong alignment on FCurve2DAppearance");
static_assert(sizeof(FCurve2DAppearance) == 0x000028, "Wrong size on FCurve2DAppearance");
static_assert(offsetof(FCurve2DAppearance, Thickness) == 0x000000, "Member 'FCurve2DAppearance::Thickness' has a wrong offset!");
static_assert(offsetof(FCurve2DAppearance, Tint) == 0x000004, "Member 'FCurve2DAppearance::Tint' has a wrong offset!");
static_assert(offsetof(FCurve2DAppearance, OutlineThickness) == 0x000014, "Member 'FCurve2DAppearance::OutlineThickness' has a wrong offset!");
static_assert(offsetof(FCurve2DAppearance, OutlineTint) == 0x000018, "Member 'FCurve2DAppearance::OutlineTint' has a wrong offset!");

// ScriptStruct FSD.DailyDealSetup
// 0x0028 (0x0028 - 0x0000)
struct FDailyDealSetup final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDealType                                     DealType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1778[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              UnitsRange;                                        // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DiscountRangePercent;                              // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ExtraValueRangePercent;                            // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1779[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDailyDealSetup) == 0x000008, "Wrong alignment on FDailyDealSetup");
static_assert(sizeof(FDailyDealSetup) == 0x000028, "Wrong size on FDailyDealSetup");
static_assert(offsetof(FDailyDealSetup, Resource) == 0x000000, "Member 'FDailyDealSetup::Resource' has a wrong offset!");
static_assert(offsetof(FDailyDealSetup, DealType) == 0x000008, "Member 'FDailyDealSetup::DealType' has a wrong offset!");
static_assert(offsetof(FDailyDealSetup, UnitsRange) == 0x00000C, "Member 'FDailyDealSetup::UnitsRange' has a wrong offset!");
static_assert(offsetof(FDailyDealSetup, DiscountRangePercent) == 0x000014, "Member 'FDailyDealSetup::DiscountRangePercent' has a wrong offset!");
static_assert(offsetof(FDailyDealSetup, ExtraValueRangePercent) == 0x00001C, "Member 'FDailyDealSetup::ExtraValueRangePercent' has a wrong offset!");

// ScriptStruct FSD.CustomCounter
// 0x0028 (0x0028 - 0x0000)
struct FCustomCounter final
{
public:
	TDelegate<void(float Value, float NormalizedTime)> OnCount;                                           // 0x0000(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 Owner;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_177A[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomCounter) == 0x000004, "Wrong alignment on FCustomCounter");
static_assert(sizeof(FCustomCounter) == 0x000028, "Wrong size on FCustomCounter");
static_assert(offsetof(FCustomCounter, OnCount) == 0x000000, "Member 'FCustomCounter::OnCount' has a wrong offset!");
static_assert(offsetof(FCustomCounter, Owner) == 0x000010, "Member 'FCustomCounter::Owner' has a wrong offset!");

// ScriptStruct FSD.DamageSubsystemItem
// 0x0020 (0x0020 - 0x0000)
struct FDamageSubsystemItem final
{
public:
	class UDamageComponent*                       DamageComponent;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_177B[0x18];                                    // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageSubsystemItem) == 0x000008, "Wrong alignment on FDamageSubsystemItem");
static_assert(sizeof(FDamageSubsystemItem) == 0x000020, "Wrong size on FDamageSubsystemItem");
static_assert(offsetof(FDamageSubsystemItem, DamageComponent) == 0x000000, "Member 'FDamageSubsystemItem::DamageComponent' has a wrong offset!");

// ScriptStruct FSD.FSDServicesEndpoints
// 0x0100 (0x0100 - 0x0000)
struct alignas(0x08) FFSDServicesEndpoints final
{
public:
	uint8                                         Pad_177C[0x100];                                   // 0x0000(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFSDServicesEndpoints) == 0x000008, "Wrong alignment on FFSDServicesEndpoints");
static_assert(sizeof(FFSDServicesEndpoints) == 0x000100, "Wrong size on FFSDServicesEndpoints");

// ScriptStruct FSD.DanceItem
// 0x0010 (0x0010 - 0x0000)
struct FDanceItem final
{
public:
	class UAnimSequence*                          DanceMove;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DanceMoveWithBeer;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDanceItem) == 0x000008, "Wrong alignment on FDanceItem");
static_assert(sizeof(FDanceItem) == 0x000010, "Wrong size on FDanceItem");
static_assert(offsetof(FDanceItem, DanceMove) == 0x000000, "Member 'FDanceItem::DanceMove' has a wrong offset!");
static_assert(offsetof(FDanceItem, DanceMoveWithBeer) == 0x000008, "Member 'FDanceItem::DanceMoveWithBeer' has a wrong offset!");

// ScriptStruct FSD.CellNoise
// 0x002C (0x002C - 0x0000)
struct FCellNoise final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CellSize;                                          // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumValues;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCellValue;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCellValue;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_177D[0x10];                                    // 0x001C(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCellNoise) == 0x000004, "Wrong alignment on FCellNoise");
static_assert(sizeof(FCellNoise) == 0x00002C, "Wrong size on FCellNoise");
static_assert(offsetof(FCellNoise, Seed) == 0x000000, "Member 'FCellNoise::Seed' has a wrong offset!");
static_assert(offsetof(FCellNoise, CellSize) == 0x000004, "Member 'FCellNoise::CellSize' has a wrong offset!");
static_assert(offsetof(FCellNoise, NumValues) == 0x000010, "Member 'FCellNoise::NumValues' has a wrong offset!");
static_assert(offsetof(FCellNoise, MinCellValue) == 0x000014, "Member 'FCellNoise::MinCellValue' has a wrong offset!");
static_assert(offsetof(FCellNoise, MaxCellValue) == 0x000018, "Member 'FCellNoise::MaxCellValue' has a wrong offset!");

// ScriptStruct FSD.UDebrisCarveMesh
// 0x0010 (0x0010 - 0x0000)
struct FUDebrisCarveMesh final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probablity;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_177E[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUDebrisCarveMesh) == 0x000008, "Wrong alignment on FUDebrisCarveMesh");
static_assert(sizeof(FUDebrisCarveMesh) == 0x000010, "Wrong size on FUDebrisCarveMesh");
static_assert(offsetof(FUDebrisCarveMesh, Mesh) == 0x000000, "Member 'FUDebrisCarveMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FUDebrisCarveMesh, Probablity) == 0x000008, "Member 'FUDebrisCarveMesh::Probablity' has a wrong offset!");

// ScriptStruct FSD.RetirementCostItem
// 0x0050 (0x0050 - 0x0000)
struct FRetirementCostItem final
{
public:
	TMap<class UResourceData*, int32>             RetirementCost;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRetirementCostItem) == 0x000008, "Wrong alignment on FRetirementCostItem");
static_assert(sizeof(FRetirementCostItem) == 0x000050, "Wrong size on FRetirementCostItem");
static_assert(offsetof(FRetirementCostItem, RetirementCost) == 0x000000, "Member 'FRetirementCostItem::RetirementCost' has a wrong offset!");

// ScriptStruct FSD.GDCharacterRetirement
// 0x00C0 (0x00C0 - 0x0000)
struct FGDCharacterRetirement final
{
public:
	TMap<class UPlayerCharacterID*, TSubclassOf<class UCampaign>> Campaigns;                                         // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UPlayerCharacterID*, struct FRetirementCostItem> RetirementCost;                                    // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<float>                                 CreditsCostMultipliers;                            // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ResourceCostMultipliers;                           // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDCharacterRetirement) == 0x000008, "Wrong alignment on FGDCharacterRetirement");
static_assert(sizeof(FGDCharacterRetirement) == 0x0000C0, "Wrong size on FGDCharacterRetirement");
static_assert(offsetof(FGDCharacterRetirement, Campaigns) == 0x000000, "Member 'FGDCharacterRetirement::Campaigns' has a wrong offset!");
static_assert(offsetof(FGDCharacterRetirement, RetirementCost) == 0x000050, "Member 'FGDCharacterRetirement::RetirementCost' has a wrong offset!");
static_assert(offsetof(FGDCharacterRetirement, CreditsCostMultipliers) == 0x0000A0, "Member 'FGDCharacterRetirement::CreditsCostMultipliers' has a wrong offset!");
static_assert(offsetof(FGDCharacterRetirement, ResourceCostMultipliers) == 0x0000B0, "Member 'FGDCharacterRetirement::ResourceCostMultipliers' has a wrong offset!");

// ScriptStruct FSD.DebrisItemActorItem
// 0x0010 (0x0010 - 0x0000)
struct FDebrisItemActorItem final
{
public:
	TSubclassOf<class AActor>                     Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_177F[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebrisItemActorItem) == 0x000008, "Wrong alignment on FDebrisItemActorItem");
static_assert(sizeof(FDebrisItemActorItem) == 0x000010, "Wrong size on FDebrisItemActorItem");
static_assert(offsetof(FDebrisItemActorItem, Actor) == 0x000000, "Member 'FDebrisItemActorItem::Actor' has a wrong offset!");
static_assert(offsetof(FDebrisItemActorItem, Probability) == 0x000008, "Member 'FDebrisItemActorItem::Probability' has a wrong offset!");

// ScriptStruct FSD.DecalData
// 0x0020 (0x0020 - 0x0000)
struct FDecalData final
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSize;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalDepth;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelay;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDecalData) == 0x000008, "Wrong alignment on FDecalData");
static_assert(sizeof(FDecalData) == 0x000020, "Wrong size on FDecalData");
static_assert(offsetof(FDecalData, DecalMaterial) == 0x000000, "Member 'FDecalData::DecalMaterial' has a wrong offset!");
static_assert(offsetof(FDecalData, DecalSize) == 0x000008, "Member 'FDecalData::DecalSize' has a wrong offset!");
static_assert(offsetof(FDecalData, DecalDepth) == 0x00000C, "Member 'FDecalData::DecalDepth' has a wrong offset!");
static_assert(offsetof(FDecalData, LifeSpan) == 0x000010, "Member 'FDecalData::LifeSpan' has a wrong offset!");
static_assert(offsetof(FDecalData, StartDelay) == 0x000014, "Member 'FDecalData::StartDelay' has a wrong offset!");
static_assert(offsetof(FDecalData, FadeInDuration) == 0x000018, "Member 'FDecalData::FadeInDuration' has a wrong offset!");
static_assert(offsetof(FDecalData, FadeDuration) == 0x00001C, "Member 'FDecalData::FadeDuration' has a wrong offset!");

// ScriptStruct FSD.DebrisStaticMesh
// 0x0058 (0x0058 - 0x0000)
struct FDebrisStaticMesh final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDebrisMeshCollisionProfile                   CollisionProfile;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1780[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Probablity;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DestroyedSound;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         DestroyedParticles;                                // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDecalData                             Decal;                                             // 0x0028(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Fragile;                                           // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDebrisMeshShadows                            CastShadows;                                       // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Durable;                                           // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1781[0x1];                                     // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpecialDebrisType;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpawnWhenCarving;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlySpawnWhenCarving;                              // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1782[0x6];                                     // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebrisStaticMesh) == 0x000008, "Wrong alignment on FDebrisStaticMesh");
static_assert(sizeof(FDebrisStaticMesh) == 0x000058, "Wrong size on FDebrisStaticMesh");
static_assert(offsetof(FDebrisStaticMesh, Mesh) == 0x000000, "Member 'FDebrisStaticMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, Material) == 0x000008, "Member 'FDebrisStaticMesh::Material' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, CollisionProfile) == 0x000010, "Member 'FDebrisStaticMesh::CollisionProfile' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, Probablity) == 0x000014, "Member 'FDebrisStaticMesh::Probablity' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, DestroyedSound) == 0x000018, "Member 'FDebrisStaticMesh::DestroyedSound' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, DestroyedParticles) == 0x000020, "Member 'FDebrisStaticMesh::DestroyedParticles' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, Decal) == 0x000028, "Member 'FDebrisStaticMesh::Decal' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, Fragile) == 0x000048, "Member 'FDebrisStaticMesh::Fragile' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, CastShadows) == 0x000049, "Member 'FDebrisStaticMesh::CastShadows' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, Durable) == 0x00004A, "Member 'FDebrisStaticMesh::Durable' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, SpecialDebrisType) == 0x00004C, "Member 'FDebrisStaticMesh::SpecialDebrisType' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, SpawnWhenCarving) == 0x000050, "Member 'FDebrisStaticMesh::SpawnWhenCarving' has a wrong offset!");
static_assert(offsetof(FDebrisStaticMesh, OnlySpawnWhenCarving) == 0x000051, "Member 'FDebrisStaticMesh::OnlySpawnWhenCarving' has a wrong offset!");

// ScriptStruct FSD.GDPlayerAndCharacterProgression
// 0x00A0 (0x00A0 - 0x0000)
struct FGDPlayerAndCharacterProgression final
{
public:
	TArray<TSoftClassPtr<class UClass>>           RankedHeroClasses;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           TestHeroClasses;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class APlayerCharacter>>   LoadedClasses;                                     // 0x0020(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FText>                           PlayerRankNames;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CharacterXPLevels;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class UPlayerCharacterID*> PlayerCharacterIDs;                                // 0x0050(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDPlayerAndCharacterProgression) == 0x000008, "Wrong alignment on FGDPlayerAndCharacterProgression");
static_assert(sizeof(FGDPlayerAndCharacterProgression) == 0x0000A0, "Wrong size on FGDPlayerAndCharacterProgression");
static_assert(offsetof(FGDPlayerAndCharacterProgression, RankedHeroClasses) == 0x000000, "Member 'FGDPlayerAndCharacterProgression::RankedHeroClasses' has a wrong offset!");
static_assert(offsetof(FGDPlayerAndCharacterProgression, TestHeroClasses) == 0x000010, "Member 'FGDPlayerAndCharacterProgression::TestHeroClasses' has a wrong offset!");
static_assert(offsetof(FGDPlayerAndCharacterProgression, LoadedClasses) == 0x000020, "Member 'FGDPlayerAndCharacterProgression::LoadedClasses' has a wrong offset!");
static_assert(offsetof(FGDPlayerAndCharacterProgression, PlayerRankNames) == 0x000030, "Member 'FGDPlayerAndCharacterProgression::PlayerRankNames' has a wrong offset!");
static_assert(offsetof(FGDPlayerAndCharacterProgression, CharacterXPLevels) == 0x000040, "Member 'FGDPlayerAndCharacterProgression::CharacterXPLevels' has a wrong offset!");
static_assert(offsetof(FGDPlayerAndCharacterProgression, PlayerCharacterIDs) == 0x000050, "Member 'FGDPlayerAndCharacterProgression::PlayerCharacterIDs' has a wrong offset!");

// ScriptStruct FSD.UDebrisStaticCarveMesh
// 0x0010 (0x0010 - 0x0000)
struct FUDebrisStaticCarveMesh final
{
public:
	class UStaticMeshCarver*                      Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probablity;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1783[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUDebrisStaticCarveMesh) == 0x000008, "Wrong alignment on FUDebrisStaticCarveMesh");
static_assert(sizeof(FUDebrisStaticCarveMesh) == 0x000010, "Wrong size on FUDebrisStaticCarveMesh");
static_assert(offsetof(FUDebrisStaticCarveMesh, Mesh) == 0x000000, "Member 'FUDebrisStaticCarveMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FUDebrisStaticCarveMesh, Probablity) == 0x000008, "Member 'FUDebrisStaticCarveMesh::Probablity' has a wrong offset!");

// ScriptStruct FSD.WidgetFade
// 0x001C (0x001C - 0x0000)
struct FWidgetFade final
{
public:
	TWeakObjectPtr<class UUserWidget>             Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1784[0x14];                                    // 0x0008(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetFade) == 0x000004, "Wrong alignment on FWidgetFade");
static_assert(sizeof(FWidgetFade) == 0x00001C, "Wrong size on FWidgetFade");
static_assert(offsetof(FWidgetFade, Widget) == 0x000000, "Member 'FWidgetFade::Widget' has a wrong offset!");

// ScriptStruct FSD.DebrisCapsule
// 0x0020 (0x0020 - 0x0000)
struct FDebrisCapsule final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebrisCapsule) == 0x000004, "Wrong alignment on FDebrisCapsule");
static_assert(sizeof(FDebrisCapsule) == 0x000020, "Wrong size on FDebrisCapsule");
static_assert(offsetof(FDebrisCapsule, ID) == 0x000000, "Member 'FDebrisCapsule::ID' has a wrong offset!");
static_assert(offsetof(FDebrisCapsule, Start) == 0x000004, "Member 'FDebrisCapsule::Start' has a wrong offset!");
static_assert(offsetof(FDebrisCapsule, End) == 0x000010, "Member 'FDebrisCapsule::End' has a wrong offset!");
static_assert(offsetof(FDebrisCapsule, Radius) == 0x00001C, "Member 'FDebrisCapsule::Radius' has a wrong offset!");

// ScriptStruct FSD.DebrisInfluence
// 0x0010 (0x0010 - 0x0000)
struct FDebrisInfluence final
{
public:
	class UObject*                                CaveInfluencer;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1785[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebrisInfluence) == 0x000008, "Wrong alignment on FDebrisInfluence");
static_assert(sizeof(FDebrisInfluence) == 0x000010, "Wrong size on FDebrisInfluence");
static_assert(offsetof(FDebrisInfluence, CaveInfluencer) == 0x000000, "Member 'FDebrisInfluence::CaveInfluencer' has a wrong offset!");
static_assert(offsetof(FDebrisInfluence, Radius) == 0x000008, "Member 'FDebrisInfluence::Radius' has a wrong offset!");

// ScriptStruct FSD.RuntimeSpawnedDebris
// 0x0040 (0x0040 - 0x0000)
struct FRuntimeSpawnedDebris final
{
public:
	uint8                                         Pad_1786[0x28];                                    // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDebrisInstances*>               DebrisInstances;                                   // 0x0028(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDebrisMesh*                            DebrisMesh;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeSpawnedDebris) == 0x000008, "Wrong alignment on FRuntimeSpawnedDebris");
static_assert(sizeof(FRuntimeSpawnedDebris) == 0x000040, "Wrong size on FRuntimeSpawnedDebris");
static_assert(offsetof(FRuntimeSpawnedDebris, DebrisInstances) == 0x000028, "Member 'FRuntimeSpawnedDebris::DebrisInstances' has a wrong offset!");
static_assert(offsetof(FRuntimeSpawnedDebris, DebrisMesh) == 0x000038, "Member 'FRuntimeSpawnedDebris::DebrisMesh' has a wrong offset!");

// ScriptStruct FSD.DebrisWhenCarving
// 0x0030 (0x0030 - 0x0000)
struct FDebrisWhenCarving final
{
public:
	uint8                                         Pad_1787[0x28];                                    // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebrisInstances*                       Debris;                                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebrisWhenCarving) == 0x000008, "Wrong alignment on FDebrisWhenCarving");
static_assert(sizeof(FDebrisWhenCarving) == 0x000030, "Wrong size on FDebrisWhenCarving");
static_assert(offsetof(FDebrisWhenCarving, Debris) == 0x000028, "Member 'FDebrisWhenCarving::Debris' has a wrong offset!");

// ScriptStruct FSD.TrackPositionList
// 0x0038 (0x0038 - 0x0000)
struct FTrackPositionList final
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector4>                       Positions;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UGemTracker>>     Trackers;                                          // 0x0018(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UMaterialInstanceDynamic>> DynamicMaterials;                                  // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackPositionList) == 0x000008, "Wrong alignment on FTrackPositionList");
static_assert(sizeof(FTrackPositionList) == 0x000038, "Wrong size on FTrackPositionList");
static_assert(offsetof(FTrackPositionList, TrackName) == 0x000000, "Member 'FTrackPositionList::TrackName' has a wrong offset!");
static_assert(offsetof(FTrackPositionList, Positions) == 0x000008, "Member 'FTrackPositionList::Positions' has a wrong offset!");
static_assert(offsetof(FTrackPositionList, Trackers) == 0x000018, "Member 'FTrackPositionList::Trackers' has a wrong offset!");
static_assert(offsetof(FTrackPositionList, DynamicMaterials) == 0x000028, "Member 'FTrackPositionList::DynamicMaterials' has a wrong offset!");

// ScriptStruct FSD.CSGRaycastHitInfo
// 0x001C (0x001C - 0x0000)
struct FCSGRaycastHitInfo final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Material;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCSGRaycastHitInfo) == 0x000004, "Wrong alignment on FCSGRaycastHitInfo");
static_assert(sizeof(FCSGRaycastHitInfo) == 0x00001C, "Wrong size on FCSGRaycastHitInfo");
static_assert(offsetof(FCSGRaycastHitInfo, Position) == 0x000000, "Member 'FCSGRaycastHitInfo::Position' has a wrong offset!");
static_assert(offsetof(FCSGRaycastHitInfo, Normal) == 0x00000C, "Member 'FCSGRaycastHitInfo::Normal' has a wrong offset!");
static_assert(offsetof(FCSGRaycastHitInfo, Material) == 0x000018, "Member 'FCSGRaycastHitInfo::Material' has a wrong offset!");

// ScriptStruct FSD.DeepDiveTemplateItem
// 0x0038 (0x0038 - 0x0000)
struct FDeepDiveTemplateItem final
{
public:
	class UMissionTemplate*                       Mission;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1788[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMissionDuration*>               AllowedDurations;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMissionComplexity*>             AllowedComplexities;                               // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CanOnlyAppearOnce;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanOnlyAppearOncePerDeepDiveSet;                   // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1789[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeepDiveTemplateItem) == 0x000008, "Wrong alignment on FDeepDiveTemplateItem");
static_assert(sizeof(FDeepDiveTemplateItem) == 0x000038, "Wrong size on FDeepDiveTemplateItem");
static_assert(offsetof(FDeepDiveTemplateItem, Mission) == 0x000000, "Member 'FDeepDiveTemplateItem::Mission' has a wrong offset!");
static_assert(offsetof(FDeepDiveTemplateItem, Probability) == 0x000008, "Member 'FDeepDiveTemplateItem::Probability' has a wrong offset!");
static_assert(offsetof(FDeepDiveTemplateItem, AllowedDurations) == 0x000010, "Member 'FDeepDiveTemplateItem::AllowedDurations' has a wrong offset!");
static_assert(offsetof(FDeepDiveTemplateItem, AllowedComplexities) == 0x000020, "Member 'FDeepDiveTemplateItem::AllowedComplexities' has a wrong offset!");
static_assert(offsetof(FDeepDiveTemplateItem, CanOnlyAppearOnce) == 0x000030, "Member 'FDeepDiveTemplateItem::CanOnlyAppearOnce' has a wrong offset!");
static_assert(offsetof(FDeepDiveTemplateItem, CanOnlyAppearOncePerDeepDiveSet) == 0x000031, "Member 'FDeepDiveTemplateItem::CanOnlyAppearOncePerDeepDiveSet' has a wrong offset!");

// ScriptStruct FSD.HandleRotationOptions
// 0x0001 (0x0001 - 0x0000)
struct FHandleRotationOptions final
{
public:
	bool                                          HandlePitch;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandleRotationOptions) == 0x000001, "Wrong alignment on FHandleRotationOptions");
static_assert(sizeof(FHandleRotationOptions) == 0x000001, "Wrong size on FHandleRotationOptions");
static_assert(offsetof(FHandleRotationOptions, HandlePitch) == 0x000000, "Member 'FHandleRotationOptions::HandlePitch' has a wrong offset!");

// ScriptStruct FSD.DeepRepPath
// 0x00D0 (0x00D0 - 0x0000)
struct FDeepRepPath final
{
public:
	struct FVector                                PathBase;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PathLength;                                        // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeepMovementState                            State;                                             // 0x000D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StateBits;                                         // 0x000E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178A[0x1];                                     // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PathOffsets[0x10];                                 // 0x0010(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeepRepPath) == 0x000004, "Wrong alignment on FDeepRepPath");
static_assert(sizeof(FDeepRepPath) == 0x0000D0, "Wrong size on FDeepRepPath");
static_assert(offsetof(FDeepRepPath, PathBase) == 0x000000, "Member 'FDeepRepPath::PathBase' has a wrong offset!");
static_assert(offsetof(FDeepRepPath, PathLength) == 0x00000C, "Member 'FDeepRepPath::PathLength' has a wrong offset!");
static_assert(offsetof(FDeepRepPath, State) == 0x00000D, "Member 'FDeepRepPath::State' has a wrong offset!");
static_assert(offsetof(FDeepRepPath, StateBits) == 0x00000E, "Member 'FDeepRepPath::StateBits' has a wrong offset!");
static_assert(offsetof(FDeepRepPath, PathOffsets) == 0x000010, "Member 'FDeepRepPath::PathOffsets' has a wrong offset!");

// ScriptStruct FSD.GDResources
// 0x00F0 (0x00F0 - 0x0000)
struct FGDResources final
{
public:
	class UResourceData*                          CreditsResource;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          Fashionite;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          MOMResource;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          GoldResource;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          NitraResource;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          HollomiteResource;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          MagniteResource;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          NeromiteResource;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          QuantriteResource;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          UmaniteResource;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          CropaniteResource;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          DystrumResource;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          IronResource;                                      // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          EnorResource;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          BismorResource;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          OilShaleResource;                                  // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          Barly1;                                            // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          Barly2;                                            // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          Barly3;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          Barly4;                                            // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGemResourceData*                       JadizResource;                                     // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGemResourceData*                       BittergemResource;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGemResourceData*                       MotherlodeGemResource;                             // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          RedSugarResource;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UResourceData*                          BlankSchematics;                                   // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UResourceData*>                  CraftingResources;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UResourceData*>                  AllResources;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         FashioniteToCredits;                               // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FashioniteToMinerals;                              // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDResources) == 0x000008, "Wrong alignment on FGDResources");
static_assert(sizeof(FGDResources) == 0x0000F0, "Wrong size on FGDResources");
static_assert(offsetof(FGDResources, CreditsResource) == 0x000000, "Member 'FGDResources::CreditsResource' has a wrong offset!");
static_assert(offsetof(FGDResources, Fashionite) == 0x000008, "Member 'FGDResources::Fashionite' has a wrong offset!");
static_assert(offsetof(FGDResources, MOMResource) == 0x000010, "Member 'FGDResources::MOMResource' has a wrong offset!");
static_assert(offsetof(FGDResources, GoldResource) == 0x000018, "Member 'FGDResources::GoldResource' has a wrong offset!");
static_assert(offsetof(FGDResources, NitraResource) == 0x000020, "Member 'FGDResources::NitraResource' has a wrong offset!");
static_assert(offsetof(FGDResources, HollomiteResource) == 0x000028, "Member 'FGDResources::HollomiteResource' has a wrong offset!");
static_assert(offsetof(FGDResources, MagniteResource) == 0x000030, "Member 'FGDResources::MagniteResource' has a wrong offset!");
static_assert(offsetof(FGDResources, NeromiteResource) == 0x000038, "Member 'FGDResources::NeromiteResource' has a wrong offset!");
static_assert(offsetof(FGDResources, QuantriteResource) == 0x000040, "Member 'FGDResources::QuantriteResource' has a wrong offset!");
static_assert(offsetof(FGDResources, UmaniteResource) == 0x000048, "Member 'FGDResources::UmaniteResource' has a wrong offset!");
static_assert(offsetof(FGDResources, CropaniteResource) == 0x000050, "Member 'FGDResources::CropaniteResource' has a wrong offset!");
static_assert(offsetof(FGDResources, DystrumResource) == 0x000058, "Member 'FGDResources::DystrumResource' has a wrong offset!");
static_assert(offsetof(FGDResources, IronResource) == 0x000060, "Member 'FGDResources::IronResource' has a wrong offset!");
static_assert(offsetof(FGDResources, EnorResource) == 0x000068, "Member 'FGDResources::EnorResource' has a wrong offset!");
static_assert(offsetof(FGDResources, BismorResource) == 0x000070, "Member 'FGDResources::BismorResource' has a wrong offset!");
static_assert(offsetof(FGDResources, OilShaleResource) == 0x000078, "Member 'FGDResources::OilShaleResource' has a wrong offset!");
static_assert(offsetof(FGDResources, Barly1) == 0x000080, "Member 'FGDResources::Barly1' has a wrong offset!");
static_assert(offsetof(FGDResources, Barly2) == 0x000088, "Member 'FGDResources::Barly2' has a wrong offset!");
static_assert(offsetof(FGDResources, Barly3) == 0x000090, "Member 'FGDResources::Barly3' has a wrong offset!");
static_assert(offsetof(FGDResources, Barly4) == 0x000098, "Member 'FGDResources::Barly4' has a wrong offset!");
static_assert(offsetof(FGDResources, JadizResource) == 0x0000A0, "Member 'FGDResources::JadizResource' has a wrong offset!");
static_assert(offsetof(FGDResources, BittergemResource) == 0x0000A8, "Member 'FGDResources::BittergemResource' has a wrong offset!");
static_assert(offsetof(FGDResources, MotherlodeGemResource) == 0x0000B0, "Member 'FGDResources::MotherlodeGemResource' has a wrong offset!");
static_assert(offsetof(FGDResources, RedSugarResource) == 0x0000B8, "Member 'FGDResources::RedSugarResource' has a wrong offset!");
static_assert(offsetof(FGDResources, BlankSchematics) == 0x0000C0, "Member 'FGDResources::BlankSchematics' has a wrong offset!");
static_assert(offsetof(FGDResources, CraftingResources) == 0x0000C8, "Member 'FGDResources::CraftingResources' has a wrong offset!");
static_assert(offsetof(FGDResources, AllResources) == 0x0000D8, "Member 'FGDResources::AllResources' has a wrong offset!");
static_assert(offsetof(FGDResources, FashioniteToCredits) == 0x0000E8, "Member 'FGDResources::FashioniteToCredits' has a wrong offset!");
static_assert(offsetof(FGDResources, FashioniteToMinerals) == 0x0000EC, "Member 'FGDResources::FashioniteToMinerals' has a wrong offset!");

// ScriptStruct FSD.TerrainLateJoinIteration
// 0x0034 (0x0034 - 0x0000)
struct FTerrainLateJoinIteration final
{
public:
	int32                                         DrillsIndex;                                       // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeltsIndex;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickAxeIndex;                                      // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FloatingIndex;                                     // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColliderCarvesIndex;                               // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeshCarvesIndex;                                   // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExplosionsIndex;                                   // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SplineIndex;                                       // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CSGIndex;                                          // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnDebrisIndex;                                  // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LateJoinIndex;                                     // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebrisIndex;                                       // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChunkVisibilityIndex;                              // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainLateJoinIteration) == 0x000004, "Wrong alignment on FTerrainLateJoinIteration");
static_assert(sizeof(FTerrainLateJoinIteration) == 0x000034, "Wrong size on FTerrainLateJoinIteration");
static_assert(offsetof(FTerrainLateJoinIteration, DrillsIndex) == 0x000000, "Member 'FTerrainLateJoinIteration::DrillsIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, MeltsIndex) == 0x000004, "Member 'FTerrainLateJoinIteration::MeltsIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, PickAxeIndex) == 0x000008, "Member 'FTerrainLateJoinIteration::PickAxeIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, FloatingIndex) == 0x00000C, "Member 'FTerrainLateJoinIteration::FloatingIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, ColliderCarvesIndex) == 0x000010, "Member 'FTerrainLateJoinIteration::ColliderCarvesIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, MeshCarvesIndex) == 0x000014, "Member 'FTerrainLateJoinIteration::MeshCarvesIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, ExplosionsIndex) == 0x000018, "Member 'FTerrainLateJoinIteration::ExplosionsIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, SplineIndex) == 0x00001C, "Member 'FTerrainLateJoinIteration::SplineIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, CSGIndex) == 0x000020, "Member 'FTerrainLateJoinIteration::CSGIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, SpawnDebrisIndex) == 0x000024, "Member 'FTerrainLateJoinIteration::SpawnDebrisIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, LateJoinIndex) == 0x000028, "Member 'FTerrainLateJoinIteration::LateJoinIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, DebrisIndex) == 0x00002C, "Member 'FTerrainLateJoinIteration::DebrisIndex' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinIteration, ChunkVisibilityIndex) == 0x000030, "Member 'FTerrainLateJoinIteration::ChunkVisibilityIndex' has a wrong offset!");

// ScriptStruct FSD.GrenadeExplodeOperationData
// 0x0038 (0x0038 - 0x0000)
struct FGrenadeExplodeOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitPos;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalOffset;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalSqueeze;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Noise;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurnThickness;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBulletBurntMaterial;                            // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DissolvePlatforms;                                 // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178B[0x2];                                     // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        OverrideBurntMaterialHandle;                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrenadeExplodeOperationData) == 0x000004, "Wrong alignment on FGrenadeExplodeOperationData");
static_assert(sizeof(FGrenadeExplodeOperationData) == 0x000038, "Wrong size on FGrenadeExplodeOperationData");
static_assert(offsetof(FGrenadeExplodeOperationData, OperationNumber) == 0x000000, "Member 'FGrenadeExplodeOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, HitPos) == 0x000004, "Member 'FGrenadeExplodeOperationData::HitPos' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, Normal) == 0x000010, "Member 'FGrenadeExplodeOperationData::Normal' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, NormalOffset) == 0x00001C, "Member 'FGrenadeExplodeOperationData::NormalOffset' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, NormalSqueeze) == 0x000020, "Member 'FGrenadeExplodeOperationData::NormalSqueeze' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, Radius) == 0x000024, "Member 'FGrenadeExplodeOperationData::Radius' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, Noise) == 0x000028, "Member 'FGrenadeExplodeOperationData::Noise' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, BurnThickness) == 0x00002C, "Member 'FGrenadeExplodeOperationData::BurnThickness' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, UseBulletBurntMaterial) == 0x000030, "Member 'FGrenadeExplodeOperationData::UseBulletBurntMaterial' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, DissolvePlatforms) == 0x000031, "Member 'FGrenadeExplodeOperationData::DissolvePlatforms' has a wrong offset!");
static_assert(offsetof(FGrenadeExplodeOperationData, OverrideBurntMaterialHandle) == 0x000034, "Member 'FGrenadeExplodeOperationData::OverrideBurntMaterialHandle' has a wrong offset!");

// ScriptStruct FSD.SplineSegmentCarveOperationData
// 0x0030 (0x0030 - 0x0000)
struct FSplineSegmentCarveOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178C[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCarveSplineSegment>            Segments;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTerrainMaterial*                       Material;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECarveFilterType                              CarveFilter;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPreciousMaterialOptions                      Precious;                                          // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178D[0x6];                                     // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelGenerationCarverComponent*        LevelGenerationComponent;                          // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineSegmentCarveOperationData) == 0x000008, "Wrong alignment on FSplineSegmentCarveOperationData");
static_assert(sizeof(FSplineSegmentCarveOperationData) == 0x000030, "Wrong size on FSplineSegmentCarveOperationData");
static_assert(offsetof(FSplineSegmentCarveOperationData, OperationNumber) == 0x000000, "Member 'FSplineSegmentCarveOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FSplineSegmentCarveOperationData, Segments) == 0x000008, "Member 'FSplineSegmentCarveOperationData::Segments' has a wrong offset!");
static_assert(offsetof(FSplineSegmentCarveOperationData, Material) == 0x000018, "Member 'FSplineSegmentCarveOperationData::Material' has a wrong offset!");
static_assert(offsetof(FSplineSegmentCarveOperationData, CarveFilter) == 0x000020, "Member 'FSplineSegmentCarveOperationData::CarveFilter' has a wrong offset!");
static_assert(offsetof(FSplineSegmentCarveOperationData, Precious) == 0x000021, "Member 'FSplineSegmentCarveOperationData::Precious' has a wrong offset!");
static_assert(offsetof(FSplineSegmentCarveOperationData, LevelGenerationComponent) == 0x000028, "Member 'FSplineSegmentCarveOperationData::LevelGenerationComponent' has a wrong offset!");

// ScriptStruct FSD.CarveWithColliderOperationData
// 0x0070 (0x0070 - 0x0000)
struct FCarveWithColliderOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178E[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainMaterial*                       Material;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECarveFilterType                              CarveFilter;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178F[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrixWithExactSync                   Transform;                                         // 0x001C(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1790[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelGenerationCarverComponent*        LevelGenerationComponent;                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpensiveNoise;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPreciousMaterialOptions                      Precious;                                          // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECarveOptionsCellSize                         CarveCellSize;                                     // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1791[0x2];                                     // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCarveWithColliderOperationData) == 0x000008, "Wrong alignment on FCarveWithColliderOperationData");
static_assert(sizeof(FCarveWithColliderOperationData) == 0x000070, "Wrong size on FCarveWithColliderOperationData");
static_assert(offsetof(FCarveWithColliderOperationData, OperationNumber) == 0x000000, "Member 'FCarveWithColliderOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, StaticMesh) == 0x000008, "Member 'FCarveWithColliderOperationData::StaticMesh' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, Material) == 0x000010, "Member 'FCarveWithColliderOperationData::Material' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, CarveFilter) == 0x000018, "Member 'FCarveWithColliderOperationData::CarveFilter' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, Transform) == 0x00001C, "Member 'FCarveWithColliderOperationData::Transform' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, LevelGenerationComponent) == 0x000060, "Member 'FCarveWithColliderOperationData::LevelGenerationComponent' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, ExpensiveNoise) == 0x000068, "Member 'FCarveWithColliderOperationData::ExpensiveNoise' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, Precious) == 0x00006C, "Member 'FCarveWithColliderOperationData::Precious' has a wrong offset!");
static_assert(offsetof(FCarveWithColliderOperationData, CarveCellSize) == 0x00006D, "Member 'FCarveWithColliderOperationData::CarveCellSize' has a wrong offset!");

// ScriptStruct FSD.RemoveFloatingIslandOperationData
// 0x0004 (0x0004 - 0x0000)
struct FRemoveFloatingIslandOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRemoveFloatingIslandOperationData) == 0x000004, "Wrong alignment on FRemoveFloatingIslandOperationData");
static_assert(sizeof(FRemoveFloatingIslandOperationData) == 0x000004, "Wrong size on FRemoveFloatingIslandOperationData");
static_assert(offsetof(FRemoveFloatingIslandOperationData, OperationNumber) == 0x000000, "Member 'FRemoveFloatingIslandOperationData::OperationNumber' has a wrong offset!");

// ScriptStruct FSD.DrillOperationData
// 0x002C (0x002C - 0x0000)
struct FDrillOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitPos;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Dir;                                               // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CarveSize;                                         // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarveNoise;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDrillOperationData) == 0x000004, "Wrong alignment on FDrillOperationData");
static_assert(sizeof(FDrillOperationData) == 0x00002C, "Wrong size on FDrillOperationData");
static_assert(offsetof(FDrillOperationData, OperationNumber) == 0x000000, "Member 'FDrillOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FDrillOperationData, HitPos) == 0x000004, "Member 'FDrillOperationData::HitPos' has a wrong offset!");
static_assert(offsetof(FDrillOperationData, Dir) == 0x000010, "Member 'FDrillOperationData::Dir' has a wrong offset!");
static_assert(offsetof(FDrillOperationData, CarveSize) == 0x00001C, "Member 'FDrillOperationData::CarveSize' has a wrong offset!");
static_assert(offsetof(FDrillOperationData, CarveNoise) == 0x000028, "Member 'FDrillOperationData::CarveNoise' has a wrong offset!");

// ScriptStruct FSD.MeltOperationData
// 0x0020 (0x0020 - 0x0000)
struct FMeltOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1792[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Points;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1793[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeltOperationData) == 0x000008, "Wrong alignment on FMeltOperationData");
static_assert(sizeof(FMeltOperationData) == 0x000020, "Wrong size on FMeltOperationData");
static_assert(offsetof(FMeltOperationData, OperationNumber) == 0x000000, "Member 'FMeltOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FMeltOperationData, Points) == 0x000008, "Member 'FMeltOperationData::Points' has a wrong offset!");
static_assert(offsetof(FMeltOperationData, Radius) == 0x000018, "Member 'FMeltOperationData::Radius' has a wrong offset!");

// ScriptStruct FSD.CSGBuildOperationData
// 0x0060 (0x0060 - 0x0000)
struct FCSGBuildOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1794[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACSGBuilder>                CSGModel;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBakeSettings                          CarverSettings;                                    // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FMatrixWithExactSync                   Transform;                                         // 0x0020(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCSGBuildOperationData) == 0x000008, "Wrong alignment on FCSGBuildOperationData");
static_assert(sizeof(FCSGBuildOperationData) == 0x000060, "Wrong size on FCSGBuildOperationData");
static_assert(offsetof(FCSGBuildOperationData, OperationNumber) == 0x000000, "Member 'FCSGBuildOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FCSGBuildOperationData, CSGModel) == 0x000008, "Member 'FCSGBuildOperationData::CSGModel' has a wrong offset!");
static_assert(offsetof(FCSGBuildOperationData, CarverSettings) == 0x000010, "Member 'FCSGBuildOperationData::CarverSettings' has a wrong offset!");
static_assert(offsetof(FCSGBuildOperationData, Transform) == 0x000020, "Member 'FCSGBuildOperationData::Transform' has a wrong offset!");

// ScriptStruct FSD.TerrainSpawnDebrisOperationData
// 0x0020 (0x0020 - 0x0000)
struct FTerrainSpawnDebrisOperationData final
{
public:
	int32                                         OperationNumber;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1795[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebrisMesh*                            Debris;                                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainSpawnDebrisOperationData) == 0x000008, "Wrong alignment on FTerrainSpawnDebrisOperationData");
static_assert(sizeof(FTerrainSpawnDebrisOperationData) == 0x000020, "Wrong size on FTerrainSpawnDebrisOperationData");
static_assert(offsetof(FTerrainSpawnDebrisOperationData, OperationNumber) == 0x000000, "Member 'FTerrainSpawnDebrisOperationData::OperationNumber' has a wrong offset!");
static_assert(offsetof(FTerrainSpawnDebrisOperationData, Pos) == 0x000004, "Member 'FTerrainSpawnDebrisOperationData::Pos' has a wrong offset!");
static_assert(offsetof(FTerrainSpawnDebrisOperationData, Radius) == 0x000010, "Member 'FTerrainSpawnDebrisOperationData::Radius' has a wrong offset!");
static_assert(offsetof(FTerrainSpawnDebrisOperationData, Debris) == 0x000018, "Member 'FTerrainSpawnDebrisOperationData::Debris' has a wrong offset!");

// ScriptStruct FSD.TerrainLateJoinData
// 0x00C8 (0x00C8 - 0x0000)
struct FTerrainLateJoinData final
{
public:
	TArray<struct FGrenadeExplodeOperationData>   Explosions;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FCarveWithColliderOperationData> ColliderCarves;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FCarveWithSTLMeshOperationData> MeshCarves;                                        // 0x0020(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FPickaxeDigOperationData>       PickAxe;                                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FRemoveFloatingIslandOperationData> RemoveFloating;                                    // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FDrillOperationData>            Drills;                                            // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FMeltOperationData>             Melts;                                             // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSplineSegmentCarveOperationData> Splines;                                           // 0x0070(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FCSGBuildOperationData>         CSGBuilds;                                         // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTerrainSpawnDebrisOperationData> SpawnDebris;                                       // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 DebrisInstanceComponentPairs;                      // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<uint32>                                VisibleChunks;                                     // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         OperationCount;                                    // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1796[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainLateJoinData) == 0x000008, "Wrong alignment on FTerrainLateJoinData");
static_assert(sizeof(FTerrainLateJoinData) == 0x0000C8, "Wrong size on FTerrainLateJoinData");
static_assert(offsetof(FTerrainLateJoinData, Explosions) == 0x000000, "Member 'FTerrainLateJoinData::Explosions' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, ColliderCarves) == 0x000010, "Member 'FTerrainLateJoinData::ColliderCarves' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, MeshCarves) == 0x000020, "Member 'FTerrainLateJoinData::MeshCarves' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, PickAxe) == 0x000030, "Member 'FTerrainLateJoinData::PickAxe' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, RemoveFloating) == 0x000040, "Member 'FTerrainLateJoinData::RemoveFloating' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, Drills) == 0x000050, "Member 'FTerrainLateJoinData::Drills' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, Melts) == 0x000060, "Member 'FTerrainLateJoinData::Melts' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, Splines) == 0x000070, "Member 'FTerrainLateJoinData::Splines' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, CSGBuilds) == 0x000080, "Member 'FTerrainLateJoinData::CSGBuilds' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, SpawnDebris) == 0x000090, "Member 'FTerrainLateJoinData::SpawnDebris' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, DebrisInstanceComponentPairs) == 0x0000A0, "Member 'FTerrainLateJoinData::DebrisInstanceComponentPairs' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, VisibleChunks) == 0x0000B0, "Member 'FTerrainLateJoinData::VisibleChunks' has a wrong offset!");
static_assert(offsetof(FTerrainLateJoinData, OperationCount) == 0x0000C0, "Member 'FTerrainLateJoinData::OperationCount' has a wrong offset!");

// ScriptStruct FSD.Rotator_NoQuantize
// 0x0000 (0x000C - 0x000C)
struct FRotator_NoQuantize final : public FRotator
{
};
static_assert(alignof(FRotator_NoQuantize) == 0x000004, "Wrong alignment on FRotator_NoQuantize");
static_assert(sizeof(FRotator_NoQuantize) == 0x00000C, "Wrong size on FRotator_NoQuantize");

// ScriptStruct FSD.RoomBox
// 0x0030 (0x0030 - 0x0000)
struct FRoomBox final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator_NoQuantize                    Rotation;                                          // 0x000C(0x000C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Extends;                                           // 0x0018(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseRange;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloodFillSettings*                     Noise;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomBox) == 0x000008, "Wrong alignment on FRoomBox");
static_assert(sizeof(FRoomBox) == 0x000030, "Wrong size on FRoomBox");
static_assert(offsetof(FRoomBox, Position) == 0x000000, "Member 'FRoomBox::Position' has a wrong offset!");
static_assert(offsetof(FRoomBox, Rotation) == 0x00000C, "Member 'FRoomBox::Rotation' has a wrong offset!");
static_assert(offsetof(FRoomBox, Extends) == 0x000018, "Member 'FRoomBox::Extends' has a wrong offset!");
static_assert(offsetof(FRoomBox, NoiseRange) == 0x000024, "Member 'FRoomBox::NoiseRange' has a wrong offset!");
static_assert(offsetof(FRoomBox, Noise) == 0x000028, "Member 'FRoomBox::Noise' has a wrong offset!");

// ScriptStruct FSD.GDItemCategoryIDs
// 0x0040 (0x0040 - 0x0000)
struct FGDItemCategoryIDs final
{
public:
	class UCategoryID*                            OverclockID;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCategoryID*                            ItemSkinID;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCategoryID*                            VanityID;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCategoryID*                            PickaxePartID;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCategoryID*                            WeaponID;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCategoryID*                            CraftingID;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCategoryID*                            ForgeID;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCategoryID*                            BoscoSkinID;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDItemCategoryIDs) == 0x000008, "Wrong alignment on FGDItemCategoryIDs");
static_assert(sizeof(FGDItemCategoryIDs) == 0x000040, "Wrong size on FGDItemCategoryIDs");
static_assert(offsetof(FGDItemCategoryIDs, OverclockID) == 0x000000, "Member 'FGDItemCategoryIDs::OverclockID' has a wrong offset!");
static_assert(offsetof(FGDItemCategoryIDs, ItemSkinID) == 0x000008, "Member 'FGDItemCategoryIDs::ItemSkinID' has a wrong offset!");
static_assert(offsetof(FGDItemCategoryIDs, VanityID) == 0x000010, "Member 'FGDItemCategoryIDs::VanityID' has a wrong offset!");
static_assert(offsetof(FGDItemCategoryIDs, PickaxePartID) == 0x000018, "Member 'FGDItemCategoryIDs::PickaxePartID' has a wrong offset!");
static_assert(offsetof(FGDItemCategoryIDs, WeaponID) == 0x000020, "Member 'FGDItemCategoryIDs::WeaponID' has a wrong offset!");
static_assert(offsetof(FGDItemCategoryIDs, CraftingID) == 0x000028, "Member 'FGDItemCategoryIDs::CraftingID' has a wrong offset!");
static_assert(offsetof(FGDItemCategoryIDs, ForgeID) == 0x000030, "Member 'FGDItemCategoryIDs::ForgeID' has a wrong offset!");
static_assert(offsetof(FGDItemCategoryIDs, BoscoSkinID) == 0x000038, "Member 'FGDItemCategoryIDs::BoscoSkinID' has a wrong offset!");

// ScriptStruct FSD.AvoidActorEntry
// 0x0010 (0x0010 - 0x0000)
struct FAvoidActorEntry final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1797[0x8];                                     // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvoidActorEntry) == 0x000008, "Wrong alignment on FAvoidActorEntry");
static_assert(sizeof(FAvoidActorEntry) == 0x000010, "Wrong size on FAvoidActorEntry");
static_assert(offsetof(FAvoidActorEntry, Actor) == 0x000000, "Member 'FAvoidActorEntry::Actor' has a wrong offset!");

// ScriptStruct FSD.RoomItem
// 0x0020 (0x0020 - 0x0000)
struct FRoomItem final
{
public:
	TSubclassOf<class AActor>                     Spawnable;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator_NoQuantize                    Rotation;                                          // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomItem) == 0x000008, "Wrong alignment on FRoomItem");
static_assert(sizeof(FRoomItem) == 0x000020, "Wrong size on FRoomItem");
static_assert(offsetof(FRoomItem, Spawnable) == 0x000000, "Member 'FRoomItem::Spawnable' has a wrong offset!");
static_assert(offsetof(FRoomItem, Location) == 0x000008, "Member 'FRoomItem::Location' has a wrong offset!");
static_assert(offsetof(FRoomItem, Rotation) == 0x000014, "Member 'FRoomItem::Rotation' has a wrong offset!");

// ScriptStruct FSD.DialogStruct
// 0x0058 (0x0058 - 0x0000)
struct FDialogStruct final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1798[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Audio;                                             // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogRestriction                            Restriction;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1799[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weigth;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValidEntry;                                     // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179A[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogStruct) == 0x000008, "Wrong alignment on FDialogStruct");
static_assert(sizeof(FDialogStruct) == 0x000058, "Wrong size on FDialogStruct");
static_assert(offsetof(FDialogStruct, Enabled) == 0x000000, "Member 'FDialogStruct::Enabled' has a wrong offset!");
static_assert(offsetof(FDialogStruct, Text) == 0x000008, "Member 'FDialogStruct::Text' has a wrong offset!");
static_assert(offsetof(FDialogStruct, Audio) == 0x000020, "Member 'FDialogStruct::Audio' has a wrong offset!");
static_assert(offsetof(FDialogStruct, Restriction) == 0x000048, "Member 'FDialogStruct::Restriction' has a wrong offset!");
static_assert(offsetof(FDialogStruct, Weigth) == 0x00004C, "Member 'FDialogStruct::Weigth' has a wrong offset!");
static_assert(offsetof(FDialogStruct, bIsValidEntry) == 0x000050, "Member 'FDialogStruct::bIsValidEntry' has a wrong offset!");

// ScriptStruct FSD.PartyAnalyticsInformation
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FPartyAnalyticsInformation final
{
public:
	uint8                                         Pad_179B[0x14];                                    // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartyAnalyticsInformation) == 0x000004, "Wrong alignment on FPartyAnalyticsInformation");
static_assert(sizeof(FPartyAnalyticsInformation) == 0x000014, "Wrong size on FPartyAnalyticsInformation");

// ScriptStruct FSD.VeteranComposition
// 0x0020 (0x0020 - 0x0000)
struct FVeteranComposition final
{
public:
	struct FRandFloatInterval                     Normal;                                            // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FRandFloatInterval                     Large;                                             // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVeteranComposition) == 0x000008, "Wrong alignment on FVeteranComposition");
static_assert(sizeof(FVeteranComposition) == 0x000020, "Wrong size on FVeteranComposition");
static_assert(offsetof(FVeteranComposition, Normal) == 0x000000, "Member 'FVeteranComposition::Normal' has a wrong offset!");
static_assert(offsetof(FVeteranComposition, Large) == 0x000010, "Member 'FVeteranComposition::Large' has a wrong offset!");

// ScriptStruct FSD.DiscordFactionRoleRequest
// 0x0028 (0x0028 - 0x0000)
struct FDiscordFactionRoleRequest final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FactionID;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179C[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SteamTicket;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordFactionRoleRequest) == 0x000008, "Wrong alignment on FDiscordFactionRoleRequest");
static_assert(sizeof(FDiscordFactionRoleRequest) == 0x000028, "Wrong size on FDiscordFactionRoleRequest");
static_assert(offsetof(FDiscordFactionRoleRequest, UserId) == 0x000000, "Member 'FDiscordFactionRoleRequest::UserId' has a wrong offset!");
static_assert(offsetof(FDiscordFactionRoleRequest, FactionID) == 0x000010, "Member 'FDiscordFactionRoleRequest::FactionID' has a wrong offset!");
static_assert(offsetof(FDiscordFactionRoleRequest, SteamTicket) == 0x000018, "Member 'FDiscordFactionRoleRequest::SteamTicket' has a wrong offset!");

// ScriptStruct FSD.RoomLinePoint
// 0x0030 (0x0030 - 0x0000)
struct FRoomLinePoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HRange;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VRange;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CielingNoiseRange;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallNoiseRange;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorNoiseRange;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cielingheight;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightScale;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorDepth;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorAngle;                                        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomLinePoint) == 0x000004, "Wrong alignment on FRoomLinePoint");
static_assert(sizeof(FRoomLinePoint) == 0x000030, "Wrong size on FRoomLinePoint");
static_assert(offsetof(FRoomLinePoint, Location) == 0x000000, "Member 'FRoomLinePoint::Location' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, HRange) == 0x00000C, "Member 'FRoomLinePoint::HRange' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, VRange) == 0x000010, "Member 'FRoomLinePoint::VRange' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, CielingNoiseRange) == 0x000014, "Member 'FRoomLinePoint::CielingNoiseRange' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, WallNoiseRange) == 0x000018, "Member 'FRoomLinePoint::WallNoiseRange' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, FloorNoiseRange) == 0x00001C, "Member 'FRoomLinePoint::FloorNoiseRange' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, Cielingheight) == 0x000020, "Member 'FRoomLinePoint::Cielingheight' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, HeightScale) == 0x000024, "Member 'FRoomLinePoint::HeightScale' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, FloorDepth) == 0x000028, "Member 'FRoomLinePoint::FloorDepth' has a wrong offset!");
static_assert(offsetof(FRoomLinePoint, FloorAngle) == 0x00002C, "Member 'FRoomLinePoint::FloorAngle' has a wrong offset!");

// ScriptStruct FSD.DiscordEoMData
// 0x0020 (0x0020 - 0x0000)
struct FDiscordEoMData final
{
public:
	class FString                                 Nick;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordEoMData) == 0x000008, "Wrong alignment on FDiscordEoMData");
static_assert(sizeof(FDiscordEoMData) == 0x000020, "Wrong size on FDiscordEoMData");
static_assert(offsetof(FDiscordEoMData, Nick) == 0x000000, "Member 'FDiscordEoMData::Nick' has a wrong offset!");
static_assert(offsetof(FDiscordEoMData, UserId) == 0x000010, "Member 'FDiscordEoMData::UserId' has a wrong offset!");

// ScriptStruct FSD.DiscordServerInviteGuildData
// 0x0060 (0x0060 - 0x0000)
struct FDiscordServerInviteGuildData final
{
public:
	class FString                                 banner;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Icon;                                              // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Splash;                                            // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordServerInviteGuildData) == 0x000008, "Wrong alignment on FDiscordServerInviteGuildData");
static_assert(sizeof(FDiscordServerInviteGuildData) == 0x000060, "Wrong size on FDiscordServerInviteGuildData");
static_assert(offsetof(FDiscordServerInviteGuildData, banner) == 0x000000, "Member 'FDiscordServerInviteGuildData::banner' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteGuildData, Icon) == 0x000010, "Member 'FDiscordServerInviteGuildData::Icon' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteGuildData, Splash) == 0x000020, "Member 'FDiscordServerInviteGuildData::Splash' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteGuildData, ID) == 0x000030, "Member 'FDiscordServerInviteGuildData::ID' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteGuildData, Name) == 0x000040, "Member 'FDiscordServerInviteGuildData::Name' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteGuildData, Description) == 0x000050, "Member 'FDiscordServerInviteGuildData::Description' has a wrong offset!");

// ScriptStruct FSD.DiscordServerInviteData
// 0x0078 (0x0078 - 0x0000)
struct FDiscordServerInviteData final
{
public:
	class FString                                 Code;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Approximate_presence_count;                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Approximate_member_count;                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDiscordServerInviteGuildData          Guild;                                             // 0x0018(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordServerInviteData) == 0x000008, "Wrong alignment on FDiscordServerInviteData");
static_assert(sizeof(FDiscordServerInviteData) == 0x000078, "Wrong size on FDiscordServerInviteData");
static_assert(offsetof(FDiscordServerInviteData, Code) == 0x000000, "Member 'FDiscordServerInviteData::Code' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteData, Approximate_presence_count) == 0x000010, "Member 'FDiscordServerInviteData::Approximate_presence_count' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteData, Approximate_member_count) == 0x000014, "Member 'FDiscordServerInviteData::Approximate_member_count' has a wrong offset!");
static_assert(offsetof(FDiscordServerInviteData, Guild) == 0x000018, "Member 'FDiscordServerInviteData::Guild' has a wrong offset!");

// ScriptStruct FSD.PathObstacle
// 0x0010 (0x0010 - 0x0000)
struct FPathObstacle final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathObstacle) == 0x000004, "Wrong alignment on FPathObstacle");
static_assert(sizeof(FPathObstacle) == 0x000010, "Wrong size on FPathObstacle");
static_assert(offsetof(FPathObstacle, Position) == 0x000000, "Member 'FPathObstacle::Position' has a wrong offset!");
static_assert(offsetof(FPathObstacle, Radius) == 0x00000C, "Member 'FPathObstacle::Radius' has a wrong offset!");

// ScriptStruct FSD.DiscordRewardNotification
// 0x0040 (0x0040 - 0x0000)
struct FDiscordRewardNotification final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColor;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordRewardNotification) == 0x000008, "Wrong alignment on FDiscordRewardNotification");
static_assert(sizeof(FDiscordRewardNotification) == 0x000040, "Wrong size on FDiscordRewardNotification");
static_assert(offsetof(FDiscordRewardNotification, Text) == 0x000000, "Member 'FDiscordRewardNotification::Text' has a wrong offset!");
static_assert(offsetof(FDiscordRewardNotification, Icon) == 0x000018, "Member 'FDiscordRewardNotification::Icon' has a wrong offset!");
static_assert(offsetof(FDiscordRewardNotification, IconColor) == 0x000020, "Member 'FDiscordRewardNotification::IconColor' has a wrong offset!");
static_assert(offsetof(FDiscordRewardNotification, ID) == 0x000030, "Member 'FDiscordRewardNotification::ID' has a wrong offset!");

// ScriptStruct FSD.DoubleDrillDamageItem
// 0x0038 (0x0038 - 0x0000)
struct FDoubleDrillDamageItem final
{
public:
	TWeakObjectPtr<class UPrimitiveComponent>     Target;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x0008(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0014(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFSDPhysicalMaterial*                   Material;                                          // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BoneIndex;                                         // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179D[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDoubleDrillDamageItem) == 0x000008, "Wrong alignment on FDoubleDrillDamageItem");
static_assert(sizeof(FDoubleDrillDamageItem) == 0x000038, "Wrong size on FDoubleDrillDamageItem");
static_assert(offsetof(FDoubleDrillDamageItem, Target) == 0x000000, "Member 'FDoubleDrillDamageItem::Target' has a wrong offset!");
static_assert(offsetof(FDoubleDrillDamageItem, Location) == 0x000008, "Member 'FDoubleDrillDamageItem::Location' has a wrong offset!");
static_assert(offsetof(FDoubleDrillDamageItem, Normal) == 0x000014, "Member 'FDoubleDrillDamageItem::Normal' has a wrong offset!");
static_assert(offsetof(FDoubleDrillDamageItem, Material) == 0x000020, "Member 'FDoubleDrillDamageItem::Material' has a wrong offset!");
static_assert(offsetof(FDoubleDrillDamageItem, BoneName) == 0x000028, "Member 'FDoubleDrillDamageItem::BoneName' has a wrong offset!");
static_assert(offsetof(FDoubleDrillDamageItem, BoneIndex) == 0x000030, "Member 'FDoubleDrillDamageItem::BoneIndex' has a wrong offset!");

// ScriptStruct FSD.DeathIntroSettings
// 0x0024 (0x0024 - 0x0000)
struct FDeathIntroSettings final
{
public:
	uint8                                         Pad_179E[0x4];                                     // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstPersonDuration;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeToBlackDelay;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeToBlackDuration;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeFromBlackDelay;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeFromBlackDuration;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutDuration;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutStartDistance;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179F[0x4];                                     // 0x0020(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeathIntroSettings) == 0x000004, "Wrong alignment on FDeathIntroSettings");
static_assert(sizeof(FDeathIntroSettings) == 0x000024, "Wrong size on FDeathIntroSettings");
static_assert(offsetof(FDeathIntroSettings, FirstPersonDuration) == 0x000004, "Member 'FDeathIntroSettings::FirstPersonDuration' has a wrong offset!");
static_assert(offsetof(FDeathIntroSettings, FadeToBlackDelay) == 0x000008, "Member 'FDeathIntroSettings::FadeToBlackDelay' has a wrong offset!");
static_assert(offsetof(FDeathIntroSettings, FadeToBlackDuration) == 0x00000C, "Member 'FDeathIntroSettings::FadeToBlackDuration' has a wrong offset!");
static_assert(offsetof(FDeathIntroSettings, FadeFromBlackDelay) == 0x000010, "Member 'FDeathIntroSettings::FadeFromBlackDelay' has a wrong offset!");
static_assert(offsetof(FDeathIntroSettings, FadeFromBlackDuration) == 0x000014, "Member 'FDeathIntroSettings::FadeFromBlackDuration' has a wrong offset!");
static_assert(offsetof(FDeathIntroSettings, ZoomOutDuration) == 0x000018, "Member 'FDeathIntroSettings::ZoomOutDuration' has a wrong offset!");
static_assert(offsetof(FDeathIntroSettings, ZoomOutStartDistance) == 0x00001C, "Member 'FDeathIntroSettings::ZoomOutStartDistance' has a wrong offset!");

// ScriptStruct FSD.PlayerStatsAnalyticInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FPlayerStatsAnalyticInfo final
{
public:
	uint8                                         Pad_17A0[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStatsAnalyticInfo) == 0x000004, "Wrong alignment on FPlayerStatsAnalyticInfo");
static_assert(sizeof(FPlayerStatsAnalyticInfo) == 0x000010, "Wrong size on FPlayerStatsAnalyticInfo");

// ScriptStruct FSD.JettyBootSetting
// 0x0018 (0x0018 - 0x0000)
struct FJettyBootSetting final
{
public:
	struct FIRandRange                            GateCount;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FIRandRange                            GateSpacing;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FIRandRange                            GateOpeningSize;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJettyBootSetting) == 0x000004, "Wrong alignment on FJettyBootSetting");
static_assert(sizeof(FJettyBootSetting) == 0x000018, "Wrong size on FJettyBootSetting");
static_assert(offsetof(FJettyBootSetting, GateCount) == 0x000000, "Member 'FJettyBootSetting::GateCount' has a wrong offset!");
static_assert(offsetof(FJettyBootSetting, GateSpacing) == 0x000008, "Member 'FJettyBootSetting::GateSpacing' has a wrong offset!");
static_assert(offsetof(FJettyBootSetting, GateOpeningSize) == 0x000010, "Member 'FJettyBootSetting::GateOpeningSize' has a wrong offset!");

// ScriptStruct FSD.WeaponAnalyticInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FWeaponAnalyticInfo final
{
public:
	uint8                                         Pad_17A1[0x60];                                    // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponAnalyticInfo) == 0x000008, "Wrong alignment on FWeaponAnalyticInfo");
static_assert(sizeof(FWeaponAnalyticInfo) == 0x000060, "Wrong size on FWeaponAnalyticInfo");

// ScriptStruct FSD.UserStatsAnalyticInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FUserStatsAnalyticInfo final
{
public:
	uint8                                         Pad_17A2[0x30];                                    // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserStatsAnalyticInfo) == 0x000004, "Wrong alignment on FUserStatsAnalyticInfo");
static_assert(sizeof(FUserStatsAnalyticInfo) == 0x000030, "Wrong size on FUserStatsAnalyticInfo");

// ScriptStruct FSD.DelayedActorSwitchData
// 0x0020 (0x0020 - 0x0000)
struct FDelayedActorSwitchData final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsActive : 1;                                      // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsExternalActor : 1;                               // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsUnEquipCalled : 1;                               // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17A3[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquippedActorData                     Cached;                                            // 0x0010(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDelayedActorSwitchData) == 0x000008, "Wrong alignment on FDelayedActorSwitchData");
static_assert(sizeof(FDelayedActorSwitchData) == 0x000020, "Wrong size on FDelayedActorSwitchData");
static_assert(offsetof(FDelayedActorSwitchData, Actor) == 0x000000, "Member 'FDelayedActorSwitchData::Actor' has a wrong offset!");
static_assert(offsetof(FDelayedActorSwitchData, Cached) == 0x000010, "Member 'FDelayedActorSwitchData::Cached' has a wrong offset!");

// ScriptStruct FSD.MissionAnalyticInfo
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FMissionAnalyticInfo final
{
public:
	uint8                                         Pad_17A4[0x98];                                    // 0x0000(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionAnalyticInfo) == 0x000008, "Wrong alignment on FMissionAnalyticInfo");
static_assert(sizeof(FMissionAnalyticInfo) == 0x000098, "Wrong size on FMissionAnalyticInfo");

// ScriptStruct FSD.QueuedMontage
// 0x0010 (0x0010 - 0x0000)
struct FQueuedMontage final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceUpdate;                                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A5[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQueuedMontage) == 0x000008, "Wrong alignment on FQueuedMontage");
static_assert(sizeof(FQueuedMontage) == 0x000010, "Wrong size on FQueuedMontage");
static_assert(offsetof(FQueuedMontage, Montage) == 0x000000, "Member 'FQueuedMontage::Montage' has a wrong offset!");
static_assert(offsetof(FQueuedMontage, ForceUpdate) == 0x000008, "Member 'FQueuedMontage::ForceUpdate' has a wrong offset!");

// ScriptStruct FSD.EliminationTarget
// 0x0010 (0x0010 - 0x0000)
struct FEliminationTarget final
{
public:
	TArray<class AFSDPawn*>                       Targets;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEliminationTarget) == 0x000008, "Wrong alignment on FEliminationTarget");
static_assert(sizeof(FEliminationTarget) == 0x000010, "Wrong size on FEliminationTarget");
static_assert(offsetof(FEliminationTarget, Targets) == 0x000000, "Member 'FEliminationTarget::Targets' has a wrong offset!");

// ScriptStruct FSD.ManagedEncounterItem
// 0x0010 (0x0010 - 0x0000)
struct FManagedEncounterItem final
{
public:
	class UEnemyDescriptor*                       Descriptor;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A6[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedEncounterItem) == 0x000008, "Wrong alignment on FManagedEncounterItem");
static_assert(sizeof(FManagedEncounterItem) == 0x000010, "Wrong size on FManagedEncounterItem");
static_assert(offsetof(FManagedEncounterItem, Descriptor) == 0x000000, "Member 'FManagedEncounterItem::Descriptor' has a wrong offset!");
static_assert(offsetof(FManagedEncounterItem, Amount) == 0x000008, "Member 'FManagedEncounterItem::Amount' has a wrong offset!");

// ScriptStruct FSD.PrePlacedEncounterItem
// 0x0050 (0x0050 - 0x0000)
struct FPrePlacedEncounterItem final
{
public:
	class UEnemyDescriptor*                       Descriptor;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A7[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Location;                                          // 0x0010(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AEncounterActor*                        EncounterActor;                                    // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A8[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrePlacedEncounterItem) == 0x000010, "Wrong alignment on FPrePlacedEncounterItem");
static_assert(sizeof(FPrePlacedEncounterItem) == 0x000050, "Wrong size on FPrePlacedEncounterItem");
static_assert(offsetof(FPrePlacedEncounterItem, Descriptor) == 0x000000, "Member 'FPrePlacedEncounterItem::Descriptor' has a wrong offset!");
static_assert(offsetof(FPrePlacedEncounterItem, Location) == 0x000010, "Member 'FPrePlacedEncounterItem::Location' has a wrong offset!");
static_assert(offsetof(FPrePlacedEncounterItem, EncounterActor) == 0x000040, "Member 'FPrePlacedEncounterItem::EncounterActor' has a wrong offset!");

// ScriptStruct FSD.EncounterManagerItem
// 0x0050 (0x0050 - 0x0000)
struct FEncounterManagerItem final
{
public:
	TArray<struct FManagedEncounterItem>          ManagedEcnounterItems;                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FPrePlacedEncounterItem>        PrePlacedEncounterItems;                           // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRoom;                                            // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A9[0x17];                                    // 0x0025(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class APawn* Enemy)>           Callback;                                          // 0x003C(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17AA[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterManagerItem) == 0x000008, "Wrong alignment on FEncounterManagerItem");
static_assert(sizeof(FEncounterManagerItem) == 0x000050, "Wrong size on FEncounterManagerItem");
static_assert(offsetof(FEncounterManagerItem, ManagedEcnounterItems) == 0x000000, "Member 'FEncounterManagerItem::ManagedEcnounterItems' has a wrong offset!");
static_assert(offsetof(FEncounterManagerItem, PrePlacedEncounterItems) == 0x000010, "Member 'FEncounterManagerItem::PrePlacedEncounterItems' has a wrong offset!");
static_assert(offsetof(FEncounterManagerItem, ID) == 0x000020, "Member 'FEncounterManagerItem::ID' has a wrong offset!");
static_assert(offsetof(FEncounterManagerItem, IsRoom) == 0x000024, "Member 'FEncounterManagerItem::IsRoom' has a wrong offset!");
static_assert(offsetof(FEncounterManagerItem, Callback) == 0x00003C, "Member 'FEncounterManagerItem::Callback' has a wrong offset!");

// ScriptStruct FSD.ItemSkinOwners
// 0x0010 (0x0010 - 0x0000)
struct FItemSkinOwners final
{
public:
	TArray<class UItemID*>                        Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSkinOwners) == 0x000008, "Wrong alignment on FItemSkinOwners");
static_assert(sizeof(FItemSkinOwners) == 0x000010, "Wrong size on FItemSkinOwners");
static_assert(offsetof(FItemSkinOwners, Items) == 0x000000, "Member 'FItemSkinOwners::Items' has a wrong offset!");

// ScriptStruct FSD.LightStrobeChannel
// 0x00D0 (0x00D0 - 0x0000)
struct FLightStrobeChannel final
{
public:
	TWeakObjectPtr<class UPointLightComponent>    Light;                                             // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMaterialInstanceDynamic> Mid;                                               // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          Mesh;                                              // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIntensity;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIntensity;                                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScale;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17AB[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaterialMultiplier;                                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17AC[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     StrobingCurve;                                     // 0x0038(0x0088)(Edit, NativeAccessSpecifierPublic)
	EStrobingMode                                 Mode;                                              // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStrobeMaterialMode                           MaterialMode;                                      // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17AD[0x2];                                     // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Loops;                                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17AE[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightStrobeChannel) == 0x000008, "Wrong alignment on FLightStrobeChannel");
static_assert(sizeof(FLightStrobeChannel) == 0x0000D0, "Wrong size on FLightStrobeChannel");
static_assert(offsetof(FLightStrobeChannel, Light) == 0x000000, "Member 'FLightStrobeChannel::Light' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, Mid) == 0x000008, "Member 'FLightStrobeChannel::Mid' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, Mesh) == 0x000010, "Member 'FLightStrobeChannel::Mesh' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, ParamName) == 0x000018, "Member 'FLightStrobeChannel::ParamName' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, MinIntensity) == 0x000020, "Member 'FLightStrobeChannel::MinIntensity' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, MaxIntensity) == 0x000024, "Member 'FLightStrobeChannel::MaxIntensity' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, TimeScale) == 0x000028, "Member 'FLightStrobeChannel::TimeScale' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, MaterialMultiplier) == 0x000030, "Member 'FLightStrobeChannel::MaterialMultiplier' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, StrobingCurve) == 0x000038, "Member 'FLightStrobeChannel::StrobingCurve' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, Mode) == 0x0000C0, "Member 'FLightStrobeChannel::Mode' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, MaterialMode) == 0x0000C1, "Member 'FLightStrobeChannel::MaterialMode' has a wrong offset!");
static_assert(offsetof(FLightStrobeChannel, Loops) == 0x0000C4, "Member 'FLightStrobeChannel::Loops' has a wrong offset!");

// ScriptStruct FSD.EncounterSpecialItem
// 0x0010 (0x0010 - 0x0000)
struct FEncounterSpecialItem final
{
public:
	class UEnemyDescriptor*                       Enemy;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseChance;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSpawnInDeepDive;                                // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17AF[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterSpecialItem) == 0x000008, "Wrong alignment on FEncounterSpecialItem");
static_assert(sizeof(FEncounterSpecialItem) == 0x000010, "Wrong size on FEncounterSpecialItem");
static_assert(offsetof(FEncounterSpecialItem, Enemy) == 0x000000, "Member 'FEncounterSpecialItem::Enemy' has a wrong offset!");
static_assert(offsetof(FEncounterSpecialItem, BaseChance) == 0x000008, "Member 'FEncounterSpecialItem::BaseChance' has a wrong offset!");
static_assert(offsetof(FEncounterSpecialItem, CanSpawnInDeepDive) == 0x00000C, "Member 'FEncounterSpecialItem::CanSpawnInDeepDive' has a wrong offset!");

// ScriptStruct FSD.EncounterRareCritterItem
// 0x0010 (0x0010 - 0x0000)
struct FEncounterRareCritterItem final
{
public:
	class URareCritterDescriptor*                 Critter;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B0[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterRareCritterItem) == 0x000008, "Wrong alignment on FEncounterRareCritterItem");
static_assert(sizeof(FEncounterRareCritterItem) == 0x000010, "Wrong size on FEncounterRareCritterItem");
static_assert(offsetof(FEncounterRareCritterItem, Critter) == 0x000000, "Member 'FEncounterRareCritterItem::Critter' has a wrong offset!");
static_assert(offsetof(FEncounterRareCritterItem, Chance) == 0x000008, "Member 'FEncounterRareCritterItem::Chance' has a wrong offset!");

// ScriptStruct FSD.SpriteRect
// 0x0010 (0x0010 - 0x0000)
struct FSpriteRect final
{
public:
	float                                         Left;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Right;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bottom;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpriteRect) == 0x000004, "Wrong alignment on FSpriteRect");
static_assert(sizeof(FSpriteRect) == 0x000010, "Wrong size on FSpriteRect");
static_assert(offsetof(FSpriteRect, Left) == 0x000000, "Member 'FSpriteRect::Left' has a wrong offset!");
static_assert(offsetof(FSpriteRect, Top) == 0x000004, "Member 'FSpriteRect::Top' has a wrong offset!");
static_assert(offsetof(FSpriteRect, Right) == 0x000008, "Member 'FSpriteRect::Right' has a wrong offset!");
static_assert(offsetof(FSpriteRect, Bottom) == 0x00000C, "Member 'FSpriteRect::Bottom' has a wrong offset!");

// ScriptStruct FSD.GliderAnimSync
// 0x0020 (0x0020 - 0x0000)
struct FGliderAnimSync final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimAlphaSync;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityPercent;                                   // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DownUpBlendBool;                                   // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RightLeftBlendBool;                                // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B1[0x2];                                     // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalAddBlend;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalAddBlend;                                // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGliderAnimSync) == 0x000004, "Wrong alignment on FGliderAnimSync");
static_assert(sizeof(FGliderAnimSync) == 0x000020, "Wrong size on FGliderAnimSync");
static_assert(offsetof(FGliderAnimSync, Time) == 0x000000, "Member 'FGliderAnimSync::Time' has a wrong offset!");
static_assert(offsetof(FGliderAnimSync, AnimAlphaSync) == 0x000004, "Member 'FGliderAnimSync::AnimAlphaSync' has a wrong offset!");
static_assert(offsetof(FGliderAnimSync, VelocityPercent) == 0x000008, "Member 'FGliderAnimSync::VelocityPercent' has a wrong offset!");
static_assert(offsetof(FGliderAnimSync, DownUpBlendBool) == 0x000014, "Member 'FGliderAnimSync::DownUpBlendBool' has a wrong offset!");
static_assert(offsetof(FGliderAnimSync, RightLeftBlendBool) == 0x000015, "Member 'FGliderAnimSync::RightLeftBlendBool' has a wrong offset!");
static_assert(offsetof(FGliderAnimSync, VerticalAddBlend) == 0x000018, "Member 'FGliderAnimSync::VerticalAddBlend' has a wrong offset!");
static_assert(offsetof(FGliderAnimSync, HorizontalAddBlend) == 0x00001C, "Member 'FGliderAnimSync::HorizontalAddBlend' has a wrong offset!");

// ScriptStruct FSD.EnemyDebris
// 0x0018 (0x0018 - 0x0000)
struct FEnemyDebris final
{
public:
	float                                         InfluenceRange;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B2[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDebrisBase*>                    Debris;                                            // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyDebris) == 0x000008, "Wrong alignment on FEnemyDebris");
static_assert(sizeof(FEnemyDebris) == 0x000018, "Wrong size on FEnemyDebris");
static_assert(offsetof(FEnemyDebris, InfluenceRange) == 0x000000, "Member 'FEnemyDebris::InfluenceRange' has a wrong offset!");
static_assert(offsetof(FEnemyDebris, Debris) == 0x000008, "Member 'FEnemyDebris::Debris' has a wrong offset!");

// ScriptStruct FSD.LaserPointerData
// 0x0060 (0x0060 - 0x0000)
struct FLaserPointerData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELaserPointerTargetType                       TargetType;                                        // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B3[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SavegameID;                                        // 0x004C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B4[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLaserPointerData) == 0x000008, "Wrong alignment on FLaserPointerData");
static_assert(sizeof(FLaserPointerData) == 0x000060, "Wrong size on FLaserPointerData");
static_assert(offsetof(FLaserPointerData, Name) == 0x000000, "Member 'FLaserPointerData::Name' has a wrong offset!");
static_assert(offsetof(FLaserPointerData, Description) == 0x000018, "Member 'FLaserPointerData::Description' has a wrong offset!");
static_assert(offsetof(FLaserPointerData, Color) == 0x000030, "Member 'FLaserPointerData::Color' has a wrong offset!");
static_assert(offsetof(FLaserPointerData, Icon) == 0x000040, "Member 'FLaserPointerData::Icon' has a wrong offset!");
static_assert(offsetof(FLaserPointerData, TargetType) == 0x000048, "Member 'FLaserPointerData::TargetType' has a wrong offset!");
static_assert(offsetof(FLaserPointerData, SavegameID) == 0x00004C, "Member 'FLaserPointerData::SavegameID' has a wrong offset!");

// ScriptStruct FSD.SpawnRarityItem
// 0x0008 (0x0008 - 0x0000)
struct FSpawnRarityItem final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rarity;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnRarityItem) == 0x000004, "Wrong alignment on FSpawnRarityItem");
static_assert(sizeof(FSpawnRarityItem) == 0x000008, "Wrong size on FSpawnRarityItem");
static_assert(offsetof(FSpawnRarityItem, Duration) == 0x000000, "Member 'FSpawnRarityItem::Duration' has a wrong offset!");
static_assert(offsetof(FSpawnRarityItem, Rarity) == 0x000004, "Member 'FSpawnRarityItem::Rarity' has a wrong offset!");

// ScriptStruct FSD.EnemyGroupDescriptorItem
// 0x0008 (0x0008 - 0x0000)
struct FEnemyGroupDescriptorItem final
{
public:
	class UEnemyDescriptor*                       EnemyDescriptor;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyGroupDescriptorItem) == 0x000008, "Wrong alignment on FEnemyGroupDescriptorItem");
static_assert(sizeof(FEnemyGroupDescriptorItem) == 0x000008, "Wrong size on FEnemyGroupDescriptorItem");
static_assert(offsetof(FEnemyGroupDescriptorItem, EnemyDescriptor) == 0x000000, "Member 'FEnemyGroupDescriptorItem::EnemyDescriptor' has a wrong offset!");

// ScriptStruct FSD.ProgressShout
// 0x0010 (0x0010 - 0x0000)
struct FProgressShout final
{
public:
	float                                         ProgressStamp;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B5[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDialogDataAsset*                       Shout;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressShout) == 0x000008, "Wrong alignment on FProgressShout");
static_assert(sizeof(FProgressShout) == 0x000010, "Wrong size on FProgressShout");
static_assert(offsetof(FProgressShout, ProgressStamp) == 0x000000, "Member 'FProgressShout::ProgressStamp' has a wrong offset!");
static_assert(offsetof(FProgressShout, Shout) == 0x000008, "Member 'FProgressShout::Shout' has a wrong offset!");

// ScriptStruct FSD.EnemyGroupDescriptorSpawnItem
// 0x0010 (0x0010 - 0x0000)
struct FEnemyGroupDescriptorSpawnItem final
{
public:
	class UEnemyDescriptor*                       Enemy;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B6[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyGroupDescriptorSpawnItem) == 0x000008, "Wrong alignment on FEnemyGroupDescriptorSpawnItem");
static_assert(sizeof(FEnemyGroupDescriptorSpawnItem) == 0x000010, "Wrong size on FEnemyGroupDescriptorSpawnItem");
static_assert(offsetof(FEnemyGroupDescriptorSpawnItem, Enemy) == 0x000000, "Member 'FEnemyGroupDescriptorSpawnItem::Enemy' has a wrong offset!");
static_assert(offsetof(FEnemyGroupDescriptorSpawnItem, Count) == 0x000008, "Member 'FEnemyGroupDescriptorSpawnItem::Count' has a wrong offset!");

// ScriptStruct FSD.EnemyAttackDescription
// 0x0020 (0x0020 - 0x0000)
struct FEnemyAttackDescription final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EEnemyAttackType                              Range;                                             // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   DamageType;                                        // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B7[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyAttackDescription) == 0x000008, "Wrong alignment on FEnemyAttackDescription");
static_assert(sizeof(FEnemyAttackDescription) == 0x000020, "Wrong size on FEnemyAttackDescription");
static_assert(offsetof(FEnemyAttackDescription, Name) == 0x000000, "Member 'FEnemyAttackDescription::Name' has a wrong offset!");
static_assert(offsetof(FEnemyAttackDescription, Range) == 0x000018, "Member 'FEnemyAttackDescription::Range' has a wrong offset!");
static_assert(offsetof(FEnemyAttackDescription, DamageType) == 0x000019, "Member 'FEnemyAttackDescription::DamageType' has a wrong offset!");

// ScriptStruct FSD.LineSegmentFillerPoint
// 0x0024 (0x0024 - 0x0000)
struct FLineSegmentFillerPoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandRange                             RandomRange;                                       // 0x000C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRandRange                             RandomNoiseRange;                                  // 0x0014(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRandRange                             FillAmount;                                        // 0x001C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLineSegmentFillerPoint) == 0x000004, "Wrong alignment on FLineSegmentFillerPoint");
static_assert(sizeof(FLineSegmentFillerPoint) == 0x000024, "Wrong size on FLineSegmentFillerPoint");
static_assert(offsetof(FLineSegmentFillerPoint, Position) == 0x000000, "Member 'FLineSegmentFillerPoint::Position' has a wrong offset!");
static_assert(offsetof(FLineSegmentFillerPoint, RandomRange) == 0x00000C, "Member 'FLineSegmentFillerPoint::RandomRange' has a wrong offset!");
static_assert(offsetof(FLineSegmentFillerPoint, RandomNoiseRange) == 0x000014, "Member 'FLineSegmentFillerPoint::RandomNoiseRange' has a wrong offset!");
static_assert(offsetof(FLineSegmentFillerPoint, FillAmount) == 0x00001C, "Member 'FLineSegmentFillerPoint::FillAmount' has a wrong offset!");

// ScriptStruct FSD.SpawnEffectsArray
// 0x0018 (0x0120 - 0x0108)
struct FSpawnEffectsArray final : public FFastArraySerializer
{
public:
	TArray<struct FSpawnEffectItem>               Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B8[0x8];                                     // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnEffectsArray) == 0x000008, "Wrong alignment on FSpawnEffectsArray");
static_assert(sizeof(FSpawnEffectsArray) == 0x000120, "Wrong size on FSpawnEffectsArray");
static_assert(offsetof(FSpawnEffectsArray, Items) == 0x000108, "Member 'FSpawnEffectsArray::Items' has a wrong offset!");

// ScriptStruct FSD.JettyBootsReplay
// 0x001C (0x001C - 0x0000)
struct FJettyBootsReplay final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         State;                                             // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B9[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Lives;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJettyBootsReplay) == 0x000004, "Wrong alignment on FJettyBootsReplay");
static_assert(sizeof(FJettyBootsReplay) == 0x00001C, "Wrong size on FJettyBootsReplay");
static_assert(offsetof(FJettyBootsReplay, Seed) == 0x000000, "Member 'FJettyBootsReplay::Seed' has a wrong offset!");
static_assert(offsetof(FJettyBootsReplay, Position) == 0x000004, "Member 'FJettyBootsReplay::Position' has a wrong offset!");
static_assert(offsetof(FJettyBootsReplay, State) == 0x00000C, "Member 'FJettyBootsReplay::State' has a wrong offset!");
static_assert(offsetof(FJettyBootsReplay, Level) == 0x000010, "Member 'FJettyBootsReplay::Level' has a wrong offset!");
static_assert(offsetof(FJettyBootsReplay, Score) == 0x000014, "Member 'FJettyBootsReplay::Score' has a wrong offset!");
static_assert(offsetof(FJettyBootsReplay, Lives) == 0x000018, "Member 'FJettyBootsReplay::Lives' has a wrong offset!");

// ScriptStruct FSD.SpawnQueueItem
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FSpawnQueueItem final
{
public:
	TSoftClassPtr<class UClass>                   EnemyClass;                                        // 0x0000(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnemyDescriptor*                       Enemy;                                             // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class APawn* Enemy)>           Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BA[0x40];                                    // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnQueueItem) == 0x000010, "Wrong alignment on FSpawnQueueItem");
static_assert(sizeof(FSpawnQueueItem) == 0x000080, "Wrong size on FSpawnQueueItem");
static_assert(offsetof(FSpawnQueueItem, EnemyClass) == 0x000000, "Member 'FSpawnQueueItem::EnemyClass' has a wrong offset!");
static_assert(offsetof(FSpawnQueueItem, Enemy) == 0x000028, "Member 'FSpawnQueueItem::Enemy' has a wrong offset!");
static_assert(offsetof(FSpawnQueueItem, Callback) == 0x000030, "Member 'FSpawnQueueItem::Callback' has a wrong offset!");

// ScriptStruct FSD.MUSTBEHERETOCOMPILE
// 0x0001 (0x0001 - 0x0000)
struct FMUSTBEHERETOCOMPILE final
{
public:
	uint8                                         Pad_17BB[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMUSTBEHERETOCOMPILE) == 0x000001, "Wrong alignment on FMUSTBEHERETOCOMPILE");
static_assert(sizeof(FMUSTBEHERETOCOMPILE) == 0x000001, "Wrong size on FMUSTBEHERETOCOMPILE");

// ScriptStruct FSD.EscortMuleMovementState
// 0x0050 (0x0050 - 0x0000)
struct FEscortMuleMovementState final
{
public:
	struct FTransform                             TargetTransform;                                   // 0x0000(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BC[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  AngularVelocity;                                   // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEscortMuleMovementState) == 0x000010, "Wrong alignment on FEscortMuleMovementState");
static_assert(sizeof(FEscortMuleMovementState) == 0x000050, "Wrong size on FEscortMuleMovementState");
static_assert(offsetof(FEscortMuleMovementState, TargetTransform) == 0x000000, "Member 'FEscortMuleMovementState::TargetTransform' has a wrong offset!");
static_assert(offsetof(FEscortMuleMovementState, Velocity) == 0x000030, "Member 'FEscortMuleMovementState::Velocity' has a wrong offset!");
static_assert(offsetof(FEscortMuleMovementState, AngularVelocity) == 0x000040, "Member 'FEscortMuleMovementState::AngularVelocity' has a wrong offset!");

// ScriptStruct FSD.GDDamageClasses
// 0x0060 (0x0060 - 0x0000)
struct FGDDamageClasses final
{
public:
	class UDamageClass*                           Falling;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Fire;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Burn;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Heat;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Disintegrate;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Physical;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Kinetic;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Explosive;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Cold;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Ice;                                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Corrosive;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageClass*                           Infectious;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDDamageClasses) == 0x000008, "Wrong alignment on FGDDamageClasses");
static_assert(sizeof(FGDDamageClasses) == 0x000060, "Wrong size on FGDDamageClasses");
static_assert(offsetof(FGDDamageClasses, Falling) == 0x000000, "Member 'FGDDamageClasses::Falling' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Fire) == 0x000008, "Member 'FGDDamageClasses::Fire' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Burn) == 0x000010, "Member 'FGDDamageClasses::Burn' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Heat) == 0x000018, "Member 'FGDDamageClasses::Heat' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Disintegrate) == 0x000020, "Member 'FGDDamageClasses::Disintegrate' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Physical) == 0x000028, "Member 'FGDDamageClasses::Physical' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Kinetic) == 0x000030, "Member 'FGDDamageClasses::Kinetic' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Explosive) == 0x000038, "Member 'FGDDamageClasses::Explosive' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Cold) == 0x000040, "Member 'FGDDamageClasses::Cold' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Ice) == 0x000048, "Member 'FGDDamageClasses::Ice' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Corrosive) == 0x000050, "Member 'FGDDamageClasses::Corrosive' has a wrong offset!");
static_assert(offsetof(FGDDamageClasses, Infectious) == 0x000058, "Member 'FGDDamageClasses::Infectious' has a wrong offset!");

// ScriptStruct FSD.EscortMuleExtractorSlot
// 0x0020 (0x0020 - 0x0000)
struct FEscortMuleExtractorSlot final
{
public:
	EEscortExtractorState                         ExtractorState;                                    // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEscortExtractorState                         LastState;                                         // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BD[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachPoint;                                       // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstantUsable*                         Usable;                                            // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       Widget;                                            // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEscortMuleExtractorSlot) == 0x000008, "Wrong alignment on FEscortMuleExtractorSlot");
static_assert(sizeof(FEscortMuleExtractorSlot) == 0x000020, "Wrong size on FEscortMuleExtractorSlot");
static_assert(offsetof(FEscortMuleExtractorSlot, ExtractorState) == 0x000000, "Member 'FEscortMuleExtractorSlot::ExtractorState' has a wrong offset!");
static_assert(offsetof(FEscortMuleExtractorSlot, LastState) == 0x000001, "Member 'FEscortMuleExtractorSlot::LastState' has a wrong offset!");
static_assert(offsetof(FEscortMuleExtractorSlot, AttachPoint) == 0x000008, "Member 'FEscortMuleExtractorSlot::AttachPoint' has a wrong offset!");
static_assert(offsetof(FEscortMuleExtractorSlot, Usable) == 0x000010, "Member 'FEscortMuleExtractorSlot::Usable' has a wrong offset!");
static_assert(offsetof(FEscortMuleExtractorSlot, Widget) == 0x000018, "Member 'FEscortMuleExtractorSlot::Widget' has a wrong offset!");

// ScriptStruct FSD.EscortMulePath
// 0x0018 (0x0018 - 0x0000)
struct FEscortMulePath final
{
public:
	TArray<struct FVector>                        Path;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BE[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEscortMulePath) == 0x000008, "Wrong alignment on FEscortMulePath");
static_assert(sizeof(FEscortMulePath) == 0x000018, "Wrong size on FEscortMulePath");
static_assert(offsetof(FEscortMulePath, Path) == 0x000000, "Member 'FEscortMulePath::Path' has a wrong offset!");

// ScriptStruct FSD.GDGameStatsTracking
// 0x0020 (0x0020 - 0x0000)
struct FGDGameStatsTracking final
{
public:
	struct FGameplayTagContainer                  TotalEnemyKillsFilter;                             // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDGameStatsTracking) == 0x000008, "Wrong alignment on FGDGameStatsTracking");
static_assert(sizeof(FGDGameStatsTracking) == 0x000020, "Wrong size on FGDGameStatsTracking");
static_assert(offsetof(FGDGameStatsTracking, TotalEnemyKillsFilter) == 0x000000, "Member 'FGDGameStatsTracking::TotalEnemyKillsFilter' has a wrong offset!");

// ScriptStruct FSD.FSDDeepDiveResponse
// 0x0018 (0x0018 - 0x0000)
struct FFSDDeepDiveResponse final
{
public:
	uint32                                        SeedV2;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BF[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExpirationTime;                                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDDeepDiveResponse) == 0x000008, "Wrong alignment on FFSDDeepDiveResponse");
static_assert(sizeof(FFSDDeepDiveResponse) == 0x000018, "Wrong size on FFSDDeepDiveResponse");
static_assert(offsetof(FFSDDeepDiveResponse, SeedV2) == 0x000000, "Member 'FFSDDeepDiveResponse::SeedV2' has a wrong offset!");
static_assert(offsetof(FFSDDeepDiveResponse, ExpirationTime) == 0x000008, "Member 'FFSDDeepDiveResponse::ExpirationTime' has a wrong offset!");

// ScriptStruct FSD.SoftMissionStepDescription
// 0x0058 (0x0058 - 0x0000)
struct FSoftMissionStepDescription final
{
public:
	class FText                                   Headline;                                          // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RichDescription;                                   // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftMissionStepDescription) == 0x000008, "Wrong alignment on FSoftMissionStepDescription");
static_assert(sizeof(FSoftMissionStepDescription) == 0x000058, "Wrong size on FSoftMissionStepDescription");
static_assert(offsetof(FSoftMissionStepDescription, Headline) == 0x000000, "Member 'FSoftMissionStepDescription::Headline' has a wrong offset!");
static_assert(offsetof(FSoftMissionStepDescription, RichDescription) == 0x000018, "Member 'FSoftMissionStepDescription::RichDescription' has a wrong offset!");
static_assert(offsetof(FSoftMissionStepDescription, Image) == 0x000030, "Member 'FSoftMissionStepDescription::Image' has a wrong offset!");

// ScriptStruct FSD.BackendNotification
// 0x0050 (0x0050 - 0x0000)
struct FBackendNotification final
{
public:
	class FString                                 Platform;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Header;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageType;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Link;                                              // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBackendNotification) == 0x000008, "Wrong alignment on FBackendNotification");
static_assert(sizeof(FBackendNotification) == 0x000050, "Wrong size on FBackendNotification");
static_assert(offsetof(FBackendNotification, Platform) == 0x000000, "Member 'FBackendNotification::Platform' has a wrong offset!");
static_assert(offsetof(FBackendNotification, Header) == 0x000010, "Member 'FBackendNotification::Header' has a wrong offset!");
static_assert(offsetof(FBackendNotification, Message) == 0x000020, "Member 'FBackendNotification::Message' has a wrong offset!");
static_assert(offsetof(FBackendNotification, MessageType) == 0x000030, "Member 'FBackendNotification::MessageType' has a wrong offset!");
static_assert(offsetof(FBackendNotification, Link) == 0x000040, "Member 'FBackendNotification::Link' has a wrong offset!");

// ScriptStruct FSD.FSDEventsResponse
// 0x0020 (0x0020 - 0x0000)
struct FFSDEventsResponse final
{
public:
	TArray<struct FBackendNotification>           Notifications;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFSDEventWithEnd>               ActiveEventsWithEnd;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDEventsResponse) == 0x000008, "Wrong alignment on FFSDEventsResponse");
static_assert(sizeof(FFSDEventsResponse) == 0x000020, "Wrong size on FFSDEventsResponse");
static_assert(offsetof(FFSDEventsResponse, Notifications) == 0x000000, "Member 'FFSDEventsResponse::Notifications' has a wrong offset!");
static_assert(offsetof(FFSDEventsResponse, ActiveEventsWithEnd) == 0x000010, "Member 'FFSDEventsResponse::ActiveEventsWithEnd' has a wrong offset!");

// ScriptStruct FSD.SubObjective
// 0x0030 (0x0030 - 0x0000)
struct FSubObjective final
{
public:
	class UDialogDataAsset*                       OnProgressShout;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       OnCompletedShout;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveText;                                     // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Required;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubObjective) == 0x000008, "Wrong alignment on FSubObjective");
static_assert(sizeof(FSubObjective) == 0x000030, "Wrong size on FSubObjective");
static_assert(offsetof(FSubObjective, OnProgressShout) == 0x000000, "Member 'FSubObjective::OnProgressShout' has a wrong offset!");
static_assert(offsetof(FSubObjective, OnCompletedShout) == 0x000008, "Member 'FSubObjective::OnCompletedShout' has a wrong offset!");
static_assert(offsetof(FSubObjective, ObjectiveText) == 0x000010, "Member 'FSubObjective::ObjectiveText' has a wrong offset!");
static_assert(offsetof(FSubObjective, Required) == 0x000028, "Member 'FSubObjective::Required' has a wrong offset!");
static_assert(offsetof(FSubObjective, Count) == 0x00002C, "Member 'FSubObjective::Count' has a wrong offset!");

// ScriptStruct FSD.SoftIconWithColor
// 0x0038 (0x0038 - 0x0000)
struct FSoftIconWithColor final
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftIconWithColor) == 0x000008, "Wrong alignment on FSoftIconWithColor");
static_assert(sizeof(FSoftIconWithColor) == 0x000038, "Wrong size on FSoftIconWithColor");
static_assert(offsetof(FSoftIconWithColor, Icon) == 0x000000, "Member 'FSoftIconWithColor::Icon' has a wrong offset!");
static_assert(offsetof(FSoftIconWithColor, Tint) == 0x000028, "Member 'FSoftIconWithColor::Tint' has a wrong offset!");

// ScriptStruct FSD.DamageTypeDescription
// 0x0078 (0x0078 - 0x0000)
struct FDamageTypeDescription final
{
public:
	EDamageType                                   Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C0[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RichDescription;                                   // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftIconWithColor                     Icon;                                              // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         IconScale;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C1[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageTypeDescription) == 0x000008, "Wrong alignment on FDamageTypeDescription");
static_assert(sizeof(FDamageTypeDescription) == 0x000078, "Wrong size on FDamageTypeDescription");
static_assert(offsetof(FDamageTypeDescription, Type) == 0x000000, "Member 'FDamageTypeDescription::Type' has a wrong offset!");
static_assert(offsetof(FDamageTypeDescription, Name) == 0x000008, "Member 'FDamageTypeDescription::Name' has a wrong offset!");
static_assert(offsetof(FDamageTypeDescription, RichDescription) == 0x000020, "Member 'FDamageTypeDescription::RichDescription' has a wrong offset!");
static_assert(offsetof(FDamageTypeDescription, Icon) == 0x000038, "Member 'FDamageTypeDescription::Icon' has a wrong offset!");
static_assert(offsetof(FDamageTypeDescription, IconScale) == 0x000070, "Member 'FDamageTypeDescription::IconScale' has a wrong offset!");

// ScriptStruct FSD.SmartSpawnEntry
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FSmartSpawnEntry final
{
public:
	uint8                                         Pad_17C2[0x18];                                    // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmartSpawnEntry) == 0x000004, "Wrong alignment on FSmartSpawnEntry");
static_assert(sizeof(FSmartSpawnEntry) == 0x000018, "Wrong size on FSmartSpawnEntry");

// ScriptStruct FSD.RandInterval
// 0x0010 (0x0010 - 0x0000)
struct FRandInterval final
{
public:
	TArray<struct FRandIntervalItem>              Intervals;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandInterval) == 0x000008, "Wrong alignment on FRandInterval");
static_assert(sizeof(FRandInterval) == 0x000010, "Wrong size on FRandInterval");
static_assert(offsetof(FRandInterval, Intervals) == 0x000000, "Member 'FRandInterval::Intervals' has a wrong offset!");

// ScriptStruct FSD.FacilityGeneratorEnounter
// 0x0028 (0x0028 - 0x0000)
struct FFacilityGeneratorEnounter final
{
public:
	TArray<class UEnemyDescriptor*>               Enemies;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Difficulty;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C3[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandInterval                          Diversity;                                         // 0x0018(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacilityGeneratorEnounter) == 0x000008, "Wrong alignment on FFacilityGeneratorEnounter");
static_assert(sizeof(FFacilityGeneratorEnounter) == 0x000028, "Wrong size on FFacilityGeneratorEnounter");
static_assert(offsetof(FFacilityGeneratorEnounter, Enemies) == 0x000000, "Member 'FFacilityGeneratorEnounter::Enemies' has a wrong offset!");
static_assert(offsetof(FFacilityGeneratorEnounter, Difficulty) == 0x000010, "Member 'FFacilityGeneratorEnounter::Difficulty' has a wrong offset!");
static_assert(offsetof(FFacilityGeneratorEnounter, Diversity) == 0x000018, "Member 'FFacilityGeneratorEnounter::Diversity' has a wrong offset!");

// ScriptStruct FSD.EnemyMinersManualStats
// 0x000C (0x000C - 0x0000)
struct FEnemyMinersManualStats final
{
public:
	int32                                         Health;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyMinersManualStats) == 0x000004, "Wrong alignment on FEnemyMinersManualStats");
static_assert(sizeof(FEnemyMinersManualStats) == 0x00000C, "Wrong size on FEnemyMinersManualStats");
static_assert(offsetof(FEnemyMinersManualStats, Health) == 0x000000, "Member 'FEnemyMinersManualStats::Health' has a wrong offset!");
static_assert(offsetof(FEnemyMinersManualStats, Damage) == 0x000004, "Member 'FEnemyMinersManualStats::Damage' has a wrong offset!");
static_assert(offsetof(FEnemyMinersManualStats, Speed) == 0x000008, "Member 'FEnemyMinersManualStats::Speed' has a wrong offset!");

// ScriptStruct FSD.XPReward
// 0x0020 (0x0020 - 0x0000)
struct FXPReward final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C4[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXPReward) == 0x000008, "Wrong alignment on FXPReward");
static_assert(sizeof(FXPReward) == 0x000020, "Wrong size on FXPReward");
static_assert(offsetof(FXPReward, Description) == 0x000000, "Member 'FXPReward::Description' has a wrong offset!");
static_assert(offsetof(FXPReward, XP) == 0x000018, "Member 'FXPReward::XP' has a wrong offset!");

// ScriptStruct FSD.FadeData
// 0x0048 (0x0048 - 0x0000)
struct FFadeData final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugOutput;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C5[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFSDLevelLoadingPersistentWidget> WidgetType;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFSDLevelLoadingPersistentWidget*       Widget;                                            // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentFade;                                       // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFade;                                        // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeSpeed;                                         // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeWorldOnly;                                    // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapFramerate;                                     // 0x0029(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToSpaceRig;                                       // 0x002A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C6[0x5];                                     // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               LoadingImage;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugMsg;                                          // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFadeData) == 0x000008, "Wrong alignment on FFadeData");
static_assert(sizeof(FFadeData) == 0x000048, "Wrong size on FFadeData");
static_assert(offsetof(FFadeData, bEnabled) == 0x000000, "Member 'FFadeData::bEnabled' has a wrong offset!");
static_assert(offsetof(FFadeData, bShowDebugOutput) == 0x000001, "Member 'FFadeData::bShowDebugOutput' has a wrong offset!");
static_assert(offsetof(FFadeData, WidgetType) == 0x000008, "Member 'FFadeData::WidgetType' has a wrong offset!");
static_assert(offsetof(FFadeData, Widget) == 0x000010, "Member 'FFadeData::Widget' has a wrong offset!");
static_assert(offsetof(FFadeData, CurrentFade) == 0x000018, "Member 'FFadeData::CurrentFade' has a wrong offset!");
static_assert(offsetof(FFadeData, TargetFade) == 0x00001C, "Member 'FFadeData::TargetFade' has a wrong offset!");
static_assert(offsetof(FFadeData, FadeSpeed) == 0x000020, "Member 'FFadeData::FadeSpeed' has a wrong offset!");
static_assert(offsetof(FFadeData, Delay) == 0x000024, "Member 'FFadeData::Delay' has a wrong offset!");
static_assert(offsetof(FFadeData, bFadeWorldOnly) == 0x000028, "Member 'FFadeData::bFadeWorldOnly' has a wrong offset!");
static_assert(offsetof(FFadeData, bCapFramerate) == 0x000029, "Member 'FFadeData::bCapFramerate' has a wrong offset!");
static_assert(offsetof(FFadeData, bToSpaceRig) == 0x00002A, "Member 'FFadeData::bToSpaceRig' has a wrong offset!");
static_assert(offsetof(FFadeData, LoadingImage) == 0x000030, "Member 'FFadeData::LoadingImage' has a wrong offset!");
static_assert(offsetof(FFadeData, DebugMsg) == 0x000038, "Member 'FFadeData::DebugMsg' has a wrong offset!");

// ScriptStruct FSD.FakeMoverTarget
// 0x001C (0x001C - 0x0000)
struct FFakeMoverTarget final
{
public:
	float                                         InfluenceDistance;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistance;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetCloserAirAcceleration;                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetAwayAirAcceleration;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetCloserGroundAcceleration;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetAwayGroundAcceleration;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFakeMoverTarget) == 0x000004, "Wrong alignment on FFakeMoverTarget");
static_assert(sizeof(FFakeMoverTarget) == 0x00001C, "Wrong size on FFakeMoverTarget");
static_assert(offsetof(FFakeMoverTarget, InfluenceDistance) == 0x000000, "Member 'FFakeMoverTarget::InfluenceDistance' has a wrong offset!");
static_assert(offsetof(FFakeMoverTarget, TargetDistance) == 0x000004, "Member 'FFakeMoverTarget::TargetDistance' has a wrong offset!");
static_assert(offsetof(FFakeMoverTarget, GetCloserAirAcceleration) == 0x000008, "Member 'FFakeMoverTarget::GetCloserAirAcceleration' has a wrong offset!");
static_assert(offsetof(FFakeMoverTarget, GetAwayAirAcceleration) == 0x00000C, "Member 'FFakeMoverTarget::GetAwayAirAcceleration' has a wrong offset!");
static_assert(offsetof(FFakeMoverTarget, GetCloserGroundAcceleration) == 0x000010, "Member 'FFakeMoverTarget::GetCloserGroundAcceleration' has a wrong offset!");
static_assert(offsetof(FFakeMoverTarget, GetAwayGroundAcceleration) == 0x000014, "Member 'FFakeMoverTarget::GetAwayGroundAcceleration' has a wrong offset!");
static_assert(offsetof(FFakeMoverTarget, MinDistance) == 0x000018, "Member 'FFakeMoverTarget::MinDistance' has a wrong offset!");

// ScriptStruct FSD.MissionBiomeItem
// 0x0010 (0x0010 - 0x0000)
struct FMissionBiomeItem final
{
public:
	class UBiome*                                 Biome;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Rarity;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionBiomeItem) == 0x000008, "Wrong alignment on FMissionBiomeItem");
static_assert(sizeof(FMissionBiomeItem) == 0x000010, "Wrong size on FMissionBiomeItem");
static_assert(offsetof(FMissionBiomeItem, Biome) == 0x000000, "Member 'FMissionBiomeItem::Biome' has a wrong offset!");
static_assert(offsetof(FMissionBiomeItem, Rarity) == 0x000008, "Member 'FMissionBiomeItem::Rarity' has a wrong offset!");

// ScriptStruct FSD.FakeMoverPropulsion
// 0x0014 (0x0014 - 0x0000)
struct FFakeMoverPropulsion final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirAcceleration;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDeceleration;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundAcceleration;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDeceleration;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFakeMoverPropulsion) == 0x000004, "Wrong alignment on FFakeMoverPropulsion");
static_assert(sizeof(FFakeMoverPropulsion) == 0x000014, "Wrong size on FFakeMoverPropulsion");
static_assert(offsetof(FFakeMoverPropulsion, Speed) == 0x000000, "Member 'FFakeMoverPropulsion::Speed' has a wrong offset!");
static_assert(offsetof(FFakeMoverPropulsion, AirAcceleration) == 0x000004, "Member 'FFakeMoverPropulsion::AirAcceleration' has a wrong offset!");
static_assert(offsetof(FFakeMoverPropulsion, AirDeceleration) == 0x000008, "Member 'FFakeMoverPropulsion::AirDeceleration' has a wrong offset!");
static_assert(offsetof(FFakeMoverPropulsion, GroundAcceleration) == 0x00000C, "Member 'FFakeMoverPropulsion::GroundAcceleration' has a wrong offset!");
static_assert(offsetof(FFakeMoverPropulsion, GroundDeceleration) == 0x000010, "Member 'FFakeMoverPropulsion::GroundDeceleration' has a wrong offset!");

// ScriptStruct FSD.FlareMeta
// 0x0024 (0x0024 - 0x0000)
struct FFlareMeta final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inhibit;                                           // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvRadius;                                         // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0014(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Moving;                                            // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C8[0x3];                                     // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFlareMeta) == 0x000004, "Wrong alignment on FFlareMeta");
static_assert(sizeof(FFlareMeta) == 0x000024, "Wrong size on FFlareMeta");
static_assert(offsetof(FFlareMeta, Actor) == 0x000000, "Member 'FFlareMeta::Actor' has a wrong offset!");
static_assert(offsetof(FFlareMeta, Inhibit) == 0x000008, "Member 'FFlareMeta::Inhibit' has a wrong offset!");
static_assert(offsetof(FFlareMeta, Radius) == 0x00000C, "Member 'FFlareMeta::Radius' has a wrong offset!");
static_assert(offsetof(FFlareMeta, InvRadius) == 0x000010, "Member 'FFlareMeta::InvRadius' has a wrong offset!");
static_assert(offsetof(FFlareMeta, Pos) == 0x000014, "Member 'FFlareMeta::Pos' has a wrong offset!");
static_assert(offsetof(FFlareMeta, Moving) == 0x000020, "Member 'FFlareMeta::Moving' has a wrong offset!");

// ScriptStruct FSD.GeneratedMissionGroup
// 0x0018 (0x0018 - 0x0000)
struct FGeneratedMissionGroup final
{
public:
	TArray<class UGeneratedMission*>              AvailableMissions;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          OptedOutOfSeasonContent;                           // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C9[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratedMissionGroup) == 0x000008, "Wrong alignment on FGeneratedMissionGroup");
static_assert(sizeof(FGeneratedMissionGroup) == 0x000018, "Wrong size on FGeneratedMissionGroup");
static_assert(offsetof(FGeneratedMissionGroup, AvailableMissions) == 0x000000, "Member 'FGeneratedMissionGroup::AvailableMissions' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionGroup, OptedOutOfSeasonContent) == 0x000010, "Member 'FGeneratedMissionGroup::OptedOutOfSeasonContent' has a wrong offset!");

// ScriptStruct FSD.FloatPerkRankValue
// 0x0008 (0x0008 - 0x0000)
struct FFloatPerkRankValue final
{
public:
	int32                                         RankIndex;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatPerkRankValue) == 0x000004, "Wrong alignment on FFloatPerkRankValue");
static_assert(sizeof(FFloatPerkRankValue) == 0x000008, "Wrong size on FFloatPerkRankValue");
static_assert(offsetof(FFloatPerkRankValue, RankIndex) == 0x000000, "Member 'FFloatPerkRankValue::RankIndex' has a wrong offset!");
static_assert(offsetof(FFloatPerkRankValue, Value) == 0x000004, "Member 'FFloatPerkRankValue::Value' has a wrong offset!");

// ScriptStruct FSD.FloatPerkEffect
// 0x0030 (0x0030 - 0x0000)
struct FFloatPerkEffect final
{
public:
	class UFloatPerkActivation*                   PerkActivation;                                    // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FormattedDescription;                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FFloatPerkRankValue>            RankValues;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatPerkEffect) == 0x000008, "Wrong alignment on FFloatPerkEffect");
static_assert(sizeof(FFloatPerkEffect) == 0x000030, "Wrong size on FFloatPerkEffect");
static_assert(offsetof(FFloatPerkEffect, PerkActivation) == 0x000000, "Member 'FFloatPerkEffect::PerkActivation' has a wrong offset!");
static_assert(offsetof(FFloatPerkEffect, FormattedDescription) == 0x000008, "Member 'FFloatPerkEffect::FormattedDescription' has a wrong offset!");
static_assert(offsetof(FFloatPerkEffect, RankValues) == 0x000020, "Member 'FFloatPerkEffect::RankValues' has a wrong offset!");

// ScriptStruct FSD.FormationDataItem
// 0x0010 (0x0010 - 0x0000)
struct FFormationDataItem final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFormationDataItem) == 0x000004, "Wrong alignment on FFormationDataItem");
static_assert(sizeof(FFormationDataItem) == 0x000010, "Wrong size on FFormationDataItem");
static_assert(offsetof(FFormationDataItem, Direction) == 0x000000, "Member 'FFormationDataItem::Direction' has a wrong offset!");
static_assert(offsetof(FFormationDataItem, Distance) == 0x00000C, "Member 'FFormationDataItem::Distance' has a wrong offset!");

// ScriptStruct FSD.Formation
// 0x0020 (0x0020 - 0x0000)
struct FFormation final
{
public:
	uint8                                         Pad_17CA[0x18];                                    // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFormationData*                         FormationData;                                     // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFormation) == 0x000008, "Wrong alignment on FFormation");
static_assert(sizeof(FFormation) == 0x000020, "Wrong size on FFormation");
static_assert(offsetof(FFormation, FormationData) == 0x000018, "Member 'FFormation::FormationData' has a wrong offset!");

// ScriptStruct FSD.PathDebugNode
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FPathDebugNode final
{
public:
	uint8                                         Pad_17CB[0x20];                                    // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathDebugNode) == 0x000004, "Wrong alignment on FPathDebugNode");
static_assert(sizeof(FPathDebugNode) == 0x000020, "Wrong size on FPathDebugNode");

// ScriptStruct FSD.FormationID
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FFormationID final
{
public:
	uint8                                         Pad_17CC[0x8];                                     // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFormationID) == 0x000004, "Wrong alignment on FFormationID");
static_assert(sizeof(FFormationID) == 0x000008, "Wrong size on FFormationID");

// ScriptStruct FSD.InputDirectionSet
// 0x0020 (0x0020 - 0x0000)
struct FInputDirectionSet final
{
public:
	TArray<EThawInputDirection>                   Directions;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         InputCount;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSequence;                                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17CD[0x3];                                     // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSubsequentDuplicates;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17CE[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputDirectionSet) == 0x000008, "Wrong alignment on FInputDirectionSet");
static_assert(sizeof(FInputDirectionSet) == 0x000020, "Wrong size on FInputDirectionSet");
static_assert(offsetof(FInputDirectionSet, Directions) == 0x000000, "Member 'FInputDirectionSet::Directions' has a wrong offset!");
static_assert(offsetof(FInputDirectionSet, InputCount) == 0x000010, "Member 'FInputDirectionSet::InputCount' has a wrong offset!");
static_assert(offsetof(FInputDirectionSet, IsSequence) == 0x000014, "Member 'FInputDirectionSet::IsSequence' has a wrong offset!");
static_assert(offsetof(FInputDirectionSet, MaxSubsequentDuplicates) == 0x000018, "Member 'FInputDirectionSet::MaxSubsequentDuplicates' has a wrong offset!");

// ScriptStruct FSD.RequiredMissionItem
// 0x0020 (0x0020 - 0x0000)
struct FRequiredMissionItem final
{
public:
	class UMissionTemplate*                       MissionTemplate;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionComplexity*                     Complexity;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionDuration*                       Duration;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanHaveMutators;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17CF[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequiredMissionItem) == 0x000008, "Wrong alignment on FRequiredMissionItem");
static_assert(sizeof(FRequiredMissionItem) == 0x000020, "Wrong size on FRequiredMissionItem");
static_assert(offsetof(FRequiredMissionItem, MissionTemplate) == 0x000000, "Member 'FRequiredMissionItem::MissionTemplate' has a wrong offset!");
static_assert(offsetof(FRequiredMissionItem, Complexity) == 0x000008, "Member 'FRequiredMissionItem::Complexity' has a wrong offset!");
static_assert(offsetof(FRequiredMissionItem, Duration) == 0x000010, "Member 'FRequiredMissionItem::Duration' has a wrong offset!");
static_assert(offsetof(FRequiredMissionItem, CanHaveMutators) == 0x000018, "Member 'FRequiredMissionItem::CanHaveMutators' has a wrong offset!");

// ScriptStruct FSD.DelegateStruct
// 0x0001 (0x0001 - 0x0000)
struct FDelegateStruct final
{
public:
	uint8                                         Pad_17D0[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelegateStruct) == 0x000001, "Wrong alignment on FDelegateStruct");
static_assert(sizeof(FDelegateStruct) == 0x000001, "Wrong size on FDelegateStruct");

// ScriptStruct FSD.FSDTagsRoot
// 0x0018 (0x0018 - 0x0000)
struct FFSDTagsRoot final
{
public:
	struct FFSDTagsAttitude                       Attitude;                                          // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDTagsRoot) == 0x000004, "Wrong alignment on FFSDTagsRoot");
static_assert(sizeof(FFSDTagsRoot) == 0x000018, "Wrong size on FFSDTagsRoot");
static_assert(offsetof(FFSDTagsRoot, Attitude) == 0x000000, "Member 'FFSDTagsRoot::Attitude' has a wrong offset!");

// ScriptStruct FSD.GeneratedMissionSeed
// 0x0058 (0x0058 - 0x0000)
struct FGeneratedMissionSeed final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalSeed;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBiome*                                 Biome;                                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionTemplate*                       Template;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionComplexity*                     ComplexityLimit;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionDuration*                       DurationLimit;                                     // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionMutator*                        Mutator;                                           // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMissionWarning*>                Warnings;                                          // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UFSDEvent*>                      ActiveEvents;                                      // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	EMissionStructure                             MissionStructure;                                  // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D1[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratedMissionSeed) == 0x000008, "Wrong alignment on FGeneratedMissionSeed");
static_assert(sizeof(FGeneratedMissionSeed) == 0x000058, "Wrong size on FGeneratedMissionSeed");
static_assert(offsetof(FGeneratedMissionSeed, Seed) == 0x000000, "Member 'FGeneratedMissionSeed::Seed' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, GlobalSeed) == 0x000004, "Member 'FGeneratedMissionSeed::GlobalSeed' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, Biome) == 0x000008, "Member 'FGeneratedMissionSeed::Biome' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, Template) == 0x000010, "Member 'FGeneratedMissionSeed::Template' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, ComplexityLimit) == 0x000018, "Member 'FGeneratedMissionSeed::ComplexityLimit' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, DurationLimit) == 0x000020, "Member 'FGeneratedMissionSeed::DurationLimit' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, Mutator) == 0x000028, "Member 'FGeneratedMissionSeed::Mutator' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, Warnings) == 0x000030, "Member 'FGeneratedMissionSeed::Warnings' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, ActiveEvents) == 0x000040, "Member 'FGeneratedMissionSeed::ActiveEvents' has a wrong offset!");
static_assert(offsetof(FGeneratedMissionSeed, MissionStructure) == 0x000050, "Member 'FGeneratedMissionSeed::MissionStructure' has a wrong offset!");

// ScriptStruct FSD.ModdingUISettings
// 0x0060 (0x0060 - 0x0000)
struct FModdingUISettings final
{
public:
	uint8                                         SortField;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SortAscending;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D2[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<uint8>                                   ServerFilters;                                     // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShowSandboxLabel;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D3[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModdingUISettings) == 0x000008, "Wrong alignment on FModdingUISettings");
static_assert(sizeof(FModdingUISettings) == 0x000060, "Wrong size on FModdingUISettings");
static_assert(offsetof(FModdingUISettings, SortField) == 0x000000, "Member 'FModdingUISettings::SortField' has a wrong offset!");
static_assert(offsetof(FModdingUISettings, SortAscending) == 0x000001, "Member 'FModdingUISettings::SortAscending' has a wrong offset!");
static_assert(offsetof(FModdingUISettings, ServerFilters) == 0x000008, "Member 'FModdingUISettings::ServerFilters' has a wrong offset!");
static_assert(offsetof(FModdingUISettings, bShowSandboxLabel) == 0x000058, "Member 'FModdingUISettings::bShowSandboxLabel' has a wrong offset!");

// ScriptStruct FSD.FSDPlatformHelper
// 0x0001 (0x0001 - 0x0000)
struct FFSDPlatformHelper final
{
public:
	uint8                                         Pad_17D4[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFSDPlatformHelper) == 0x000001, "Wrong alignment on FFSDPlatformHelper");
static_assert(sizeof(FFSDPlatformHelper) == 0x000001, "Wrong size on FFSDPlatformHelper");

// ScriptStruct FSD.SplineHitResult
// 0x0098 (0x0098 - 0x0000)
struct FSplineHitResult final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SplineDistance;                                    // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SplineTangent;                                     // 0x008C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineHitResult) == 0x000004, "Wrong alignment on FSplineHitResult");
static_assert(sizeof(FSplineHitResult) == 0x000098, "Wrong size on FSplineHitResult");
static_assert(offsetof(FSplineHitResult, HitResult) == 0x000000, "Member 'FSplineHitResult::HitResult' has a wrong offset!");
static_assert(offsetof(FSplineHitResult, SplineDistance) == 0x000088, "Member 'FSplineHitResult::SplineDistance' has a wrong offset!");
static_assert(offsetof(FSplineHitResult, SplineTangent) == 0x00008C, "Member 'FSplineHitResult::SplineTangent' has a wrong offset!");

// ScriptStruct FSD.SplineSegment
// 0x0030 (0x0030 - 0x0000)
struct FSplineSegment final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTangent;                                      // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTangent;                                        // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineSegment) == 0x000004, "Wrong alignment on FSplineSegment");
static_assert(sizeof(FSplineSegment) == 0x000030, "Wrong size on FSplineSegment");
static_assert(offsetof(FSplineSegment, StartLocation) == 0x000000, "Member 'FSplineSegment::StartLocation' has a wrong offset!");
static_assert(offsetof(FSplineSegment, StartTangent) == 0x00000C, "Member 'FSplineSegment::StartTangent' has a wrong offset!");
static_assert(offsetof(FSplineSegment, EndLocation) == 0x000018, "Member 'FSplineSegment::EndLocation' has a wrong offset!");
static_assert(offsetof(FSplineSegment, EndTangent) == 0x000024, "Member 'FSplineSegment::EndTangent' has a wrong offset!");

// ScriptStruct FSD.WidgetMover
// 0x0028 (0x0028 - 0x0000)
struct FWidgetMover final
{
public:
	TWeakObjectPtr<class UWidget>                 Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D5[0x20];                                    // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetMover) == 0x000004, "Wrong alignment on FWidgetMover");
static_assert(sizeof(FWidgetMover) == 0x000028, "Wrong size on FWidgetMover");
static_assert(offsetof(FWidgetMover, Widget) == 0x000000, "Member 'FWidgetMover::Widget' has a wrong offset!");

// ScriptStruct FSD.WidgetPing
// 0x0020 (0x0020 - 0x0000)
struct FWidgetPing final
{
public:
	TWeakObjectPtr<class UWidget>                 Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D6[0x18];                                    // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetPing) == 0x000004, "Wrong alignment on FWidgetPing");
static_assert(sizeof(FWidgetPing) == 0x000020, "Wrong size on FWidgetPing");
static_assert(offsetof(FWidgetPing, Widget) == 0x000000, "Member 'FWidgetPing::Widget' has a wrong offset!");

// ScriptStruct FSD.GVisibilityGroups
// 0x0058 (0x0058 - 0x0000)
struct FGVisibilityGroups final
{
public:
	TSet<class UHUDVisibilityGroup*>              AllGroups;                                         // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UHUDVisibilityGroup*                    EnemyHealth;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGVisibilityGroups) == 0x000008, "Wrong alignment on FGVisibilityGroups");
static_assert(sizeof(FGVisibilityGroups) == 0x000058, "Wrong size on FGVisibilityGroups");
static_assert(offsetof(FGVisibilityGroups, AllGroups) == 0x000000, "Member 'FGVisibilityGroups::AllGroups' has a wrong offset!");
static_assert(offsetof(FGVisibilityGroups, EnemyHealth) == 0x000050, "Member 'FGVisibilityGroups::EnemyHealth' has a wrong offset!");

// ScriptStruct FSD.GDMilestones
// 0x0010 (0x0010 - 0x0000)
struct FGDMilestones final
{
public:
	TArray<class UMilestoneAsset*>                Milestones;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDMilestones) == 0x000008, "Wrong alignment on FGDMilestones");
static_assert(sizeof(FGDMilestones) == 0x000010, "Wrong size on FGDMilestones");
static_assert(offsetof(FGDMilestones, Milestones) == 0x000000, "Member 'FGDMilestones::Milestones' has a wrong offset!");

// ScriptStruct FSD.GDTerrainTypes
// 0x0010 (0x0010 - 0x0000)
struct FGDTerrainTypes final
{
public:
	class UTerrainType*                           Rock;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainType*                           Dirt;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDTerrainTypes) == 0x000008, "Wrong alignment on FGDTerrainTypes");
static_assert(sizeof(FGDTerrainTypes) == 0x000010, "Wrong size on FGDTerrainTypes");
static_assert(offsetof(FGDTerrainTypes, Rock) == 0x000000, "Member 'FGDTerrainTypes::Rock' has a wrong offset!");
static_assert(offsetof(FGDTerrainTypes, Dirt) == 0x000008, "Member 'FGDTerrainTypes::Dirt' has a wrong offset!");

// ScriptStruct FSD.GDAudio
// 0x0050 (0x0050 - 0x0000)
struct FGDAudio final
{
public:
	TSoftObjectPtr<class USoundAttenuation>       FirstPersonHitscanAttenuationOverride;             // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFSDReverbVolume>           ReverbActor;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDynamicReverbComponent>    DynamicReverbClass;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmallCaveRadius;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumCaveRadius;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargeCaveRadius;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPersonPriority;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonPriority;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D7[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGDAudio) == 0x000008, "Wrong alignment on FGDAudio");
static_assert(sizeof(FGDAudio) == 0x000050, "Wrong size on FGDAudio");
static_assert(offsetof(FGDAudio, FirstPersonHitscanAttenuationOverride) == 0x000000, "Member 'FGDAudio::FirstPersonHitscanAttenuationOverride' has a wrong offset!");
static_assert(offsetof(FGDAudio, ReverbActor) == 0x000028, "Member 'FGDAudio::ReverbActor' has a wrong offset!");
static_assert(offsetof(FGDAudio, DynamicReverbClass) == 0x000030, "Member 'FGDAudio::DynamicReverbClass' has a wrong offset!");
static_assert(offsetof(FGDAudio, SmallCaveRadius) == 0x000038, "Member 'FGDAudio::SmallCaveRadius' has a wrong offset!");
static_assert(offsetof(FGDAudio, MediumCaveRadius) == 0x00003C, "Member 'FGDAudio::MediumCaveRadius' has a wrong offset!");
static_assert(offsetof(FGDAudio, LargeCaveRadius) == 0x000040, "Member 'FGDAudio::LargeCaveRadius' has a wrong offset!");
static_assert(offsetof(FGDAudio, FirstPersonPriority) == 0x000044, "Member 'FGDAudio::FirstPersonPriority' has a wrong offset!");
static_assert(offsetof(FGDAudio, ThirdPersonPriority) == 0x000048, "Member 'FGDAudio::ThirdPersonPriority' has a wrong offset!");

// ScriptStruct FSD.GDDifficulty
// 0x0010 (0x0010 - 0x0000)
struct FGDDifficulty final
{
public:
	TArray<class UDifficultySetting*>             DifficultySettings;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGDDifficulty) == 0x000008, "Wrong alignment on FGDDifficulty");
static_assert(sizeof(FGDDifficulty) == 0x000010, "Wrong size on FGDDifficulty");
static_assert(offsetof(FGDDifficulty, DifficultySettings) == 0x000000, "Member 'FGDDifficulty::DifficultySettings' has a wrong offset!");

// ScriptStruct FSD.RoomLine
// 0x0040 (0x0040 - 0x0000)
struct FRoomLine final
{
public:
	class UFloodFillSettings*                     WallNoiseOverride;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloodFillSettings*                     CeilingNoiseOverride;                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloodFillSettings*                     FloorNoiseOverride;                                // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDetailNoise;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D8[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRoomLinePoint>                 Points;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        RightVectors;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomLine) == 0x000008, "Wrong alignment on FRoomLine");
static_assert(sizeof(FRoomLine) == 0x000040, "Wrong size on FRoomLine");
static_assert(offsetof(FRoomLine, WallNoiseOverride) == 0x000000, "Member 'FRoomLine::WallNoiseOverride' has a wrong offset!");
static_assert(offsetof(FRoomLine, CeilingNoiseOverride) == 0x000008, "Member 'FRoomLine::CeilingNoiseOverride' has a wrong offset!");
static_assert(offsetof(FRoomLine, FloorNoiseOverride) == 0x000010, "Member 'FRoomLine::FloorNoiseOverride' has a wrong offset!");
static_assert(offsetof(FRoomLine, UseDetailNoise) == 0x000018, "Member 'FRoomLine::UseDetailNoise' has a wrong offset!");
static_assert(offsetof(FRoomLine, Points) == 0x000020, "Member 'FRoomLine::Points' has a wrong offset!");
static_assert(offsetof(FRoomLine, RightVectors) == 0x000030, "Member 'FRoomLine::RightVectors' has a wrong offset!");

// ScriptStruct FSD.TriggerItem
// 0x0050 (0x0050 - 0x0000)
struct FTriggerItem final
{
public:
	TSubclassOf<class ASpawnTrigger>              TriggerClass;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D9[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Message;                                           // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DA[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTriggerItem) == 0x000010, "Wrong alignment on FTriggerItem");
static_assert(sizeof(FTriggerItem) == 0x000050, "Wrong size on FTriggerItem");
static_assert(offsetof(FTriggerItem, TriggerClass) == 0x000000, "Member 'FTriggerItem::TriggerClass' has a wrong offset!");
static_assert(offsetof(FTriggerItem, Transform) == 0x000010, "Member 'FTriggerItem::Transform' has a wrong offset!");
static_assert(offsetof(FTriggerItem, Message) == 0x000040, "Member 'FTriggerItem::Message' has a wrong offset!");

// ScriptStruct FSD.Pillar
// 0x0020 (0x0020 - 0x0000)
struct FPillar final
{
public:
	class UFloodFillSettings*                     NoiseOverride;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeightedLinePoint>             Points;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         NoiseScale;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndcapScale;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPillar) == 0x000008, "Wrong alignment on FPillar");
static_assert(sizeof(FPillar) == 0x000020, "Wrong size on FPillar");
static_assert(offsetof(FPillar, NoiseOverride) == 0x000000, "Member 'FPillar::NoiseOverride' has a wrong offset!");
static_assert(offsetof(FPillar, Points) == 0x000008, "Member 'FPillar::Points' has a wrong offset!");
static_assert(offsetof(FPillar, NoiseScale) == 0x000018, "Member 'FPillar::NoiseScale' has a wrong offset!");
static_assert(offsetof(FPillar, EndcapScale) == 0x00001C, "Member 'FPillar::EndcapScale' has a wrong offset!");

// ScriptStruct FSD.ResourceLocation
// 0x0020 (0x0020 - 0x0000)
struct FResourceLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DB[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UResourceData*                          Resource;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseAmount;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DC[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResourceLocation) == 0x000008, "Wrong alignment on FResourceLocation");
static_assert(sizeof(FResourceLocation) == 0x000020, "Wrong size on FResourceLocation");
static_assert(offsetof(FResourceLocation, Location) == 0x000000, "Member 'FResourceLocation::Location' has a wrong offset!");
static_assert(offsetof(FResourceLocation, Resource) == 0x000010, "Member 'FResourceLocation::Resource' has a wrong offset!");
static_assert(offsetof(FResourceLocation, BaseAmount) == 0x000018, "Member 'FResourceLocation::BaseAmount' has a wrong offset!");

// ScriptStruct FSD.GeneratedRoom
// 0x0088 (0x0088 - 0x0000)
struct FGeneratedRoom final
{
public:
	class UTerrainMaterial*                       Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRoomLine>                      Lines;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPillar>                        Pillars;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FRoomBox>                       BoxCarvers;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FRoomBox>                       BoxFillers;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FResourceLocation>              ResourceLocations;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FRoomEntrance>                  Entrances;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FRoomItem>                      RoomItems;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTriggerItem>                   TriggerItems;                                      // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneratedRoom) == 0x000008, "Wrong alignment on FGeneratedRoom");
static_assert(sizeof(FGeneratedRoom) == 0x000088, "Wrong size on FGeneratedRoom");
static_assert(offsetof(FGeneratedRoom, Material) == 0x000000, "Member 'FGeneratedRoom::Material' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, Lines) == 0x000008, "Member 'FGeneratedRoom::Lines' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, Pillars) == 0x000018, "Member 'FGeneratedRoom::Pillars' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, BoxCarvers) == 0x000028, "Member 'FGeneratedRoom::BoxCarvers' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, BoxFillers) == 0x000038, "Member 'FGeneratedRoom::BoxFillers' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, ResourceLocations) == 0x000048, "Member 'FGeneratedRoom::ResourceLocations' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, Entrances) == 0x000058, "Member 'FGeneratedRoom::Entrances' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, RoomItems) == 0x000068, "Member 'FGeneratedRoom::RoomItems' has a wrong offset!");
static_assert(offsetof(FGeneratedRoom, TriggerItems) == 0x000078, "Member 'FGeneratedRoom::TriggerItems' has a wrong offset!");

// ScriptStruct FSD.DeepDiveAnalyticsInformation
// 0x000C (0x000C - 0x0000)
struct FDeepDiveAnalyticsInformation final
{
public:
	bool                                          WasDeepDive;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DD[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastDeepDiveStage;                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EliteDeepDive;                                     // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReplay;                                          // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DE[0x2];                                     // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeepDiveAnalyticsInformation) == 0x000004, "Wrong alignment on FDeepDiveAnalyticsInformation");
static_assert(sizeof(FDeepDiveAnalyticsInformation) == 0x00000C, "Wrong size on FDeepDiveAnalyticsInformation");
static_assert(offsetof(FDeepDiveAnalyticsInformation, WasDeepDive) == 0x000000, "Member 'FDeepDiveAnalyticsInformation::WasDeepDive' has a wrong offset!");
static_assert(offsetof(FDeepDiveAnalyticsInformation, LastDeepDiveStage) == 0x000004, "Member 'FDeepDiveAnalyticsInformation::LastDeepDiveStage' has a wrong offset!");
static_assert(offsetof(FDeepDiveAnalyticsInformation, EliteDeepDive) == 0x000008, "Member 'FDeepDiveAnalyticsInformation::EliteDeepDive' has a wrong offset!");
static_assert(offsetof(FDeepDiveAnalyticsInformation, IsReplay) == 0x000009, "Member 'FDeepDiveAnalyticsInformation::IsReplay' has a wrong offset!");

// ScriptStruct FSD.GooPuddleStatusEffectTrigger
// 0x0018 (0x0018 - 0x0000)
struct FGooPuddleStatusEffectTrigger final
{
public:
	TArray<class UDamageClass*>                   Trigger;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UStatusEffect>              NewStatusEffect;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGooPuddleStatusEffectTrigger) == 0x000008, "Wrong alignment on FGooPuddleStatusEffectTrigger");
static_assert(sizeof(FGooPuddleStatusEffectTrigger) == 0x000018, "Wrong size on FGooPuddleStatusEffectTrigger");
static_assert(offsetof(FGooPuddleStatusEffectTrigger, Trigger) == 0x000000, "Member 'FGooPuddleStatusEffectTrigger::Trigger' has a wrong offset!");
static_assert(offsetof(FGooPuddleStatusEffectTrigger, NewStatusEffect) == 0x000010, "Member 'FGooPuddleStatusEffectTrigger::NewStatusEffect' has a wrong offset!");

// ScriptStruct FSD.GrabAvoidClassEntry
// 0x0010 (0x0010 - 0x0000)
struct FGrabAvoidClassEntry final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToKeep;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DF[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGrabAvoidClassEntry) == 0x000008, "Wrong alignment on FGrabAvoidClassEntry");
static_assert(sizeof(FGrabAvoidClassEntry) == 0x000010, "Wrong size on FGrabAvoidClassEntry");
static_assert(offsetof(FGrabAvoidClassEntry, ActorClass) == 0x000000, "Member 'FGrabAvoidClassEntry::ActorClass' has a wrong offset!");
static_assert(offsetof(FGrabAvoidClassEntry, DistanceToKeep) == 0x000008, "Member 'FGrabAvoidClassEntry::DistanceToKeep' has a wrong offset!");

// ScriptStruct FSD.StateStats
// 0x0014 (0x0014 - 0x0000)
struct FStateStats final
{
public:
	float                                         MaxAcceleration;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPawnSpeed;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlowdownAngle;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlowdownAngle;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBreakingDeceleration;                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateStats) == 0x000004, "Wrong alignment on FStateStats");
static_assert(sizeof(FStateStats) == 0x000014, "Wrong size on FStateStats");
static_assert(offsetof(FStateStats, MaxAcceleration) == 0x000000, "Member 'FStateStats::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FStateStats, MaxPawnSpeed) == 0x000004, "Member 'FStateStats::MaxPawnSpeed' has a wrong offset!");
static_assert(offsetof(FStateStats, MinSlowdownAngle) == 0x000008, "Member 'FStateStats::MinSlowdownAngle' has a wrong offset!");
static_assert(offsetof(FStateStats, MaxSlowdownAngle) == 0x00000C, "Member 'FStateStats::MaxSlowdownAngle' has a wrong offset!");
static_assert(offsetof(FStateStats, MaxBreakingDeceleration) == 0x000010, "Member 'FStateStats::MaxBreakingDeceleration' has a wrong offset!");

// ScriptStruct FSD.PitchedUsers
// 0x0020 (0x0020 - 0x0000)
struct FPitchedUsers final
{
public:
	class APlayerCharacter*                       Player;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E0[0x14];                                    // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPitchedUsers) == 0x000008, "Wrong alignment on FPitchedUsers");
static_assert(sizeof(FPitchedUsers) == 0x000020, "Wrong size on FPitchedUsers");
static_assert(offsetof(FPitchedUsers, Player) == 0x000000, "Member 'FPitchedUsers::Player' has a wrong offset!");
static_assert(offsetof(FPitchedUsers, Timer) == 0x000008, "Member 'FPitchedUsers::Timer' has a wrong offset!");

// ScriptStruct FSD.InputDisplay
// 0x0040 (0x0040 - 0x0000)
struct FInputDisplay final
{
public:
	EInputInteraction                             Interaction;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E1[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InputText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextTint;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IconTintable;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E2[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputDisplay) == 0x000008, "Wrong alignment on FInputDisplay");
static_assert(sizeof(FInputDisplay) == 0x000040, "Wrong size on FInputDisplay");
static_assert(offsetof(FInputDisplay, Interaction) == 0x000000, "Member 'FInputDisplay::Interaction' has a wrong offset!");
static_assert(offsetof(FInputDisplay, InputText) == 0x000008, "Member 'FInputDisplay::InputText' has a wrong offset!");
static_assert(offsetof(FInputDisplay, TextTint) == 0x000020, "Member 'FInputDisplay::TextTint' has a wrong offset!");
static_assert(offsetof(FInputDisplay, Icon) == 0x000030, "Member 'FInputDisplay::Icon' has a wrong offset!");
static_assert(offsetof(FInputDisplay, IconTintable) == 0x000038, "Member 'FInputDisplay::IconTintable' has a wrong offset!");

// ScriptStruct FSD.EmitterConnection
// 0x0010 (0x0010 - 0x0000)
struct FEmitterConnection final
{
public:
	class FName                                   EmitterName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VariableName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterConnection) == 0x000004, "Wrong alignment on FEmitterConnection");
static_assert(sizeof(FEmitterConnection) == 0x000010, "Wrong size on FEmitterConnection");
static_assert(offsetof(FEmitterConnection, EmitterName) == 0x000000, "Member 'FEmitterConnection::EmitterName' has a wrong offset!");
static_assert(offsetof(FEmitterConnection, VariableName) == 0x000008, "Member 'FEmitterConnection::VariableName' has a wrong offset!");

// ScriptStruct FSD.GearStatEntry
// 0x0068 (0x0068 - 0x0000)
struct FGearStatEntry final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   Value;                                             // 0x0018(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   BaseValue;                                         // 0x0030(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   UpgradeValue;                                      // 0x0048(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	EItemPreviewStatus                            PreviewStatus;                                     // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E3[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGearStatEntry) == 0x000008, "Wrong alignment on FGearStatEntry");
static_assert(sizeof(FGearStatEntry) == 0x000068, "Wrong size on FGearStatEntry");
static_assert(offsetof(FGearStatEntry, Text) == 0x000000, "Member 'FGearStatEntry::Text' has a wrong offset!");
static_assert(offsetof(FGearStatEntry, Value) == 0x000018, "Member 'FGearStatEntry::Value' has a wrong offset!");
static_assert(offsetof(FGearStatEntry, BaseValue) == 0x000030, "Member 'FGearStatEntry::BaseValue' has a wrong offset!");
static_assert(offsetof(FGearStatEntry, UpgradeValue) == 0x000048, "Member 'FGearStatEntry::UpgradeValue' has a wrong offset!");
static_assert(offsetof(FGearStatEntry, PreviewStatus) == 0x000060, "Member 'FGearStatEntry::PreviewStatus' has a wrong offset!");

// ScriptStruct FSD.JettyBootNPC
// 0x0030 (0x0030 - 0x0000)
struct FJettyBootNPC final
{
public:
	class FString                                 CharacterName;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HasPlayedChance;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIRandRange                            ScoreInterval;                                     // 0x0014(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E4[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StartScores;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJettyBootNPC) == 0x000008, "Wrong alignment on FJettyBootNPC");
static_assert(sizeof(FJettyBootNPC) == 0x000030, "Wrong size on FJettyBootNPC");
static_assert(offsetof(FJettyBootNPC, CharacterName) == 0x000000, "Member 'FJettyBootNPC::CharacterName' has a wrong offset!");
static_assert(offsetof(FJettyBootNPC, HasPlayedChance) == 0x000010, "Member 'FJettyBootNPC::HasPlayedChance' has a wrong offset!");
static_assert(offsetof(FJettyBootNPC, ScoreInterval) == 0x000014, "Member 'FJettyBootNPC::ScoreInterval' has a wrong offset!");
static_assert(offsetof(FJettyBootNPC, StartScores) == 0x000020, "Member 'FJettyBootNPC::StartScores' has a wrong offset!");

// ScriptStruct FSD.JettyBootsPlayer
// 0x000C (0x000C - 0x0000)
struct FJettyBootsPlayer final
{
public:
	TWeakObjectPtr<class APlayerCharacter>        PlayerCharacter;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying;                                        // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E5[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJettyBootsPlayer) == 0x000004, "Wrong alignment on FJettyBootsPlayer");
static_assert(sizeof(FJettyBootsPlayer) == 0x00000C, "Wrong size on FJettyBootsPlayer");
static_assert(offsetof(FJettyBootsPlayer, PlayerCharacter) == 0x000000, "Member 'FJettyBootsPlayer::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FJettyBootsPlayer, bIsPlaying) == 0x000008, "Member 'FJettyBootsPlayer::bIsPlaying' has a wrong offset!");

// ScriptStruct FSD.BumpPlayerHit
// 0x0018 (0x0018 - 0x0000)
struct FBumpPlayerHit final
{
public:
	struct FVector_NetQuantize                    Force;                                             // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E6[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Player;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBumpPlayerHit) == 0x000008, "Wrong alignment on FBumpPlayerHit");
static_assert(sizeof(FBumpPlayerHit) == 0x000018, "Wrong size on FBumpPlayerHit");
static_assert(offsetof(FBumpPlayerHit, Force) == 0x000000, "Member 'FBumpPlayerHit::Force' has a wrong offset!");
static_assert(offsetof(FBumpPlayerHit, Player) == 0x000010, "Member 'FBumpPlayerHit::Player' has a wrong offset!");

// ScriptStruct FSD.LayeredNoise
// 0x0010 (0x0010 - 0x0000)
struct FLayeredNoise final
{
public:
	class UFloodFillSettings*                     Noise;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLayeredNoise) == 0x000008, "Wrong alignment on FLayeredNoise");
static_assert(sizeof(FLayeredNoise) == 0x000010, "Wrong size on FLayeredNoise");
static_assert(offsetof(FLayeredNoise, Noise) == 0x000000, "Member 'FLayeredNoise::Noise' has a wrong offset!");
static_assert(offsetof(FLayeredNoise, Scale) == 0x000008, "Member 'FLayeredNoise::Scale' has a wrong offset!");

// ScriptStruct FSD.LineSegmentCarverPoint
// 0x0024 (0x0024 - 0x0000)
struct FLineSegmentCarverPoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HRange;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VRange;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorAngle;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CielingNoiseRange;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallNoiseRange;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorNoiseRange;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLineSegmentCarverPoint) == 0x000004, "Wrong alignment on FLineSegmentCarverPoint");
static_assert(sizeof(FLineSegmentCarverPoint) == 0x000024, "Wrong size on FLineSegmentCarverPoint");
static_assert(offsetof(FLineSegmentCarverPoint, Position) == 0x000000, "Member 'FLineSegmentCarverPoint::Position' has a wrong offset!");
static_assert(offsetof(FLineSegmentCarverPoint, HRange) == 0x00000C, "Member 'FLineSegmentCarverPoint::HRange' has a wrong offset!");
static_assert(offsetof(FLineSegmentCarverPoint, VRange) == 0x000010, "Member 'FLineSegmentCarverPoint::VRange' has a wrong offset!");
static_assert(offsetof(FLineSegmentCarverPoint, FloorAngle) == 0x000014, "Member 'FLineSegmentCarverPoint::FloorAngle' has a wrong offset!");
static_assert(offsetof(FLineSegmentCarverPoint, CielingNoiseRange) == 0x000018, "Member 'FLineSegmentCarverPoint::CielingNoiseRange' has a wrong offset!");
static_assert(offsetof(FLineSegmentCarverPoint, WallNoiseRange) == 0x00001C, "Member 'FLineSegmentCarverPoint::WallNoiseRange' has a wrong offset!");
static_assert(offsetof(FLineSegmentCarverPoint, FloorNoiseRange) == 0x000020, "Member 'FLineSegmentCarverPoint::FloorNoiseRange' has a wrong offset!");

// ScriptStruct FSD.FSDTranslationProgress
// 0x0018 (0x0018 - 0x0000)
struct FFSDTranslationProgress final
{
public:
	class FString                                 CodeName;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslatedPercent;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E8[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFSDTranslationProgress) == 0x000008, "Wrong alignment on FFSDTranslationProgress");
static_assert(sizeof(FFSDTranslationProgress) == 0x000018, "Wrong size on FFSDTranslationProgress");
static_assert(offsetof(FFSDTranslationProgress, CodeName) == 0x000000, "Member 'FFSDTranslationProgress::CodeName' has a wrong offset!");
static_assert(offsetof(FFSDTranslationProgress, TranslatedPercent) == 0x000010, "Member 'FFSDTranslationProgress::TranslatedPercent' has a wrong offset!");

// ScriptStruct FSD.BeamCollision
// 0x00C8 (0x00C8 - 0x0000)
struct alignas(0x08) FBeamCollision final
{
public:
	bool                                          bBeamBlocked;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17E9[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeamHitDistance;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalTraceStart;                                   // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FinalTraceEnd;                                     // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17EA[0xA8];                                    // 0x0020(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBeamCollision) == 0x000008, "Wrong alignment on FBeamCollision");
static_assert(sizeof(FBeamCollision) == 0x0000C8, "Wrong size on FBeamCollision");
static_assert(offsetof(FBeamCollision, bBeamBlocked) == 0x000000, "Member 'FBeamCollision::bBeamBlocked' has a wrong offset!");
static_assert(offsetof(FBeamCollision, BeamHitDistance) == 0x000004, "Member 'FBeamCollision::BeamHitDistance' has a wrong offset!");
static_assert(offsetof(FBeamCollision, FinalTraceStart) == 0x000008, "Member 'FBeamCollision::FinalTraceStart' has a wrong offset!");
static_assert(offsetof(FBeamCollision, FinalTraceEnd) == 0x000014, "Member 'FBeamCollision::FinalTraceEnd' has a wrong offset!");

// ScriptStruct FSD.MicrowaveLense
// 0x0014 (0x0014 - 0x0000)
struct FMicrowaveLense final
{
public:
	float                                         ShotRadiusMultiplier;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotBonusDamageModifier;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatModifier;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateOfFireModifier;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17EB[0x4];                                     // 0x0010(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMicrowaveLense) == 0x000004, "Wrong alignment on FMicrowaveLense");
static_assert(sizeof(FMicrowaveLense) == 0x000014, "Wrong size on FMicrowaveLense");
static_assert(offsetof(FMicrowaveLense, ShotRadiusMultiplier) == 0x000000, "Member 'FMicrowaveLense::ShotRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(FMicrowaveLense, ShotBonusDamageModifier) == 0x000004, "Member 'FMicrowaveLense::ShotBonusDamageModifier' has a wrong offset!");
static_assert(offsetof(FMicrowaveLense, HeatModifier) == 0x000008, "Member 'FMicrowaveLense::HeatModifier' has a wrong offset!");
static_assert(offsetof(FMicrowaveLense, RateOfFireModifier) == 0x00000C, "Member 'FMicrowaveLense::RateOfFireModifier' has a wrong offset!");

// ScriptStruct FSD.MilestoneTier
// 0x0008 (0x0008 - 0x0000)
struct FMilestoneTier final
{
public:
	float                                         CompletionCount;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PerkPoints;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMilestoneTier) == 0x000004, "Wrong alignment on FMilestoneTier");
static_assert(sizeof(FMilestoneTier) == 0x000008, "Wrong size on FMilestoneTier");
static_assert(offsetof(FMilestoneTier, CompletionCount) == 0x000000, "Member 'FMilestoneTier::CompletionCount' has a wrong offset!");
static_assert(offsetof(FMilestoneTier, PerkPoints) == 0x000004, "Member 'FMilestoneTier::PerkPoints' has a wrong offset!");

// ScriptStruct FSD.MissionTypeDescription
// 0x0028 (0x0028 - 0x0000)
struct FMissionTypeDescription final
{
public:
	class FText                                   InfoHeadline;                                      // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FSoftMissionStepDescription>    Steps;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTypeDescription) == 0x000008, "Wrong alignment on FMissionTypeDescription");
static_assert(sizeof(FMissionTypeDescription) == 0x000028, "Wrong size on FMissionTypeDescription");
static_assert(offsetof(FMissionTypeDescription, InfoHeadline) == 0x000000, "Member 'FMissionTypeDescription::InfoHeadline' has a wrong offset!");
static_assert(offsetof(FMissionTypeDescription, Steps) == 0x000018, "Member 'FMissionTypeDescription::Steps' has a wrong offset!");

// ScriptStruct FSD.MissionStepDescription
// 0x0038 (0x0038 - 0x0000)
struct FMissionStepDescription final
{
public:
	class FText                                   Headline;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RichDescription;                                   // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionStepDescription) == 0x000008, "Wrong alignment on FMissionStepDescription");
static_assert(sizeof(FMissionStepDescription) == 0x000038, "Wrong size on FMissionStepDescription");
static_assert(offsetof(FMissionStepDescription, Headline) == 0x000000, "Member 'FMissionStepDescription::Headline' has a wrong offset!");
static_assert(offsetof(FMissionStepDescription, RichDescription) == 0x000018, "Member 'FMissionStepDescription::RichDescription' has a wrong offset!");
static_assert(offsetof(FMissionStepDescription, Image) == 0x000030, "Member 'FMissionStepDescription::Image' has a wrong offset!");

// ScriptStruct FSD.SoftMinersManualDescription
// 0x0080 (0x0080 - 0x0000)
struct FSoftMinersManualDescription final
{
public:
	class FText                                   Headline;                                          // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RichDescription;                                   // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImageFront;                                        // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImageBackground;                                   // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftMinersManualDescription) == 0x000008, "Wrong alignment on FSoftMinersManualDescription");
static_assert(sizeof(FSoftMinersManualDescription) == 0x000080, "Wrong size on FSoftMinersManualDescription");
static_assert(offsetof(FSoftMinersManualDescription, Headline) == 0x000000, "Member 'FSoftMinersManualDescription::Headline' has a wrong offset!");
static_assert(offsetof(FSoftMinersManualDescription, RichDescription) == 0x000018, "Member 'FSoftMinersManualDescription::RichDescription' has a wrong offset!");
static_assert(offsetof(FSoftMinersManualDescription, ImageFront) == 0x000030, "Member 'FSoftMinersManualDescription::ImageFront' has a wrong offset!");
static_assert(offsetof(FSoftMinersManualDescription, ImageBackground) == 0x000058, "Member 'FSoftMinersManualDescription::ImageBackground' has a wrong offset!");

// ScriptStruct FSD.RewardTexts
// 0x0090 (0x0090 - 0x0000)
struct FRewardTexts final
{
public:
	class FText                                   PrimaryObjective;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SecondaryObjective;                                // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CountPrimaryObjectives;                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CountSecondaryObjectives;                          // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   MineralsMinedByTeam;                               // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   HostilesKilled;                                    // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardTexts) == 0x000008, "Wrong alignment on FRewardTexts");
static_assert(sizeof(FRewardTexts) == 0x000090, "Wrong size on FRewardTexts");
static_assert(offsetof(FRewardTexts, PrimaryObjective) == 0x000000, "Member 'FRewardTexts::PrimaryObjective' has a wrong offset!");
static_assert(offsetof(FRewardTexts, SecondaryObjective) == 0x000018, "Member 'FRewardTexts::SecondaryObjective' has a wrong offset!");
static_assert(offsetof(FRewardTexts, CountPrimaryObjectives) == 0x000030, "Member 'FRewardTexts::CountPrimaryObjectives' has a wrong offset!");
static_assert(offsetof(FRewardTexts, CountSecondaryObjectives) == 0x000048, "Member 'FRewardTexts::CountSecondaryObjectives' has a wrong offset!");
static_assert(offsetof(FRewardTexts, MineralsMinedByTeam) == 0x000060, "Member 'FRewardTexts::MineralsMinedByTeam' has a wrong offset!");
static_assert(offsetof(FRewardTexts, HostilesKilled) == 0x000078, "Member 'FRewardTexts::HostilesKilled' has a wrong offset!");

// ScriptStruct FSD.PlanetZoneItem
// 0x0030 (0x0030 - 0x0000)
struct FPlanetZoneItem final
{
public:
	TArray<class UBiome*>                         Biomes;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UGeneratedMission*>              Missions;                                          // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UPlanetZone*                            Zone;                                              // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSpecialEvent;                                   // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WouldHaveSpecialEvent;                             // 0x0029(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17EC[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanetZoneItem) == 0x000008, "Wrong alignment on FPlanetZoneItem");
static_assert(sizeof(FPlanetZoneItem) == 0x000030, "Wrong size on FPlanetZoneItem");
static_assert(offsetof(FPlanetZoneItem, Biomes) == 0x000000, "Member 'FPlanetZoneItem::Biomes' has a wrong offset!");
static_assert(offsetof(FPlanetZoneItem, Missions) == 0x000010, "Member 'FPlanetZoneItem::Missions' has a wrong offset!");
static_assert(offsetof(FPlanetZoneItem, Zone) == 0x000020, "Member 'FPlanetZoneItem::Zone' has a wrong offset!");
static_assert(offsetof(FPlanetZoneItem, HasSpecialEvent) == 0x000028, "Member 'FPlanetZoneItem::HasSpecialEvent' has a wrong offset!");
static_assert(offsetof(FPlanetZoneItem, WouldHaveSpecialEvent) == 0x000029, "Member 'FPlanetZoneItem::WouldHaveSpecialEvent' has a wrong offset!");

// ScriptStruct FSD.MissionTemplateItem
// 0x0010 (0x0010 - 0x0000)
struct FMissionTemplateItem final
{
public:
	class UMissionTemplate*                       Template;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Rarity;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17ED[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionTemplateItem) == 0x000008, "Wrong alignment on FMissionTemplateItem");
static_assert(sizeof(FMissionTemplateItem) == 0x000010, "Wrong size on FMissionTemplateItem");
static_assert(offsetof(FMissionTemplateItem, Template) == 0x000000, "Member 'FMissionTemplateItem::Template' has a wrong offset!");
static_assert(offsetof(FMissionTemplateItem, Rarity) == 0x000008, "Member 'FMissionTemplateItem::Rarity' has a wrong offset!");

// ScriptStruct FSD.ProjectileSpawnData
// 0x0028 (0x0028 - 0x0000)
struct FProjectileSpawnData final
{
public:
	TSubclassOf<class AProjectile>                ProjectileClass;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         HorizontalAngleOffset;                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         VerticalAngleOffset;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Delay;                                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBallistic;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17EE[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileSpawnData) == 0x000008, "Wrong alignment on FProjectileSpawnData");
static_assert(sizeof(FProjectileSpawnData) == 0x000028, "Wrong size on FProjectileSpawnData");
static_assert(offsetof(FProjectileSpawnData, ProjectileClass) == 0x000000, "Member 'FProjectileSpawnData::ProjectileClass' has a wrong offset!");
static_assert(offsetof(FProjectileSpawnData, HorizontalAngleOffset) == 0x000008, "Member 'FProjectileSpawnData::HorizontalAngleOffset' has a wrong offset!");
static_assert(offsetof(FProjectileSpawnData, VerticalAngleOffset) == 0x000010, "Member 'FProjectileSpawnData::VerticalAngleOffset' has a wrong offset!");
static_assert(offsetof(FProjectileSpawnData, Delay) == 0x000018, "Member 'FProjectileSpawnData::Delay' has a wrong offset!");
static_assert(offsetof(FProjectileSpawnData, IsBallistic) == 0x000020, "Member 'FProjectileSpawnData::IsBallistic' has a wrong offset!");

// ScriptStruct FSD.ActiveMusicItem
// 0x0020 (0x0020 - 0x0000)
struct FActiveMusicItem final
{
public:
	class USoundBase*                             Sound;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingTime;                                      // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Looping;                                           // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17EF[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMusicHandle                           Handle;                                            // 0x0014(0x0004)(Transient, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMusicCategory*                         Category;                                          // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveMusicItem) == 0x000008, "Wrong alignment on FActiveMusicItem");
static_assert(sizeof(FActiveMusicItem) == 0x000020, "Wrong size on FActiveMusicItem");
static_assert(offsetof(FActiveMusicItem, Sound) == 0x000000, "Member 'FActiveMusicItem::Sound' has a wrong offset!");
static_assert(offsetof(FActiveMusicItem, StartingTime) == 0x000008, "Member 'FActiveMusicItem::StartingTime' has a wrong offset!");
static_assert(offsetof(FActiveMusicItem, FadeDuration) == 0x00000C, "Member 'FActiveMusicItem::FadeDuration' has a wrong offset!");
static_assert(offsetof(FActiveMusicItem, Looping) == 0x000010, "Member 'FActiveMusicItem::Looping' has a wrong offset!");
static_assert(offsetof(FActiveMusicItem, Handle) == 0x000014, "Member 'FActiveMusicItem::Handle' has a wrong offset!");
static_assert(offsetof(FActiveMusicItem, Category) == 0x000018, "Member 'FActiveMusicItem::Category' has a wrong offset!");

// ScriptStruct FSD.PathCell
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FPathCell final
{
public:
	uint8                                         Pad_17F0[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathCell) == 0x000004, "Wrong alignment on FPathCell");
static_assert(sizeof(FPathCell) == 0x000010, "Wrong size on FPathCell");

// ScriptStruct FSD.OxygenCallback
// 0x0018 (0x0018 - 0x0000)
struct FOxygenCallback final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F1[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOxygenCallback) == 0x000004, "Wrong alignment on FOxygenCallback");
static_assert(sizeof(FOxygenCallback) == 0x000018, "Wrong size on FOxygenCallback");
static_assert(offsetof(FOxygenCallback, Delegate) == 0x000000, "Member 'FOxygenCallback::Delegate' has a wrong offset!");

// ScriptStruct FSD.SimpleObjectInfoData
// 0x0040 (0x0040 - 0x0000)
struct FSimpleObjectInfoData final
{
public:
	class FText                                   InGameName;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   InGameDescription;                                 // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       LookAtShout;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleObjectInfoData) == 0x000008, "Wrong alignment on FSimpleObjectInfoData");
static_assert(sizeof(FSimpleObjectInfoData) == 0x000040, "Wrong size on FSimpleObjectInfoData");
static_assert(offsetof(FSimpleObjectInfoData, InGameName) == 0x000000, "Member 'FSimpleObjectInfoData::InGameName' has a wrong offset!");
static_assert(offsetof(FSimpleObjectInfoData, InGameDescription) == 0x000018, "Member 'FSimpleObjectInfoData::InGameDescription' has a wrong offset!");
static_assert(offsetof(FSimpleObjectInfoData, LookAtShout) == 0x000030, "Member 'FSimpleObjectInfoData::LookAtShout' has a wrong offset!");
static_assert(offsetof(FSimpleObjectInfoData, Icon) == 0x000038, "Member 'FSimpleObjectInfoData::Icon' has a wrong offset!");

// ScriptStruct FSD.PendingRewards
// 0x0190 (0x0190 - 0x0000)
struct FPendingRewards final
{
public:
	struct FPendingRewardsStats                   StartStats;                                        // 0x0000(0x00B0)(Transient, NativeAccessSpecifierPublic)
	struct FPendingRewardsStats                   EndStats;                                          // 0x00B0(0x00B0)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FCreditsReward>                 CreditsRewardEntries;                              // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CreditsReward;                                     // 0x0170(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F2[0x4];                                     // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FXPReward>                      XPRewardEntries;                                   // 0x0178(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         XPReward;                                          // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasData;                                          // 0x018C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRecording;                                      // 0x018D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasRewarded;                                      // 0x018E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F3[0x1];                                     // 0x018F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingRewards) == 0x000008, "Wrong alignment on FPendingRewards");
static_assert(sizeof(FPendingRewards) == 0x000190, "Wrong size on FPendingRewards");
static_assert(offsetof(FPendingRewards, StartStats) == 0x000000, "Member 'FPendingRewards::StartStats' has a wrong offset!");
static_assert(offsetof(FPendingRewards, EndStats) == 0x0000B0, "Member 'FPendingRewards::EndStats' has a wrong offset!");
static_assert(offsetof(FPendingRewards, CreditsRewardEntries) == 0x000160, "Member 'FPendingRewards::CreditsRewardEntries' has a wrong offset!");
static_assert(offsetof(FPendingRewards, CreditsReward) == 0x000170, "Member 'FPendingRewards::CreditsReward' has a wrong offset!");
static_assert(offsetof(FPendingRewards, XPRewardEntries) == 0x000178, "Member 'FPendingRewards::XPRewardEntries' has a wrong offset!");
static_assert(offsetof(FPendingRewards, XPReward) == 0x000188, "Member 'FPendingRewards::XPReward' has a wrong offset!");
static_assert(offsetof(FPendingRewards, bHasData) == 0x00018C, "Member 'FPendingRewards::bHasData' has a wrong offset!");
static_assert(offsetof(FPendingRewards, bIsRecording) == 0x00018D, "Member 'FPendingRewards::bIsRecording' has a wrong offset!");
static_assert(offsetof(FPendingRewards, bWasRewarded) == 0x00018E, "Member 'FPendingRewards::bWasRewarded' has a wrong offset!");

// ScriptStruct FSD.PerkUsage
// 0x0018 (0x0018 - 0x0000)
struct FPerkUsage final
{
public:
	class UPerkAsset*                             Perk;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedCount;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F4[0xC];                                     // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkUsage) == 0x000008, "Wrong alignment on FPerkUsage");
static_assert(sizeof(FPerkUsage) == 0x000018, "Wrong size on FPerkUsage");
static_assert(offsetof(FPerkUsage, Perk) == 0x000000, "Member 'FPerkUsage::Perk' has a wrong offset!");
static_assert(offsetof(FPerkUsage, UsedCount) == 0x000008, "Member 'FPerkUsage::UsedCount' has a wrong offset!");

// ScriptStruct FSD.PickaxeMeshInstance
// 0x0010 (0x0010 - 0x0000)
struct FPickaxeMeshInstance final
{
public:
	class UMeshComponent*                         FP_Mesh;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         TP_Mesh;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickaxeMeshInstance) == 0x000008, "Wrong alignment on FPickaxeMeshInstance");
static_assert(sizeof(FPickaxeMeshInstance) == 0x000010, "Wrong size on FPickaxeMeshInstance");
static_assert(offsetof(FPickaxeMeshInstance, FP_Mesh) == 0x000000, "Member 'FPickaxeMeshInstance::FP_Mesh' has a wrong offset!");
static_assert(offsetof(FPickaxeMeshInstance, TP_Mesh) == 0x000008, "Member 'FPickaxeMeshInstance::TP_Mesh' has a wrong offset!");

// ScriptStruct FSD.DefaultPickaxeParts
// 0x0050 (0x0050 - 0x0000)
struct FDefaultPickaxeParts final
{
public:
	TMap<EPickaxePartLocation, class UPickaxePart*> Parts;                                             // 0x0000(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDefaultPickaxeParts) == 0x000008, "Wrong alignment on FDefaultPickaxeParts");
static_assert(sizeof(FDefaultPickaxeParts) == 0x000050, "Wrong size on FDefaultPickaxeParts");
static_assert(offsetof(FDefaultPickaxeParts, Parts) == 0x000000, "Member 'FDefaultPickaxeParts::Parts' has a wrong offset!");

// ScriptStruct FSD.PillarSegment
// 0x0008 (0x0008 - 0x0000)
struct FPillarSegment final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPillarSegment) == 0x000004, "Wrong alignment on FPillarSegment");
static_assert(sizeof(FPillarSegment) == 0x000008, "Wrong size on FPillarSegment");
static_assert(offsetof(FPillarSegment, Scale) == 0x000000, "Member 'FPillarSegment::Scale' has a wrong offset!");
static_assert(offsetof(FPillarSegment, HeightOffset) == 0x000004, "Member 'FPillarSegment::HeightOffset' has a wrong offset!");

// ScriptStruct FSD.PlacementObstruction
// 0x0010 (0x0010 - 0x0000)
struct FPlacementObstruction final
{
public:
	float                                         Range;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlacementObstruction) == 0x000004, "Wrong alignment on FPlacementObstruction");
static_assert(sizeof(FPlacementObstruction) == 0x000010, "Wrong size on FPlacementObstruction");
static_assert(offsetof(FPlacementObstruction, Range) == 0x000000, "Member 'FPlacementObstruction::Range' has a wrong offset!");
static_assert(offsetof(FPlacementObstruction, Location) == 0x000004, "Member 'FPlacementObstruction::Location' has a wrong offset!");

// ScriptStruct FSD.DropInfo
// 0x001C (0x001C - 0x0000)
struct FDropInfo final
{
public:
	struct FVector                                From;                                              // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                To;                                                // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasLanded;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F5[0x3];                                     // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDropInfo) == 0x000004, "Wrong alignment on FDropInfo");
static_assert(sizeof(FDropInfo) == 0x00001C, "Wrong size on FDropInfo");
static_assert(offsetof(FDropInfo, From) == 0x000000, "Member 'FDropInfo::From' has a wrong offset!");
static_assert(offsetof(FDropInfo, To) == 0x00000C, "Member 'FDropInfo::To' has a wrong offset!");
static_assert(offsetof(FDropInfo, HasLanded) == 0x000018, "Member 'FDropInfo::HasLanded' has a wrong offset!");

// ScriptStruct FSD.ShardStage
// 0x0010 (0x0010 - 0x0000)
struct FShardStage final
{
public:
	TArray<class UStaticMesh*>                    Shards;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShardStage) == 0x000008, "Wrong alignment on FShardStage");
static_assert(sizeof(FShardStage) == 0x000010, "Wrong size on FShardStage");
static_assert(offsetof(FShardStage, Shards) == 0x000000, "Member 'FShardStage::Shards' has a wrong offset!");

// ScriptStruct FSD.PlayerSphere
// 0x0020 (0x0020 - 0x0000)
struct FPlayerSphere final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class APawn>>           Players;                                           // 0x0010(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSphere) == 0x000008, "Wrong alignment on FPlayerSphere");
static_assert(sizeof(FPlayerSphere) == 0x000020, "Wrong size on FPlayerSphere");
static_assert(offsetof(FPlayerSphere, Center) == 0x000000, "Member 'FPlayerSphere::Center' has a wrong offset!");
static_assert(offsetof(FPlayerSphere, Radius) == 0x00000C, "Member 'FPlayerSphere::Radius' has a wrong offset!");
static_assert(offsetof(FPlayerSphere, Players) == 0x000010, "Member 'FPlayerSphere::Players' has a wrong offset!");

// ScriptStruct FSD.RejoinFloat
// 0x001C (0x001C - 0x0000)
struct FRejoinFloat final
{
public:
	struct FGuid                                  ItemKey;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ValueKey;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRejoinFloat) == 0x000004, "Wrong alignment on FRejoinFloat");
static_assert(sizeof(FRejoinFloat) == 0x00001C, "Wrong size on FRejoinFloat");
static_assert(offsetof(FRejoinFloat, ItemKey) == 0x000000, "Member 'FRejoinFloat::ItemKey' has a wrong offset!");
static_assert(offsetof(FRejoinFloat, ValueKey) == 0x000010, "Member 'FRejoinFloat::ValueKey' has a wrong offset!");
static_assert(offsetof(FRejoinFloat, Value) == 0x000018, "Member 'FRejoinFloat::Value' has a wrong offset!");

// ScriptStruct FSD.RejoinInt
// 0x001C (0x001C - 0x0000)
struct FRejoinInt final
{
public:
	struct FGuid                                  ItemKey;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ValueKey;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRejoinInt) == 0x000004, "Wrong alignment on FRejoinInt");
static_assert(sizeof(FRejoinInt) == 0x00001C, "Wrong size on FRejoinInt");
static_assert(offsetof(FRejoinInt, ItemKey) == 0x000000, "Member 'FRejoinInt::ItemKey' has a wrong offset!");
static_assert(offsetof(FRejoinInt, ValueKey) == 0x000010, "Member 'FRejoinInt::ValueKey' has a wrong offset!");
static_assert(offsetof(FRejoinInt, Value) == 0x000018, "Member 'FRejoinInt::Value' has a wrong offset!");

// ScriptStruct FSD.PostDataModel
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPostDataModel final
{
public:
	uint8                                         Pad_17F6[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostDataModel) == 0x000008, "Wrong alignment on FPostDataModel");
static_assert(sizeof(FPostDataModel) == 0x000010, "Wrong size on FPostDataModel");

// ScriptStruct FSD.CaveInfluenceSet
// 0x0010 (0x0010 - 0x0000)
struct FCaveInfluenceSet final
{
public:
	TArray<struct FCaveInfluence>                 CaveInfluences;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCaveInfluenceSet) == 0x000008, "Wrong alignment on FCaveInfluenceSet");
static_assert(sizeof(FCaveInfluenceSet) == 0x000010, "Wrong size on FCaveInfluenceSet");
static_assert(offsetof(FCaveInfluenceSet, CaveInfluences) == 0x000000, "Member 'FCaveInfluenceSet::CaveInfluences' has a wrong offset!");

// ScriptStruct FSD.InfluenceMap
// 0x0050 (0x0050 - 0x0000)
struct FInfluenceMap final
{
public:
	TMap<class UObject*, struct FCaveInfluenceSet> CaveInfluences;                                    // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInfluenceMap) == 0x000008, "Wrong alignment on FInfluenceMap");
static_assert(sizeof(FInfluenceMap) == 0x000050, "Wrong size on FInfluenceMap");
static_assert(offsetof(FInfluenceMap, CaveInfluences) == 0x000000, "Member 'FInfluenceMap::CaveInfluences' has a wrong offset!");

// ScriptStruct FSD.GemResourceAmount
// 0x0010 (0x0010 - 0x0000)
struct FGemResourceAmount final
{
public:
	class UGemResourceCreator*                    GemCreator;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGemResourceAmount) == 0x000008, "Wrong alignment on FGemResourceAmount");
static_assert(sizeof(FGemResourceAmount) == 0x000010, "Wrong size on FGemResourceAmount");
static_assert(offsetof(FGemResourceAmount, GemCreator) == 0x000000, "Member 'FGemResourceAmount::GemCreator' has a wrong offset!");
static_assert(offsetof(FGemResourceAmount, Amount) == 0x000008, "Member 'FGemResourceAmount::Amount' has a wrong offset!");

// ScriptStruct FSD.CarvedResource
// 0x0028 (0x0028 - 0x0000)
struct FCarvedResource final
{
public:
	class UCarvedResourceCreator*                 ResourceCreator;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PredeterminedRooms;                                // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Overflow;                                          // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F8[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCarvedResource) == 0x000008, "Wrong alignment on FCarvedResource");
static_assert(sizeof(FCarvedResource) == 0x000028, "Wrong size on FCarvedResource");
static_assert(offsetof(FCarvedResource, ResourceCreator) == 0x000000, "Member 'FCarvedResource::ResourceCreator' has a wrong offset!");
static_assert(offsetof(FCarvedResource, PredeterminedRooms) == 0x000008, "Member 'FCarvedResource::PredeterminedRooms' has a wrong offset!");
static_assert(offsetof(FCarvedResource, Amount) == 0x000018, "Member 'FCarvedResource::Amount' has a wrong offset!");
static_assert(offsetof(FCarvedResource, Overflow) == 0x00001C, "Member 'FCarvedResource::Overflow' has a wrong offset!");

// ScriptStruct FSD.DebrisVeinResource
// 0x0018 (0x0018 - 0x0000)
struct FDebrisVeinResource final
{
public:
	class UDebrisVeinComponent*                   Debris;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F9[0x10];                                    // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebrisVeinResource) == 0x000008, "Wrong alignment on FDebrisVeinResource");
static_assert(sizeof(FDebrisVeinResource) == 0x000018, "Wrong size on FDebrisVeinResource");
static_assert(offsetof(FDebrisVeinResource, Debris) == 0x000000, "Member 'FDebrisVeinResource::Debris' has a wrong offset!");

// ScriptStruct FSD.LevelGenerationCarverLists
// 0x0010 (0x0010 - 0x0000)
struct FLevelGenerationCarverLists final
{
public:
	TArray<struct FLevelGenerationCarver>         Carvers;                                           // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelGenerationCarverLists) == 0x000008, "Wrong alignment on FLevelGenerationCarverLists");
static_assert(sizeof(FLevelGenerationCarverLists) == 0x000010, "Wrong size on FLevelGenerationCarverLists");
static_assert(offsetof(FLevelGenerationCarverLists, Carvers) == 0x000000, "Member 'FLevelGenerationCarverLists::Carvers' has a wrong offset!");

// ScriptStruct FSD.LevelCarverPass
// 0x0018 (0x0018 - 0x0000)
struct FLevelCarverPass final
{
public:
	TArray<struct FLevelGenerationCarverLists>    Lists;                                             // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_17FA[0x8];                                     // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelCarverPass) == 0x000008, "Wrong alignment on FLevelCarverPass");
static_assert(sizeof(FLevelCarverPass) == 0x000018, "Wrong size on FLevelCarverPass");
static_assert(offsetof(FLevelCarverPass, Lists) == 0x000000, "Member 'FLevelCarverPass::Lists' has a wrong offset!");

// ScriptStruct FSD.GeneratedInstantCarvers
// 0x0010 (0x0010 - 0x0000)
struct FGeneratedInstantCarvers final
{
public:
	TArray<struct FLevelCarverPass>               LevelCarverPasses;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGeneratedInstantCarvers) == 0x000008, "Wrong alignment on FGeneratedInstantCarvers");
static_assert(sizeof(FGeneratedInstantCarvers) == 0x000010, "Wrong size on FGeneratedInstantCarvers");
static_assert(offsetof(FGeneratedInstantCarvers, LevelCarverPasses) == 0x000000, "Member 'FGeneratedInstantCarvers::LevelCarverPasses' has a wrong offset!");

// ScriptStruct FSD.TerrainPlacementBox
// 0x001C (0x001C - 0x0000)
struct FTerrainPlacementBox final
{
public:
	struct FVector                                Min;                                               // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x000C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETerrainPlacementBoxType                      PlacementType;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17FB[0x3];                                     // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainPlacementBox) == 0x000004, "Wrong alignment on FTerrainPlacementBox");
static_assert(sizeof(FTerrainPlacementBox) == 0x00001C, "Wrong size on FTerrainPlacementBox");
static_assert(offsetof(FTerrainPlacementBox, Min) == 0x000000, "Member 'FTerrainPlacementBox::Min' has a wrong offset!");
static_assert(offsetof(FTerrainPlacementBox, Max) == 0x00000C, "Member 'FTerrainPlacementBox::Max' has a wrong offset!");
static_assert(offsetof(FTerrainPlacementBox, PlacementType) == 0x000018, "Member 'FTerrainPlacementBox::PlacementType' has a wrong offset!");

// ScriptStruct FSD.TerrainPlacementDebugItem
// 0x0070 (0x0070 - 0x0000)
struct FTerrainPlacementDebugItem final
{
public:
	TArray<struct FTerrainPlacementBox>           TerrainCheckers;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          BoxGood;                                           // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CapsuleGood;                                       // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDebrisColliderType                           CapsuleType;                                       // 0x0012(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17FC[0x1];                                     // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebrisCapsule                         Capsule;                                           // 0x0014(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_17FD[0xC];                                     // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainPlacementDebugItem) == 0x000010, "Wrong alignment on FTerrainPlacementDebugItem");
static_assert(sizeof(FTerrainPlacementDebugItem) == 0x000070, "Wrong size on FTerrainPlacementDebugItem");
static_assert(offsetof(FTerrainPlacementDebugItem, TerrainCheckers) == 0x000000, "Member 'FTerrainPlacementDebugItem::TerrainCheckers' has a wrong offset!");
static_assert(offsetof(FTerrainPlacementDebugItem, BoxGood) == 0x000010, "Member 'FTerrainPlacementDebugItem::BoxGood' has a wrong offset!");
static_assert(offsetof(FTerrainPlacementDebugItem, CapsuleGood) == 0x000011, "Member 'FTerrainPlacementDebugItem::CapsuleGood' has a wrong offset!");
static_assert(offsetof(FTerrainPlacementDebugItem, CapsuleType) == 0x000012, "Member 'FTerrainPlacementDebugItem::CapsuleType' has a wrong offset!");
static_assert(offsetof(FTerrainPlacementDebugItem, Capsule) == 0x000014, "Member 'FTerrainPlacementDebugItem::Capsule' has a wrong offset!");
static_assert(offsetof(FTerrainPlacementDebugItem, Transform) == 0x000040, "Member 'FTerrainPlacementDebugItem::Transform' has a wrong offset!");

// ScriptStruct FSD.GeneratedInfluenceSet
// 0x0020 (0x0020 - 0x0000)
struct FGeneratedInfluenceSet final
{
public:
	class UObject*                                CaveInfluencer;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NetworkID;                                         // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17FE[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCaveInfluence>                 CaveInfluences;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneratedInfluenceSet) == 0x000008, "Wrong alignment on FGeneratedInfluenceSet");
static_assert(sizeof(FGeneratedInfluenceSet) == 0x000020, "Wrong size on FGeneratedInfluenceSet");
static_assert(offsetof(FGeneratedInfluenceSet, CaveInfluencer) == 0x000000, "Member 'FGeneratedInfluenceSet::CaveInfluencer' has a wrong offset!");
static_assert(offsetof(FGeneratedInfluenceSet, NetworkID) == 0x000008, "Member 'FGeneratedInfluenceSet::NetworkID' has a wrong offset!");
static_assert(offsetof(FGeneratedInfluenceSet, CaveInfluences) == 0x000010, "Member 'FGeneratedInfluenceSet::CaveInfluences' has a wrong offset!");

// ScriptStruct FSD.GeneratedInfluenceSets
// 0x0018 (0x0018 - 0x0000)
struct FGeneratedInfluenceSets final
{
public:
	TArray<struct FGeneratedInfluenceSet>         InfluenceSets;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17FF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratedInfluenceSets) == 0x000008, "Wrong alignment on FGeneratedInfluenceSets");
static_assert(sizeof(FGeneratedInfluenceSets) == 0x000018, "Wrong size on FGeneratedInfluenceSets");
static_assert(offsetof(FGeneratedInfluenceSets, InfluenceSets) == 0x000000, "Member 'FGeneratedInfluenceSets::InfluenceSets' has a wrong offset!");
static_assert(offsetof(FGeneratedInfluenceSets, IsValid) == 0x000010, "Member 'FGeneratedInfluenceSets::IsValid' has a wrong offset!");

// ScriptStruct FSD.CollectableSpawnableItem
// 0x0010 (0x0010 - 0x0000)
struct FCollectableSpawnableItem final
{
public:
	class UCollectableResourceData*               Resource;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1800[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectableSpawnableItem) == 0x000008, "Wrong alignment on FCollectableSpawnableItem");
static_assert(sizeof(FCollectableSpawnableItem) == 0x000010, "Wrong size on FCollectableSpawnableItem");
static_assert(offsetof(FCollectableSpawnableItem, Resource) == 0x000000, "Member 'FCollectableSpawnableItem::Resource' has a wrong offset!");
static_assert(offsetof(FCollectableSpawnableItem, Amount) == 0x000008, "Member 'FCollectableSpawnableItem::Amount' has a wrong offset!");

// ScriptStruct FSD.ResourceSpawner
// 0x0018 (0x0018 - 0x0000)
struct FResourceSpawner final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRandFloatInterval                     AmountToSpawn;                                     // 0x0008(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FResourceSpawner) == 0x000008, "Wrong alignment on FResourceSpawner");
static_assert(sizeof(FResourceSpawner) == 0x000018, "Wrong size on FResourceSpawner");
static_assert(offsetof(FResourceSpawner, Resource) == 0x000000, "Member 'FResourceSpawner::Resource' has a wrong offset!");
static_assert(offsetof(FResourceSpawner, AmountToSpawn) == 0x000008, "Member 'FResourceSpawner::AmountToSpawn' has a wrong offset!");

// ScriptStruct FSD.PLSResource
// 0x0010 (0x0010 - 0x0000)
struct FPLSResource final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountToGenerate;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1801[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPLSResource) == 0x000008, "Wrong alignment on FPLSResource");
static_assert(sizeof(FPLSResource) == 0x000010, "Wrong size on FPLSResource");
static_assert(offsetof(FPLSResource, Resource) == 0x000000, "Member 'FPLSResource::Resource' has a wrong offset!");
static_assert(offsetof(FPLSResource, AmountToGenerate) == 0x000008, "Member 'FPLSResource::AmountToGenerate' has a wrong offset!");

// ScriptStruct FSD.InfluenceSphere
// 0x0010 (0x0010 - 0x0000)
struct FInfluenceSphere final
{
public:
	class UCaveInfluencer*                        Influencer;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1802[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInfluenceSphere) == 0x000008, "Wrong alignment on FInfluenceSphere");
static_assert(sizeof(FInfluenceSphere) == 0x000010, "Wrong size on FInfluenceSphere");
static_assert(offsetof(FInfluenceSphere, Influencer) == 0x000000, "Member 'FInfluenceSphere::Influencer' has a wrong offset!");
static_assert(offsetof(FInfluenceSphere, Radius) == 0x000008, "Member 'FInfluenceSphere::Radius' has a wrong offset!");

// ScriptStruct FSD.ProfileEntry
// 0x0020 (0x0020 - 0x0000)
struct FProfileEntry final
{
public:
	TWeakObjectPtr<class UObject>                 Context;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Category;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSpent;                                         // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1803[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProfileEntry) == 0x000008, "Wrong alignment on FProfileEntry");
static_assert(sizeof(FProfileEntry) == 0x000020, "Wrong size on FProfileEntry");
static_assert(offsetof(FProfileEntry, Context) == 0x000000, "Member 'FProfileEntry::Context' has a wrong offset!");
static_assert(offsetof(FProfileEntry, Category) == 0x000008, "Member 'FProfileEntry::Category' has a wrong offset!");
static_assert(offsetof(FProfileEntry, TimeSpent) == 0x000018, "Member 'FProfileEntry::TimeSpent' has a wrong offset!");

// ScriptStruct FSD.DormantComponentState
// 0x0018 (0x0018 - 0x0000)
struct FDormantComponentState final
{
public:
	TWeakObjectPtr<class UActorComponent>         Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             Collision;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1804[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileName;                              // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Active : 1;                                        // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Visible : 1;                                       // 0x0014(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1805[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDormantComponentState) == 0x000004, "Wrong alignment on FDormantComponentState");
static_assert(sizeof(FDormantComponentState) == 0x000018, "Wrong size on FDormantComponentState");
static_assert(offsetof(FDormantComponentState, Component) == 0x000000, "Member 'FDormantComponentState::Component' has a wrong offset!");
static_assert(offsetof(FDormantComponentState, Collision) == 0x000008, "Member 'FDormantComponentState::Collision' has a wrong offset!");
static_assert(offsetof(FDormantComponentState, CollisionProfileName) == 0x00000C, "Member 'FDormantComponentState::CollisionProfileName' has a wrong offset!");

// ScriptStruct FSD.PropHuntSettingsShouts
// 0x0030 (0x0030 - 0x0000)
struct FPropHuntSettingsShouts final
{
public:
	class UDialogDataAsset*                       DrinkHunter;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       DrinkProp;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       PropHit_AsProp;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       PropHit_AsHunter;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Attention_Prop;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogDataAsset*                       Attention_Hunter;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropHuntSettingsShouts) == 0x000008, "Wrong alignment on FPropHuntSettingsShouts");
static_assert(sizeof(FPropHuntSettingsShouts) == 0x000030, "Wrong size on FPropHuntSettingsShouts");
static_assert(offsetof(FPropHuntSettingsShouts, DrinkHunter) == 0x000000, "Member 'FPropHuntSettingsShouts::DrinkHunter' has a wrong offset!");
static_assert(offsetof(FPropHuntSettingsShouts, DrinkProp) == 0x000008, "Member 'FPropHuntSettingsShouts::DrinkProp' has a wrong offset!");
static_assert(offsetof(FPropHuntSettingsShouts, PropHit_AsProp) == 0x000010, "Member 'FPropHuntSettingsShouts::PropHit_AsProp' has a wrong offset!");
static_assert(offsetof(FPropHuntSettingsShouts, PropHit_AsHunter) == 0x000018, "Member 'FPropHuntSettingsShouts::PropHit_AsHunter' has a wrong offset!");
static_assert(offsetof(FPropHuntSettingsShouts, Attention_Prop) == 0x000020, "Member 'FPropHuntSettingsShouts::Attention_Prop' has a wrong offset!");
static_assert(offsetof(FPropHuntSettingsShouts, Attention_Hunter) == 0x000028, "Member 'FPropHuntSettingsShouts::Attention_Hunter' has a wrong offset!");

// ScriptStruct FSD.RagdollItem
// 0x0028 (0x0028 - 0x0000)
struct FRagdollItem final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       Materials;                                         // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DropshadowMaterial;                                // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1806[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRagdollItem) == 0x000008, "Wrong alignment on FRagdollItem");
static_assert(sizeof(FRagdollItem) == 0x000028, "Wrong size on FRagdollItem");
static_assert(offsetof(FRagdollItem, Actor) == 0x000000, "Member 'FRagdollItem::Actor' has a wrong offset!");
static_assert(offsetof(FRagdollItem, Materials) == 0x000008, "Member 'FRagdollItem::Materials' has a wrong offset!");
static_assert(offsetof(FRagdollItem, DropshadowMaterial) == 0x000018, "Member 'FRagdollItem::DropshadowMaterial' has a wrong offset!");

// ScriptStruct FSD.RandLinePoint
// 0x002C (0x002C - 0x0000)
struct FRandLinePoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandRange                             Range;                                             // 0x000C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRandRange                             NoiseRange;                                        // 0x0014(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRandRange                             SkewFactor;                                        // 0x001C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRandRange                             FillAmount;                                        // 0x0024(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandLinePoint) == 0x000004, "Wrong alignment on FRandLinePoint");
static_assert(sizeof(FRandLinePoint) == 0x00002C, "Wrong size on FRandLinePoint");
static_assert(offsetof(FRandLinePoint, Location) == 0x000000, "Member 'FRandLinePoint::Location' has a wrong offset!");
static_assert(offsetof(FRandLinePoint, Range) == 0x00000C, "Member 'FRandLinePoint::Range' has a wrong offset!");
static_assert(offsetof(FRandLinePoint, NoiseRange) == 0x000014, "Member 'FRandLinePoint::NoiseRange' has a wrong offset!");
static_assert(offsetof(FRandLinePoint, SkewFactor) == 0x00001C, "Member 'FRandLinePoint::SkewFactor' has a wrong offset!");
static_assert(offsetof(FRandLinePoint, FillAmount) == 0x000024, "Member 'FRandLinePoint::FillAmount' has a wrong offset!");

// ScriptStruct FSD.ExposedProperty
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FExposedProperty
{
};
#pragma pack(pop)
static_assert(alignof(FExposedProperty) == 0x000001, "Wrong alignment on FExposedProperty");
static_assert(sizeof(FExposedProperty) == 0x000001, "Wrong size on FExposedProperty");

// ScriptStruct FSD.ExposedFloat
// 0x0028 (0x0028 - 0x0000)
struct FExposedFloat final : public FExposedProperty
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExposedFloat) == 0x000008, "Wrong alignment on FExposedFloat");
static_assert(sizeof(FExposedFloat) == 0x000028, "Wrong size on FExposedFloat");
static_assert(offsetof(FExposedFloat, PropertyName) == 0x000000, "Member 'FExposedFloat::PropertyName' has a wrong offset!");
static_assert(offsetof(FExposedFloat, Description) == 0x000008, "Member 'FExposedFloat::Description' has a wrong offset!");
static_assert(offsetof(FExposedFloat, MinValue) == 0x000020, "Member 'FExposedFloat::MinValue' has a wrong offset!");
static_assert(offsetof(FExposedFloat, MaxValue) == 0x000024, "Member 'FExposedFloat::MaxValue' has a wrong offset!");

// ScriptStruct FSD.ExposableFloat
// 0x0028 (0x0028 - 0x0000)
struct FExposableFloat final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Exposed;                                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1807[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExposableFloat) == 0x000008, "Wrong alignment on FExposableFloat");
static_assert(sizeof(FExposableFloat) == 0x000028, "Wrong size on FExposableFloat");
static_assert(offsetof(FExposableFloat, Value) == 0x000000, "Member 'FExposableFloat::Value' has a wrong offset!");
static_assert(offsetof(FExposableFloat, Exposed) == 0x000004, "Member 'FExposableFloat::Exposed' has a wrong offset!");
static_assert(offsetof(FExposableFloat, Description) == 0x000008, "Member 'FExposableFloat::Description' has a wrong offset!");
static_assert(offsetof(FExposableFloat, MinValue) == 0x000020, "Member 'FExposableFloat::MinValue' has a wrong offset!");
static_assert(offsetof(FExposableFloat, MaxValue) == 0x000024, "Member 'FExposableFloat::MaxValue' has a wrong offset!");

// ScriptStruct FSD.ScanPath
// 0x0018 (0x0018 - 0x0000)
struct FScanPath final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScanPath) == 0x000004, "Wrong alignment on FScanPath");
static_assert(sizeof(FScanPath) == 0x000018, "Wrong size on FScanPath");
static_assert(offsetof(FScanPath, Start) == 0x000000, "Member 'FScanPath::Start' has a wrong offset!");
static_assert(offsetof(FScanPath, End) == 0x00000C, "Member 'FScanPath::End' has a wrong offset!");

// ScriptStruct FSD.ReflectiveHitscanHit
// 0x0038 (0x0038 - 0x0000)
struct FReflectiveHitscanHit final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BoneIndex;                                         // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1808[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x000C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitLocation;                                       // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0020(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1809[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFSDPhysicalMaterial*                   PhysMat;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReflectiveHitscanHit) == 0x000008, "Wrong alignment on FReflectiveHitscanHit");
static_assert(sizeof(FReflectiveHitscanHit) == 0x000038, "Wrong size on FReflectiveHitscanHit");
static_assert(offsetof(FReflectiveHitscanHit, Component) == 0x000000, "Member 'FReflectiveHitscanHit::Component' has a wrong offset!");
static_assert(offsetof(FReflectiveHitscanHit, BoneIndex) == 0x000008, "Member 'FReflectiveHitscanHit::BoneIndex' has a wrong offset!");
static_assert(offsetof(FReflectiveHitscanHit, BoneName) == 0x00000C, "Member 'FReflectiveHitscanHit::BoneName' has a wrong offset!");
static_assert(offsetof(FReflectiveHitscanHit, HitLocation) == 0x000014, "Member 'FReflectiveHitscanHit::HitLocation' has a wrong offset!");
static_assert(offsetof(FReflectiveHitscanHit, ImpactNormal) == 0x000020, "Member 'FReflectiveHitscanHit::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FReflectiveHitscanHit, PhysMat) == 0x000030, "Member 'FReflectiveHitscanHit::PhysMat' has a wrong offset!");

// ScriptStruct FSD.ReflectionTraceResult
// 0x0048 (0x0048 - 0x0000)
struct FReflectionTraceResult final
{
public:
	TArray<struct FScanPath>                      Path;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FReflectiveHitscanHit                  FinalHit;                                          // 0x0010(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReflectionTraceResult) == 0x000008, "Wrong alignment on FReflectionTraceResult");
static_assert(sizeof(FReflectionTraceResult) == 0x000048, "Wrong size on FReflectionTraceResult");
static_assert(offsetof(FReflectionTraceResult, Path) == 0x000000, "Member 'FReflectionTraceResult::Path' has a wrong offset!");
static_assert(offsetof(FReflectionTraceResult, FinalHit) == 0x000010, "Member 'FReflectionTraceResult::FinalHit' has a wrong offset!");

// ScriptStruct FSD.ResourcePouchItem
// 0x0010 (0x0010 - 0x0000)
struct FResourcePouchItem final
{
public:
	class UResourceData*                          Resource;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180A[0x8];                                     // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResourcePouchItem) == 0x000008, "Wrong alignment on FResourcePouchItem");
static_assert(sizeof(FResourcePouchItem) == 0x000010, "Wrong size on FResourcePouchItem");
static_assert(offsetof(FResourcePouchItem, Resource) == 0x000000, "Member 'FResourcePouchItem::Resource' has a wrong offset!");

// ScriptStruct FSD.WeakpointTask
// 0x0110 (0x0110 - 0x0000)
struct FWeakpointTask final
{
public:
	struct FRichCurve                             GrowCurve;                                         // 0x0000(0x0080)(Transient, NativeAccessSpecifierPublic)
	struct FRichCurve                             FadeCurve;                                         // 0x0080(0x0080)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_180B[0x10];                                    // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeakpointTask) == 0x000008, "Wrong alignment on FWeakpointTask");
static_assert(sizeof(FWeakpointTask) == 0x000110, "Wrong size on FWeakpointTask");
static_assert(offsetof(FWeakpointTask, GrowCurve) == 0x000000, "Member 'FWeakpointTask::GrowCurve' has a wrong offset!");
static_assert(offsetof(FWeakpointTask, FadeCurve) == 0x000080, "Member 'FWeakpointTask::FadeCurve' has a wrong offset!");

// ScriptStruct FSD.ResourceDebris
// 0x0010 (0x0010 - 0x0000)
struct FResourceDebris final
{
public:
	float                                         InfluencerRange;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180C[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebrisBase*                            Debris;                                            // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceDebris) == 0x000008, "Wrong alignment on FResourceDebris");
static_assert(sizeof(FResourceDebris) == 0x000010, "Wrong size on FResourceDebris");
static_assert(offsetof(FResourceDebris, InfluencerRange) == 0x000000, "Member 'FResourceDebris::InfluencerRange' has a wrong offset!");
static_assert(offsetof(FResourceDebris, Debris) == 0x000008, "Member 'FResourceDebris::Debris' has a wrong offset!");

// ScriptStruct FSD.RichTextParseResult
// 0x0040 (0x0040 - 0x0000)
struct FRichTextParseResult final
{
public:
	class FText                                   SourceText;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 UnformattedString;                                 // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnformattedLength;                                 // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180D[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRichTextToken>                 Tokens;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichTextParseResult) == 0x000008, "Wrong alignment on FRichTextParseResult");
static_assert(sizeof(FRichTextParseResult) == 0x000040, "Wrong size on FRichTextParseResult");
static_assert(offsetof(FRichTextParseResult, SourceText) == 0x000000, "Member 'FRichTextParseResult::SourceText' has a wrong offset!");
static_assert(offsetof(FRichTextParseResult, UnformattedString) == 0x000018, "Member 'FRichTextParseResult::UnformattedString' has a wrong offset!");
static_assert(offsetof(FRichTextParseResult, UnformattedLength) == 0x000028, "Member 'FRichTextParseResult::UnformattedLength' has a wrong offset!");
static_assert(offsetof(FRichTextParseResult, Tokens) == 0x000030, "Member 'FRichTextParseResult::Tokens' has a wrong offset!");

// ScriptStruct FSD.TextStyleOverride
// 0x0098 (0x0098 - 0x0000)
struct FTextStyleOverride final
{
public:
	bool                                          bOverrideFont;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180E[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x0008(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideColor;                                    // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180F[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            Color;                                             // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bOverrideSize;                                     // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1810[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SizeScale;                                         // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextStyleOverride) == 0x000008, "Wrong alignment on FTextStyleOverride");
static_assert(sizeof(FTextStyleOverride) == 0x000098, "Wrong size on FTextStyleOverride");
static_assert(offsetof(FTextStyleOverride, bOverrideFont) == 0x000000, "Member 'FTextStyleOverride::bOverrideFont' has a wrong offset!");
static_assert(offsetof(FTextStyleOverride, Font) == 0x000008, "Member 'FTextStyleOverride::Font' has a wrong offset!");
static_assert(offsetof(FTextStyleOverride, bOverrideColor) == 0x000060, "Member 'FTextStyleOverride::bOverrideColor' has a wrong offset!");
static_assert(offsetof(FTextStyleOverride, Color) == 0x000068, "Member 'FTextStyleOverride::Color' has a wrong offset!");
static_assert(offsetof(FTextStyleOverride, bOverrideSize) == 0x000090, "Member 'FTextStyleOverride::bOverrideSize' has a wrong offset!");
static_assert(offsetof(FTextStyleOverride, SizeScale) == 0x000094, "Member 'FTextStyleOverride::SizeScale' has a wrong offset!");

// ScriptStruct FSD.XPSettings
// 0x000C (0x000C - 0x0000)
struct FXPSettings final
{
public:
	float                                         XP_PerGold;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XP_PerKill;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XP_OnSurvivedLevel;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXPSettings) == 0x000004, "Wrong alignment on FXPSettings");
static_assert(sizeof(FXPSettings) == 0x00000C, "Wrong size on FXPSettings");
static_assert(offsetof(FXPSettings, XP_PerGold) == 0x000000, "Member 'FXPSettings::XP_PerGold' has a wrong offset!");
static_assert(offsetof(FXPSettings, XP_PerKill) == 0x000004, "Member 'FXPSettings::XP_PerKill' has a wrong offset!");
static_assert(offsetof(FXPSettings, XP_OnSurvivedLevel) == 0x000008, "Member 'FXPSettings::XP_OnSurvivedLevel' has a wrong offset!");

// ScriptStruct FSD.RoomGeneratorGroupInstance
// 0x0010 (0x0010 - 0x0000)
struct FRoomGeneratorGroupInstance final
{
public:
	TArray<class URoomGenerator*>                 Rooms;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomGeneratorGroupInstance) == 0x000008, "Wrong alignment on FRoomGeneratorGroupInstance");
static_assert(sizeof(FRoomGeneratorGroupInstance) == 0x000010, "Wrong size on FRoomGeneratorGroupInstance");
static_assert(offsetof(FRoomGeneratorGroupInstance, Rooms) == 0x000000, "Member 'FRoomGeneratorGroupInstance::Rooms' has a wrong offset!");

// ScriptStruct FSD.RoomNode
// 0x00E0 (0x00E0 - 0x0000)
struct FRoomNode final : public FRoomNodeBase
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CarvePass;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 EntranceIDs;                                       // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExitIDs;                                           // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FRoomEntrance>                  RoomEntrances;                                     // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          CanHaveEnemies;                                    // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1811[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGeneratedRoom>                 Rooms;                                             // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         ResourceMultiplier;                                // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeUsedForRoomBasedDistribution;                 // 0x0064(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1812[0x3];                                     // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightedResourceAmount;                            // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1813[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRoomGeneratorItem>             RoomGenerators;                                    // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1814[0x60];                                    // 0x0080(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomNode) == 0x000008, "Wrong alignment on FRoomNode");
static_assert(sizeof(FRoomNode) == 0x0000E0, "Wrong size on FRoomNode");
static_assert(offsetof(FRoomNode, ID) == 0x000000, "Member 'FRoomNode::ID' has a wrong offset!");
static_assert(offsetof(FRoomNode, CarvePass) == 0x000004, "Member 'FRoomNode::CarvePass' has a wrong offset!");
static_assert(offsetof(FRoomNode, Position) == 0x000008, "Member 'FRoomNode::Position' has a wrong offset!");
static_assert(offsetof(FRoomNode, Radius) == 0x000014, "Member 'FRoomNode::Radius' has a wrong offset!");
static_assert(offsetof(FRoomNode, EntranceIDs) == 0x000018, "Member 'FRoomNode::EntranceIDs' has a wrong offset!");
static_assert(offsetof(FRoomNode, ExitIDs) == 0x000028, "Member 'FRoomNode::ExitIDs' has a wrong offset!");
static_assert(offsetof(FRoomNode, RoomEntrances) == 0x000038, "Member 'FRoomNode::RoomEntrances' has a wrong offset!");
static_assert(offsetof(FRoomNode, CanHaveEnemies) == 0x000048, "Member 'FRoomNode::CanHaveEnemies' has a wrong offset!");
static_assert(offsetof(FRoomNode, Rooms) == 0x000050, "Member 'FRoomNode::Rooms' has a wrong offset!");
static_assert(offsetof(FRoomNode, ResourceMultiplier) == 0x000060, "Member 'FRoomNode::ResourceMultiplier' has a wrong offset!");
static_assert(offsetof(FRoomNode, CanBeUsedForRoomBasedDistribution) == 0x000064, "Member 'FRoomNode::CanBeUsedForRoomBasedDistribution' has a wrong offset!");
static_assert(offsetof(FRoomNode, WeightedResourceAmount) == 0x000068, "Member 'FRoomNode::WeightedResourceAmount' has a wrong offset!");
static_assert(offsetof(FRoomNode, RoomGenerators) == 0x000070, "Member 'FRoomNode::RoomGenerators' has a wrong offset!");

// ScriptStruct FSD.SaveGameSnapShot
// 0x00C8 (0x00C8 - 0x0000)
struct FSaveGameSnapShot final
{
public:
	TWeakObjectPtr<class UFSDSaveGame>            SaveGame;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsObsolete;                                        // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1815[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VersionNumber;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Credits;                                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1816[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class APlayerCharacter>, int32> CharacterLevels;                                   // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UResourceData>, int32> Resources;                                         // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveGameSnapShot) == 0x000008, "Wrong alignment on FSaveGameSnapShot");
static_assert(sizeof(FSaveGameSnapShot) == 0x0000C8, "Wrong size on FSaveGameSnapShot");
static_assert(offsetof(FSaveGameSnapShot, SaveGame) == 0x000000, "Member 'FSaveGameSnapShot::SaveGame' has a wrong offset!");
static_assert(offsetof(FSaveGameSnapShot, Filename) == 0x000008, "Member 'FSaveGameSnapShot::Filename' has a wrong offset!");
static_assert(offsetof(FSaveGameSnapShot, IsObsolete) == 0x000018, "Member 'FSaveGameSnapShot::IsObsolete' has a wrong offset!");
static_assert(offsetof(FSaveGameSnapShot, VersionNumber) == 0x00001C, "Member 'FSaveGameSnapShot::VersionNumber' has a wrong offset!");
static_assert(offsetof(FSaveGameSnapShot, Credits) == 0x000020, "Member 'FSaveGameSnapShot::Credits' has a wrong offset!");
static_assert(offsetof(FSaveGameSnapShot, CharacterLevels) == 0x000028, "Member 'FSaveGameSnapShot::CharacterLevels' has a wrong offset!");
static_assert(offsetof(FSaveGameSnapShot, Resources) == 0x000078, "Member 'FSaveGameSnapShot::Resources' has a wrong offset!");

// ScriptStruct FSD.SchematicGADataEntry
// 0x0028 (0x0030 - 0x0008)
struct FSchematicGADataEntry final : public FTableRowBase
{
public:
	uint8                                         Pad_1817[0x10];                                    // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SchematicGAID;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1818[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SchematicName;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSchematicGADataEntry) == 0x000008, "Wrong alignment on FSchematicGADataEntry");
static_assert(sizeof(FSchematicGADataEntry) == 0x000030, "Wrong size on FSchematicGADataEntry");
static_assert(offsetof(FSchematicGADataEntry, SchematicGAID) == 0x000018, "Member 'FSchematicGADataEntry::SchematicGAID' has a wrong offset!");
static_assert(offsetof(FSchematicGADataEntry, SchematicName) == 0x000020, "Member 'FSchematicGADataEntry::SchematicName' has a wrong offset!");

// ScriptStruct FSD.SchematicBankItem
// 0x0020 (0x0020 - 0x0000)
struct FSchematicBankItem final
{
public:
	class USchematicPricingTier*                  PricingTier;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USchematicRarity*                       Rarity;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USchematic*>                     Schematics;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSchematicBankItem) == 0x000008, "Wrong alignment on FSchematicBankItem");
static_assert(sizeof(FSchematicBankItem) == 0x000020, "Wrong size on FSchematicBankItem");
static_assert(offsetof(FSchematicBankItem, PricingTier) == 0x000000, "Member 'FSchematicBankItem::PricingTier' has a wrong offset!");
static_assert(offsetof(FSchematicBankItem, Rarity) == 0x000008, "Member 'FSchematicBankItem::Rarity' has a wrong offset!");
static_assert(offsetof(FSchematicBankItem, Schematics) == 0x000010, "Member 'FSchematicBankItem::Schematics' has a wrong offset!");

// ScriptStruct FSD.SchematicType
// 0x0070 (0x0070 - 0x0000)
struct FSchematicType final
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconTint;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Frame;                                             // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FrameTint;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSchematicType) == 0x000008, "Wrong alignment on FSchematicType");
static_assert(sizeof(FSchematicType) == 0x000070, "Wrong size on FSchematicType");
static_assert(offsetof(FSchematicType, Icon) == 0x000000, "Member 'FSchematicType::Icon' has a wrong offset!");
static_assert(offsetof(FSchematicType, IconTint) == 0x000028, "Member 'FSchematicType::IconTint' has a wrong offset!");
static_assert(offsetof(FSchematicType, Frame) == 0x000038, "Member 'FSchematicType::Frame' has a wrong offset!");
static_assert(offsetof(FSchematicType, FrameTint) == 0x000060, "Member 'FSchematicType::FrameTint' has a wrong offset!");

// ScriptStruct FSD.UnassignedReward
// 0x0010 (0x0010 - 0x0000)
struct FUnassignedReward final
{
public:
	class UReward*                                Reward;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1819[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnassignedReward) == 0x000008, "Wrong alignment on FUnassignedReward");
static_assert(sizeof(FUnassignedReward) == 0x000010, "Wrong size on FUnassignedReward");
static_assert(offsetof(FUnassignedReward, Reward) == 0x000000, "Member 'FUnassignedReward::Reward' has a wrong offset!");
static_assert(offsetof(FUnassignedReward, Index) == 0x000008, "Member 'FUnassignedReward::Index' has a wrong offset!");

// ScriptStruct FSD.SeasonLevel
// 0x0010 (0x0010 - 0x0000)
struct FSeasonLevel final
{
public:
	class UReward*                                Reward;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReward*                                SpecialReward;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonLevel) == 0x000008, "Wrong alignment on FSeasonLevel");
static_assert(sizeof(FSeasonLevel) == 0x000010, "Wrong size on FSeasonLevel");
static_assert(offsetof(FSeasonLevel, Reward) == 0x000000, "Member 'FSeasonLevel::Reward' has a wrong offset!");
static_assert(offsetof(FSeasonLevel, SpecialReward) == 0x000008, "Member 'FSeasonLevel::SpecialReward' has a wrong offset!");

// ScriptStruct FSD.TrackedStatInfo
// 0x0050 (0x0050 - 0x0000)
struct FTrackedStatInfo final
{
public:
	class UMissionStat*                           Stat;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             AssetReference;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackedStatInfo) == 0x000008, "Wrong alignment on FTrackedStatInfo");
static_assert(sizeof(FTrackedStatInfo) == 0x000050, "Wrong size on FTrackedStatInfo");
static_assert(offsetof(FTrackedStatInfo, Stat) == 0x000000, "Member 'FTrackedStatInfo::Stat' has a wrong offset!");
static_assert(offsetof(FTrackedStatInfo, Name) == 0x000008, "Member 'FTrackedStatInfo::Name' has a wrong offset!");
static_assert(offsetof(FTrackedStatInfo, Image) == 0x000020, "Member 'FTrackedStatInfo::Image' has a wrong offset!");
static_assert(offsetof(FTrackedStatInfo, AssetReference) == 0x000048, "Member 'FTrackedStatInfo::AssetReference' has a wrong offset!");

// ScriptStruct FSD.ChallengeInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FChallengeInfo final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconOutlined;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentWins;                                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfWins;                                      // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPCompleteGain;                                    // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TokenGain;                                         // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Stat1Image;                                        // 0x0048(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Stat2Image;                                        // 0x0070(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpecial;                                        // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181A[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeInfo) == 0x000008, "Wrong alignment on FChallengeInfo");
static_assert(sizeof(FChallengeInfo) == 0x0000A0, "Wrong size on FChallengeInfo");
static_assert(offsetof(FChallengeInfo, Text) == 0x000000, "Member 'FChallengeInfo::Text' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, Icon) == 0x000018, "Member 'FChallengeInfo::Icon' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, IconOutlined) == 0x000020, "Member 'FChallengeInfo::IconOutlined' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, Color) == 0x000028, "Member 'FChallengeInfo::Color' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, CurrentWins) == 0x000038, "Member 'FChallengeInfo::CurrentWins' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, NumberOfWins) == 0x00003C, "Member 'FChallengeInfo::NumberOfWins' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, XPCompleteGain) == 0x000040, "Member 'FChallengeInfo::XPCompleteGain' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, TokenGain) == 0x000044, "Member 'FChallengeInfo::TokenGain' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, Stat1Image) == 0x000048, "Member 'FChallengeInfo::Stat1Image' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, Stat2Image) == 0x000070, "Member 'FChallengeInfo::Stat2Image' has a wrong offset!");
static_assert(offsetof(FChallengeInfo, bIsSpecial) == 0x000098, "Member 'FChallengeInfo::bIsSpecial' has a wrong offset!");

// ScriptStruct FSD.ChallengeVariation
// 0x000C (0x000C - 0x0000)
struct FChallengeVariation final
{
public:
	int32                                         NumberOfWins;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPCompleteGain;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TokenGain;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeVariation) == 0x000004, "Wrong alignment on FChallengeVariation");
static_assert(sizeof(FChallengeVariation) == 0x00000C, "Wrong size on FChallengeVariation");
static_assert(offsetof(FChallengeVariation, NumberOfWins) == 0x000000, "Member 'FChallengeVariation::NumberOfWins' has a wrong offset!");
static_assert(offsetof(FChallengeVariation, XPCompleteGain) == 0x000004, "Member 'FChallengeVariation::XPCompleteGain' has a wrong offset!");
static_assert(offsetof(FChallengeVariation, TokenGain) == 0x000008, "Member 'FChallengeVariation::TokenGain' has a wrong offset!");

// ScriptStruct FSD.SeasonalEventEntry
// 0x0030 (0x0030 - 0x0000)
struct FSeasonalEventEntry final
{
public:
	class USpecialEvent*                          SpecialEvent;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMissionTemplate*>               BannedMissions;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMutator*>                       BannedMutators;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RequiredMainCampaignProgress;                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181B[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeasonalEventEntry) == 0x000008, "Wrong alignment on FSeasonalEventEntry");
static_assert(sizeof(FSeasonalEventEntry) == 0x000030, "Wrong size on FSeasonalEventEntry");
static_assert(offsetof(FSeasonalEventEntry, SpecialEvent) == 0x000000, "Member 'FSeasonalEventEntry::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FSeasonalEventEntry, BannedMissions) == 0x000008, "Member 'FSeasonalEventEntry::BannedMissions' has a wrong offset!");
static_assert(offsetof(FSeasonalEventEntry, BannedMutators) == 0x000018, "Member 'FSeasonalEventEntry::BannedMutators' has a wrong offset!");
static_assert(offsetof(FSeasonalEventEntry, RequiredMainCampaignProgress) == 0x000028, "Member 'FSeasonalEventEntry::RequiredMainCampaignProgress' has a wrong offset!");

// ScriptStruct FSD.SeasonEvent
// 0x0020 (0x0020 - 0x0000)
struct FSeasonEvent final
{
public:
	class USeasonEventData*                       Event;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181C[0x14];                                    // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeasonEvent) == 0x000008, "Wrong alignment on FSeasonEvent");
static_assert(sizeof(FSeasonEvent) == 0x000020, "Wrong size on FSeasonEvent");
static_assert(offsetof(FSeasonEvent, Event) == 0x000000, "Member 'FSeasonEvent::Event' has a wrong offset!");
static_assert(offsetof(FSeasonEvent, Count) == 0x000008, "Member 'FSeasonEvent::Count' has a wrong offset!");

// ScriptStruct FSD.SeasonMissionResult
// 0x0048 (0x0048 - 0x0000)
struct FSeasonMissionResult final
{
public:
	int32                                         XPFromMission;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPFromChallenges;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPFromRewards;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPMultiplier;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TokenGain;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LevelIncreased;                                    // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181D[0x3];                                     // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChallengeInfo>                 UpdatedChallenges;                                 // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSeasonEvent>                   CompletedEvents;                                   // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             EndScreenImage;                                    // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EndScreenResourceIcon;                             // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonMissionResult) == 0x000008, "Wrong alignment on FSeasonMissionResult");
static_assert(sizeof(FSeasonMissionResult) == 0x000048, "Wrong size on FSeasonMissionResult");
static_assert(offsetof(FSeasonMissionResult, XPFromMission) == 0x000000, "Member 'FSeasonMissionResult::XPFromMission' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, XPFromChallenges) == 0x000004, "Member 'FSeasonMissionResult::XPFromChallenges' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, XPFromRewards) == 0x000008, "Member 'FSeasonMissionResult::XPFromRewards' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, XPMultiplier) == 0x00000C, "Member 'FSeasonMissionResult::XPMultiplier' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, TokenGain) == 0x000010, "Member 'FSeasonMissionResult::TokenGain' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, LevelIncreased) == 0x000014, "Member 'FSeasonMissionResult::LevelIncreased' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, UpdatedChallenges) == 0x000018, "Member 'FSeasonMissionResult::UpdatedChallenges' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, CompletedEvents) == 0x000028, "Member 'FSeasonMissionResult::CompletedEvents' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, EndScreenImage) == 0x000038, "Member 'FSeasonMissionResult::EndScreenImage' has a wrong offset!");
static_assert(offsetof(FSeasonMissionResult, EndScreenResourceIcon) == 0x000040, "Member 'FSeasonMissionResult::EndScreenResourceIcon' has a wrong offset!");

// ScriptStruct FSD.FSDServerListRequest
// 0x0078 (0x0078 - 0x0000)
struct FFSDServerListRequest
{
public:
	uint8                                         Pad_181E[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AuthenticationTicket;                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IgnoreId;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_PWREQUIRED;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DRG_REGION;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DRG_VERSION;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DifficultyBitset;                                  // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionSeed;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalMissionSeed;                                 // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SearchString;                                      // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DeepDive;                                          // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181F[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Platform;                                          // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDServerListRequest) == 0x000008, "Wrong alignment on FFSDServerListRequest");
static_assert(sizeof(FFSDServerListRequest) == 0x000078, "Wrong size on FFSDServerListRequest");
static_assert(offsetof(FFSDServerListRequest, AuthenticationTicket) == 0x000008, "Member 'FFSDServerListRequest::AuthenticationTicket' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, IgnoreId) == 0x000018, "Member 'FFSDServerListRequest::IgnoreId' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, Distance) == 0x000028, "Member 'FFSDServerListRequest::Distance' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, DRG_PWREQUIRED) == 0x00002C, "Member 'FFSDServerListRequest::DRG_PWREQUIRED' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, DRG_REGION) == 0x000030, "Member 'FFSDServerListRequest::DRG_REGION' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, DRG_VERSION) == 0x000040, "Member 'FFSDServerListRequest::DRG_VERSION' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, DifficultyBitset) == 0x000044, "Member 'FFSDServerListRequest::DifficultyBitset' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, MissionSeed) == 0x000048, "Member 'FFSDServerListRequest::MissionSeed' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, GlobalMissionSeed) == 0x00004C, "Member 'FFSDServerListRequest::GlobalMissionSeed' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, SearchString) == 0x000050, "Member 'FFSDServerListRequest::SearchString' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, DeepDive) == 0x000060, "Member 'FFSDServerListRequest::DeepDive' has a wrong offset!");
static_assert(offsetof(FFSDServerListRequest, Platform) == 0x000068, "Member 'FFSDServerListRequest::Platform' has a wrong offset!");

// ScriptStruct FSD.FSDSteamServerListRequest
// 0x0030 (0x00A8 - 0x0078)
struct FFSDSteamServerListRequest final : public FFSDServerListRequest
{
public:
	class FString                                 SteamTicket;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SteamPingLoc;                                      // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 GameTypes;                                         // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSDSteamServerListRequest) == 0x000008, "Wrong alignment on FFSDSteamServerListRequest");
static_assert(sizeof(FFSDSteamServerListRequest) == 0x0000A8, "Wrong size on FFSDSteamServerListRequest");
static_assert(offsetof(FFSDSteamServerListRequest, SteamTicket) == 0x000078, "Member 'FFSDSteamServerListRequest::SteamTicket' has a wrong offset!");
static_assert(offsetof(FFSDSteamServerListRequest, SteamPingLoc) == 0x000088, "Member 'FFSDSteamServerListRequest::SteamPingLoc' has a wrong offset!");
static_assert(offsetof(FFSDSteamServerListRequest, GameTypes) == 0x000098, "Member 'FFSDSteamServerListRequest::GameTypes' has a wrong offset!");

// ScriptStruct FSD.LookupSessionResponse
// 0x0030 (0x0030 - 0x0000)
struct FLookupSessionResponse final
{
public:
	bool                                          Valid;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1820[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyId;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 P2PAddr;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P2PPORT;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1821[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLookupSessionResponse) == 0x000008, "Wrong alignment on FLookupSessionResponse");
static_assert(sizeof(FLookupSessionResponse) == 0x000030, "Wrong size on FLookupSessionResponse");
static_assert(offsetof(FLookupSessionResponse, Valid) == 0x000000, "Member 'FLookupSessionResponse::Valid' has a wrong offset!");
static_assert(offsetof(FLookupSessionResponse, LobbyId) == 0x000008, "Member 'FLookupSessionResponse::LobbyId' has a wrong offset!");
static_assert(offsetof(FLookupSessionResponse, P2PAddr) == 0x000018, "Member 'FLookupSessionResponse::P2PAddr' has a wrong offset!");
static_assert(offsetof(FLookupSessionResponse, P2PPORT) == 0x000028, "Member 'FLookupSessionResponse::P2PPORT' has a wrong offset!");

// ScriptStruct FSD.StopSessionResponse
// 0x0001 (0x0001 - 0x0000)
struct FStopSessionResponse final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStopSessionResponse) == 0x000001, "Wrong alignment on FStopSessionResponse");
static_assert(sizeof(FStopSessionResponse) == 0x000001, "Wrong size on FStopSessionResponse");
static_assert(offsetof(FStopSessionResponse, Success) == 0x000000, "Member 'FStopSessionResponse::Success' has a wrong offset!");

// ScriptStruct FSD.StopSessionRequest
// 0x0010 (0x0010 - 0x0000)
struct FStopSessionRequest final
{
public:
	class FString                                 SessionKey;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStopSessionRequest) == 0x000008, "Wrong alignment on FStopSessionRequest");
static_assert(sizeof(FStopSessionRequest) == 0x000010, "Wrong size on FStopSessionRequest");
static_assert(offsetof(FStopSessionRequest, SessionKey) == 0x000000, "Member 'FStopSessionRequest::SessionKey' has a wrong offset!");

// ScriptStruct FSD.SessionUpdateResponse
// 0x0001 (0x0001 - 0x0000)
struct FSessionUpdateResponse final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSessionUpdateResponse) == 0x000001, "Wrong alignment on FSessionUpdateResponse");
static_assert(sizeof(FSessionUpdateResponse) == 0x000001, "Wrong size on FSessionUpdateResponse");
static_assert(offsetof(FSessionUpdateResponse, Success) == 0x000000, "Member 'FSessionUpdateResponse::Success' has a wrong offset!");

// ScriptStruct FSD.SessionUpdateRequest
// 0x0018 (0x0018 - 0x0000)
struct FSessionUpdateRequest final
{
public:
	class FString                                 SessionKey;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayers;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1822[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSessionUpdateRequest) == 0x000008, "Wrong alignment on FSessionUpdateRequest");
static_assert(sizeof(FSessionUpdateRequest) == 0x000018, "Wrong size on FSessionUpdateRequest");
static_assert(offsetof(FSessionUpdateRequest, SessionKey) == 0x000000, "Member 'FSessionUpdateRequest::SessionKey' has a wrong offset!");
static_assert(offsetof(FSessionUpdateRequest, NumPlayers) == 0x000010, "Member 'FSessionUpdateRequest::NumPlayers' has a wrong offset!");

// ScriptStruct FSD.RegisterSessionResponse
// 0x0010 (0x0010 - 0x0000)
struct FRegisterSessionResponse final
{
public:
	class FString                                 SessionKey;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegisterSessionResponse) == 0x000008, "Wrong alignment on FRegisterSessionResponse");
static_assert(sizeof(FRegisterSessionResponse) == 0x000010, "Wrong size on FRegisterSessionResponse");
static_assert(offsetof(FRegisterSessionResponse, SessionKey) == 0x000000, "Member 'FRegisterSessionResponse::SessionKey' has a wrong offset!");

// ScriptStruct FSD.RegisterSessionRequest
// 0x0040 (0x0040 - 0x0000)
struct FRegisterSessionRequest final
{
public:
	class FString                                 ServerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayers;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1823[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyId;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 P2PAddr;                                           // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P2PPORT;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1824[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegisterSessionRequest) == 0x000008, "Wrong alignment on FRegisterSessionRequest");
static_assert(sizeof(FRegisterSessionRequest) == 0x000040, "Wrong size on FRegisterSessionRequest");
static_assert(offsetof(FRegisterSessionRequest, ServerName) == 0x000000, "Member 'FRegisterSessionRequest::ServerName' has a wrong offset!");
static_assert(offsetof(FRegisterSessionRequest, NumPlayers) == 0x000010, "Member 'FRegisterSessionRequest::NumPlayers' has a wrong offset!");
static_assert(offsetof(FRegisterSessionRequest, LobbyId) == 0x000018, "Member 'FRegisterSessionRequest::LobbyId' has a wrong offset!");
static_assert(offsetof(FRegisterSessionRequest, P2PAddr) == 0x000028, "Member 'FRegisterSessionRequest::P2PAddr' has a wrong offset!");
static_assert(offsetof(FRegisterSessionRequest, P2PPORT) == 0x000038, "Member 'FRegisterSessionRequest::P2PPORT' has a wrong offset!");

// ScriptStruct FSD.SoundClassManagerItem
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSoundClassManagerItem final
{
public:
	uint8                                         Pad_1825[0xC];                                     // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundClassManagerItem) == 0x000004, "Wrong alignment on FSoundClassManagerItem");
static_assert(sizeof(FSoundClassManagerItem) == 0x00000C, "Wrong size on FSoundClassManagerItem");

// ScriptStruct FSD.SoundMixManagerItem
// 0x0010 (0x0010 - 0x0000)
struct FSoundMixManagerItem final
{
public:
	class USoundMix*                              Mix;                                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1826[0x8];                                     // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundMixManagerItem) == 0x000008, "Wrong alignment on FSoundMixManagerItem");
static_assert(sizeof(FSoundMixManagerItem) == 0x000010, "Wrong size on FSoundMixManagerItem");
static_assert(offsetof(FSoundMixManagerItem, Mix) == 0x000000, "Member 'FSoundMixManagerItem::Mix' has a wrong offset!");

// ScriptStruct FSD.SpiderAnimInstanceProxy
// 0x0000 (0x0770 - 0x0770)
struct FSpiderAnimInstanceProxy final : public FAnimInstanceProxy
{
};
static_assert(alignof(FSpiderAnimInstanceProxy) == 0x000010, "Wrong alignment on FSpiderAnimInstanceProxy");
static_assert(sizeof(FSpiderAnimInstanceProxy) == 0x000770, "Wrong size on FSpiderAnimInstanceProxy");

// ScriptStruct FSD.RandomWalkCycleEntry
// 0x0014 (0x0014 - 0x0000)
struct FRandomWalkCycleEntry final
{
public:
	float                                         RandomSelectionWeight;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandRange                             Duration;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CoolDown;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTimePlayed;                                    // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomWalkCycleEntry) == 0x000004, "Wrong alignment on FRandomWalkCycleEntry");
static_assert(sizeof(FRandomWalkCycleEntry) == 0x000014, "Wrong size on FRandomWalkCycleEntry");
static_assert(offsetof(FRandomWalkCycleEntry, RandomSelectionWeight) == 0x000000, "Member 'FRandomWalkCycleEntry::RandomSelectionWeight' has a wrong offset!");
static_assert(offsetof(FRandomWalkCycleEntry, Duration) == 0x000004, "Member 'FRandomWalkCycleEntry::Duration' has a wrong offset!");
static_assert(offsetof(FRandomWalkCycleEntry, CoolDown) == 0x00000C, "Member 'FRandomWalkCycleEntry::CoolDown' has a wrong offset!");
static_assert(offsetof(FRandomWalkCycleEntry, LastTimePlayed) == 0x000010, "Member 'FRandomWalkCycleEntry::LastTimePlayed' has a wrong offset!");

// ScriptStruct FSD.CablePathSettings
// 0x0010 (0x0010 - 0x0000)
struct FCablePathSettings final
{
public:
	EDeepPathFinderType                           PathType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeepPathFinderSize                           PathSize;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeepPathFinderPreference                     PathPreference;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1827[0x1];                                     // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinStepSize;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepSize;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNoiseY;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCablePathSettings) == 0x000004, "Wrong alignment on FCablePathSettings");
static_assert(sizeof(FCablePathSettings) == 0x000010, "Wrong size on FCablePathSettings");
static_assert(offsetof(FCablePathSettings, PathType) == 0x000000, "Member 'FCablePathSettings::PathType' has a wrong offset!");
static_assert(offsetof(FCablePathSettings, PathSize) == 0x000001, "Member 'FCablePathSettings::PathSize' has a wrong offset!");
static_assert(offsetof(FCablePathSettings, PathPreference) == 0x000002, "Member 'FCablePathSettings::PathPreference' has a wrong offset!");
static_assert(offsetof(FCablePathSettings, MinStepSize) == 0x000004, "Member 'FCablePathSettings::MinStepSize' has a wrong offset!");
static_assert(offsetof(FCablePathSettings, MaxStepSize) == 0x000008, "Member 'FCablePathSettings::MaxStepSize' has a wrong offset!");
static_assert(offsetof(FCablePathSettings, MaxNoiseY) == 0x00000C, "Member 'FCablePathSettings::MaxNoiseY' has a wrong offset!");

// ScriptStruct FSD.ActiveStatusEffect
// 0x0008 (0x0008 - 0x0000)
struct FActiveStatusEffect final
{
public:
	TWeakObjectPtr<class AActor>                  Owner;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveStatusEffect) == 0x000004, "Wrong alignment on FActiveStatusEffect");
static_assert(sizeof(FActiveStatusEffect) == 0x000008, "Wrong size on FActiveStatusEffect");
static_assert(offsetof(FActiveStatusEffect, Owner) == 0x000000, "Member 'FActiveStatusEffect::Owner' has a wrong offset!");

// ScriptStruct FSD.ActiveStatusEffectBank
// 0x0048 (0x0048 - 0x0000)
struct FActiveStatusEffectBank final
{
public:
	class UStatusEffect*                          Key;                                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStatusEffect*                          ActiveEffect;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1828[0x28];                                    // 0x0010(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveStatusEffect>            Effects;                                           // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveStatusEffectBank) == 0x000008, "Wrong alignment on FActiveStatusEffectBank");
static_assert(sizeof(FActiveStatusEffectBank) == 0x000048, "Wrong size on FActiveStatusEffectBank");
static_assert(offsetof(FActiveStatusEffectBank, Key) == 0x000000, "Member 'FActiveStatusEffectBank::Key' has a wrong offset!");
static_assert(offsetof(FActiveStatusEffectBank, ActiveEffect) == 0x000008, "Member 'FActiveStatusEffectBank::ActiveEffect' has a wrong offset!");
static_assert(offsetof(FActiveStatusEffectBank, Effects) == 0x000038, "Member 'FActiveStatusEffectBank::Effects' has a wrong offset!");

// ScriptStruct FSD.TentacleAnimInstanceProxy
// 0x0100 (0x0870 - 0x0770)
struct FTentacleAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_1829[0x100];                                   // 0x0770(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTentacleAnimInstanceProxy) == 0x000010, "Wrong alignment on FTentacleAnimInstanceProxy");
static_assert(sizeof(FTentacleAnimInstanceProxy) == 0x000870, "Wrong size on FTentacleAnimInstanceProxy");

// ScriptStruct FSD.TentacleTarget
// 0x0020 (0x0020 - 0x0000)
struct FTentacleTarget
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MovementDuration;                                  // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSpring;                                         // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182A[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTentacleTarget) == 0x000004, "Wrong alignment on FTentacleTarget");
static_assert(sizeof(FTentacleTarget) == 0x000020, "Wrong size on FTentacleTarget");
static_assert(offsetof(FTentacleTarget, Location) == 0x000000, "Member 'FTentacleTarget::Location' has a wrong offset!");
static_assert(offsetof(FTentacleTarget, Rotation) == 0x00000C, "Member 'FTentacleTarget::Rotation' has a wrong offset!");
static_assert(offsetof(FTentacleTarget, MovementDuration) == 0x000018, "Member 'FTentacleTarget::MovementDuration' has a wrong offset!");
static_assert(offsetof(FTentacleTarget, UseSpring) == 0x00001C, "Member 'FTentacleTarget::UseSpring' has a wrong offset!");

// ScriptStruct FSD.TerminatorTarget
// 0x0008 (0x0028 - 0x0020)
struct FTerminatorTarget final : public FTentacleTarget
{
public:
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerminatorTarget) == 0x000004, "Wrong alignment on FTerminatorTarget");
static_assert(sizeof(FTerminatorTarget) == 0x000028, "Wrong size on FTerminatorTarget");
static_assert(offsetof(FTerminatorTarget, TargetActor) == 0x000020, "Member 'FTerminatorTarget::TargetActor' has a wrong offset!");

// ScriptStruct FSD.TerminatorShoutState
// 0x0028 (0x0028 - 0x0000)
struct FTerminatorShoutState final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundCue*>                      Shouts;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Loop;                                              // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182B[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRandomShoutDelay;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRandomShoutDelay;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Interruptable;                                     // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventSubsequentDuplicate;                        // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182C[0x2];                                     // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerminatorShoutState) == 0x000008, "Wrong alignment on FTerminatorShoutState");
static_assert(sizeof(FTerminatorShoutState) == 0x000028, "Wrong size on FTerminatorShoutState");
static_assert(offsetof(FTerminatorShoutState, Name) == 0x000000, "Member 'FTerminatorShoutState::Name' has a wrong offset!");
static_assert(offsetof(FTerminatorShoutState, Shouts) == 0x000008, "Member 'FTerminatorShoutState::Shouts' has a wrong offset!");
static_assert(offsetof(FTerminatorShoutState, Loop) == 0x000018, "Member 'FTerminatorShoutState::Loop' has a wrong offset!");
static_assert(offsetof(FTerminatorShoutState, MaxRandomShoutDelay) == 0x00001C, "Member 'FTerminatorShoutState::MaxRandomShoutDelay' has a wrong offset!");
static_assert(offsetof(FTerminatorShoutState, MinRandomShoutDelay) == 0x000020, "Member 'FTerminatorShoutState::MinRandomShoutDelay' has a wrong offset!");
static_assert(offsetof(FTerminatorShoutState, Interruptable) == 0x000024, "Member 'FTerminatorShoutState::Interruptable' has a wrong offset!");
static_assert(offsetof(FTerminatorShoutState, PreventSubsequentDuplicate) == 0x000025, "Member 'FTerminatorShoutState::PreventSubsequentDuplicate' has a wrong offset!");

// ScriptStruct FSD.TestTerrainMaterialDecalItem
// 0x0020 (0x0020 - 0x0000)
struct FTestTerrainMaterialDecalItem final
{
public:
	TArray<class UTerrainMaterial*>               Materials;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDecalData>                     Decals;                                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTestTerrainMaterialDecalItem) == 0x000008, "Wrong alignment on FTestTerrainMaterialDecalItem");
static_assert(sizeof(FTestTerrainMaterialDecalItem) == 0x000020, "Wrong size on FTestTerrainMaterialDecalItem");
static_assert(offsetof(FTestTerrainMaterialDecalItem, Materials) == 0x000000, "Member 'FTestTerrainMaterialDecalItem::Materials' has a wrong offset!");
static_assert(offsetof(FTestTerrainMaterialDecalItem, Decals) == 0x000010, "Member 'FTestTerrainMaterialDecalItem::Decals' has a wrong offset!");

// ScriptStruct FSD.TestTerrainMaterialItem
// 0x00B0 (0x00B0 - 0x0000)
struct FTestTerrainMaterialItem final
{
public:
	TArray<class UTerrainMaterial*>               Materials;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFXSystemAsset>          DigParticles;                                      // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFXSystemAsset>          PartialDigParticles;                               // 0x0038(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundCue>               CrumbleSound;                                      // 0x0060(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundCue>               PartialMineSound;                                  // 0x0088(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTestTerrainMaterialItem) == 0x000008, "Wrong alignment on FTestTerrainMaterialItem");
static_assert(sizeof(FTestTerrainMaterialItem) == 0x0000B0, "Wrong size on FTestTerrainMaterialItem");
static_assert(offsetof(FTestTerrainMaterialItem, Materials) == 0x000000, "Member 'FTestTerrainMaterialItem::Materials' has a wrong offset!");
static_assert(offsetof(FTestTerrainMaterialItem, DigParticles) == 0x000010, "Member 'FTestTerrainMaterialItem::DigParticles' has a wrong offset!");
static_assert(offsetof(FTestTerrainMaterialItem, PartialDigParticles) == 0x000038, "Member 'FTestTerrainMaterialItem::PartialDigParticles' has a wrong offset!");
static_assert(offsetof(FTestTerrainMaterialItem, CrumbleSound) == 0x000060, "Member 'FTestTerrainMaterialItem::CrumbleSound' has a wrong offset!");
static_assert(offsetof(FTestTerrainMaterialItem, PartialMineSound) == 0x000088, "Member 'FTestTerrainMaterialItem::PartialMineSound' has a wrong offset!");

// ScriptStruct FSD.TetherMessageSettings
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FTetherMessageSettings final
{
public:
	uint8                                         Pad_182D[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTetherMessageSettings) == 0x000004, "Wrong alignment on FTetherMessageSettings");
static_assert(sizeof(FTetherMessageSettings) == 0x000010, "Wrong size on FTetherMessageSettings");

// ScriptStruct FSD.PipelineMovementData
// 0x001C (0x001C - 0x0000)
struct FPipelineMovementData final
{
public:
	int32                                         Direction;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpToSpeed;                                         // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182E[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Acceleration;                                      // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APipelineSegment>        PipelineSegment;                                   // 0x0014(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPipelineMovementData) == 0x000004, "Wrong alignment on FPipelineMovementData");
static_assert(sizeof(FPipelineMovementData) == 0x00001C, "Wrong size on FPipelineMovementData");
static_assert(offsetof(FPipelineMovementData, Direction) == 0x000000, "Member 'FPipelineMovementData::Direction' has a wrong offset!");
static_assert(offsetof(FPipelineMovementData, Distance) == 0x000004, "Member 'FPipelineMovementData::Distance' has a wrong offset!");
static_assert(offsetof(FPipelineMovementData, Speed) == 0x000008, "Member 'FPipelineMovementData::Speed' has a wrong offset!");
static_assert(offsetof(FPipelineMovementData, UpToSpeed) == 0x00000C, "Member 'FPipelineMovementData::UpToSpeed' has a wrong offset!");
static_assert(offsetof(FPipelineMovementData, Acceleration) == 0x000010, "Member 'FPipelineMovementData::Acceleration' has a wrong offset!");
static_assert(offsetof(FPipelineMovementData, PipelineSegment) == 0x000014, "Member 'FPipelineMovementData::PipelineSegment' has a wrong offset!");

// ScriptStruct FSD.TreasureWeight
// 0x0010 (0x0010 - 0x0000)
struct FTreasureWeight final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182F[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTreasureRewarder>          RewarderClass;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreasureWeight) == 0x000008, "Wrong alignment on FTreasureWeight");
static_assert(sizeof(FTreasureWeight) == 0x000010, "Wrong size on FTreasureWeight");
static_assert(offsetof(FTreasureWeight, Weight) == 0x000000, "Member 'FTreasureWeight::Weight' has a wrong offset!");
static_assert(offsetof(FTreasureWeight, RewarderClass) == 0x000008, "Member 'FTreasureWeight::RewarderClass' has a wrong offset!");

// ScriptStruct FSD.SpecialChanceEventItem
// 0x0010 (0x0010 - 0x0000)
struct FSpecialChanceEventItem final
{
public:
	class USpecialEvent*                          Event;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseChance;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSpawnInDeepDive;                                // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1830[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialChanceEventItem) == 0x000008, "Wrong alignment on FSpecialChanceEventItem");
static_assert(sizeof(FSpecialChanceEventItem) == 0x000010, "Wrong size on FSpecialChanceEventItem");
static_assert(offsetof(FSpecialChanceEventItem, Event) == 0x000000, "Member 'FSpecialChanceEventItem::Event' has a wrong offset!");
static_assert(offsetof(FSpecialChanceEventItem, BaseChance) == 0x000008, "Member 'FSpecialChanceEventItem::BaseChance' has a wrong offset!");
static_assert(offsetof(FSpecialChanceEventItem, CanSpawnInDeepDive) == 0x00000C, "Member 'FSpecialChanceEventItem::CanSpawnInDeepDive' has a wrong offset!");

// ScriptStruct FSD.VanityNode
// 0x0030 (0x0030 - 0x0000)
struct FVanityNode final
{
public:
	class UReward*                                Reward;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodeID;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1831[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ConnectedNodes;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsBig;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStartingNode;                                   // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1832[0x2];                                     // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Position;                                          // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1833[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVanityNode) == 0x000008, "Wrong alignment on FVanityNode");
static_assert(sizeof(FVanityNode) == 0x000030, "Wrong size on FVanityNode");
static_assert(offsetof(FVanityNode, Reward) == 0x000000, "Member 'FVanityNode::Reward' has a wrong offset!");
static_assert(offsetof(FVanityNode, NodeID) == 0x000008, "Member 'FVanityNode::NodeID' has a wrong offset!");
static_assert(offsetof(FVanityNode, ConnectedNodes) == 0x000010, "Member 'FVanityNode::ConnectedNodes' has a wrong offset!");
static_assert(offsetof(FVanityNode, bIsBig) == 0x000020, "Member 'FVanityNode::bIsBig' has a wrong offset!");
static_assert(offsetof(FVanityNode, bIsStartingNode) == 0x000021, "Member 'FVanityNode::bIsStartingNode' has a wrong offset!");
static_assert(offsetof(FVanityNode, Position) == 0x000024, "Member 'FVanityNode::Position' has a wrong offset!");

// ScriptStruct FSD.TunnelSettingItem
// 0x0010 (0x0010 - 0x0000)
struct FTunnelSettingItem final
{
public:
	class UTunnelSegmentSetting*                  SegmentSetting;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Interval                         SegmentSize;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTunnelSettingItem) == 0x000008, "Wrong alignment on FTunnelSettingItem");
static_assert(sizeof(FTunnelSettingItem) == 0x000010, "Wrong size on FTunnelSettingItem");
static_assert(offsetof(FTunnelSettingItem, SegmentSetting) == 0x000000, "Member 'FTunnelSettingItem::SegmentSetting' has a wrong offset!");
static_assert(offsetof(FTunnelSettingItem, SegmentSize) == 0x000008, "Member 'FTunnelSettingItem::SegmentSize' has a wrong offset!");

// ScriptStruct FSD.TutorialHint
// 0x0070 (0x0070 - 0x0000)
struct FTutorialHint final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TaskText;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialHint) == 0x000008, "Wrong alignment on FTutorialHint");
static_assert(sizeof(FTutorialHint) == 0x000070, "Wrong size on FTutorialHint");
static_assert(offsetof(FTutorialHint, Text) == 0x000000, "Member 'FTutorialHint::Text' has a wrong offset!");
static_assert(offsetof(FTutorialHint, TaskText) == 0x000018, "Member 'FTutorialHint::TaskText' has a wrong offset!");
static_assert(offsetof(FTutorialHint, Title) == 0x000030, "Member 'FTutorialHint::Title' has a wrong offset!");
static_assert(offsetof(FTutorialHint, Image) == 0x000048, "Member 'FTutorialHint::Image' has a wrong offset!");

// ScriptStruct FSD.HeightenedSenseTracker
// 0x0020 (0x0020 - 0x0000)
struct FHeightenedSenseTracker final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHealthComponentBase>    HealthComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IAttackingPointInterface> AttackingPoint;                                    // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeightenedSenseTracker) == 0x000008, "Wrong alignment on FHeightenedSenseTracker");
static_assert(sizeof(FHeightenedSenseTracker) == 0x000020, "Wrong size on FHeightenedSenseTracker");
static_assert(offsetof(FHeightenedSenseTracker, Actor) == 0x000000, "Member 'FHeightenedSenseTracker::Actor' has a wrong offset!");
static_assert(offsetof(FHeightenedSenseTracker, HealthComponent) == 0x000008, "Member 'FHeightenedSenseTracker::HealthComponent' has a wrong offset!");
static_assert(offsetof(FHeightenedSenseTracker, AttackingPoint) == 0x000010, "Member 'FHeightenedSenseTracker::AttackingPoint' has a wrong offset!");

// ScriptStruct FSD.InfectionPoint
// 0x0002 (0x0002 - 0x0000)
struct FInfectionPoint final
{
public:
	bool                                          IsInfected;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVacuumed;                                        // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInfectionPoint) == 0x000001, "Wrong alignment on FInfectionPoint");
static_assert(sizeof(FInfectionPoint) == 0x000002, "Wrong size on FInfectionPoint");
static_assert(offsetof(FInfectionPoint, IsInfected) == 0x000000, "Member 'FInfectionPoint::IsInfected' has a wrong offset!");
static_assert(offsetof(FInfectionPoint, IsVacuumed) == 0x000001, "Member 'FInfectionPoint::IsVacuumed' has a wrong offset!");

// ScriptStruct FSD.MasteryItem
// 0x0018 (0x0018 - 0x0000)
struct FMasteryItem final
{
public:
	int32                                         NeededMastery;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1834[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUnlockReward*>                  Unlocks;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMasteryItem) == 0x000008, "Wrong alignment on FMasteryItem");
static_assert(sizeof(FMasteryItem) == 0x000018, "Wrong size on FMasteryItem");
static_assert(offsetof(FMasteryItem, NeededMastery) == 0x000000, "Member 'FMasteryItem::NeededMastery' has a wrong offset!");
static_assert(offsetof(FMasteryItem, Unlocks) == 0x000008, "Member 'FMasteryItem::Unlocks' has a wrong offset!");

// ScriptStruct FSD.UpgradeTier
// 0x0018 (0x0018 - 0x0000)
struct FUpgradeTier final
{
public:
	TArray<class UItemUpgrade*>                   Upgrades;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RequiredCharacterLevel;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredPlayerRank;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpgradeTier) == 0x000008, "Wrong alignment on FUpgradeTier");
static_assert(sizeof(FUpgradeTier) == 0x000018, "Wrong size on FUpgradeTier");
static_assert(offsetof(FUpgradeTier, Upgrades) == 0x000000, "Member 'FUpgradeTier::Upgrades' has a wrong offset!");
static_assert(offsetof(FUpgradeTier, RequiredCharacterLevel) == 0x000010, "Member 'FUpgradeTier::RequiredCharacterLevel' has a wrong offset!");
static_assert(offsetof(FUpgradeTier, RequiredPlayerRank) == 0x000014, "Member 'FUpgradeTier::RequiredPlayerRank' has a wrong offset!");

// ScriptStruct FSD.MovementModeCombo
// 0x0002 (0x0002 - 0x0000)
struct FMovementModeCombo final
{
public:
	EMovementMode                                 Mode;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementCustomMode                           CustomMode;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementModeCombo) == 0x000001, "Wrong alignment on FMovementModeCombo");
static_assert(sizeof(FMovementModeCombo) == 0x000002, "Wrong size on FMovementModeCombo");
static_assert(offsetof(FMovementModeCombo, Mode) == 0x000000, "Member 'FMovementModeCombo::Mode' has a wrong offset!");
static_assert(offsetof(FMovementModeCombo, CustomMode) == 0x000001, "Member 'FMovementModeCombo::CustomMode' has a wrong offset!");

// ScriptStruct FSD.VanityAnimEffect
// 0x0018 (0x0018 - 0x0000)
struct FVanityAnimEffect final
{
public:
	class UNiagaraSystem*                         Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelay;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1835[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVanityAnimEffect) == 0x000008, "Wrong alignment on FVanityAnimEffect");
static_assert(sizeof(FVanityAnimEffect) == 0x000018, "Wrong size on FVanityAnimEffect");
static_assert(offsetof(FVanityAnimEffect, Effect) == 0x000000, "Member 'FVanityAnimEffect::Effect' has a wrong offset!");
static_assert(offsetof(FVanityAnimEffect, AttachSocket) == 0x000008, "Member 'FVanityAnimEffect::AttachSocket' has a wrong offset!");
static_assert(offsetof(FVanityAnimEffect, StartDelay) == 0x000010, "Member 'FVanityAnimEffect::StartDelay' has a wrong offset!");

// ScriptStruct FSD.VanityTestCharacterItem
// 0x0010 (0x0010 - 0x0000)
struct FVanityTestCharacterItem final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVanityAnimInstance>        AnimBP;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanityTestCharacterItem) == 0x000008, "Wrong alignment on FVanityTestCharacterItem");
static_assert(sizeof(FVanityTestCharacterItem) == 0x000010, "Wrong size on FVanityTestCharacterItem");
static_assert(offsetof(FVanityTestCharacterItem, Mesh) == 0x000000, "Member 'FVanityTestCharacterItem::Mesh' has a wrong offset!");
static_assert(offsetof(FVanityTestCharacterItem, AnimBP) == 0x000008, "Member 'FVanityTestCharacterItem::AnimBP' has a wrong offset!");

// ScriptStruct FSD.VanityEventSource
// 0x0020 (0x0020 - 0x0000)
struct FVanityEventSource final
{
public:
	class FText                                   EventName;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             EventIcon;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanityEventSource) == 0x000008, "Wrong alignment on FVanityEventSource");
static_assert(sizeof(FVanityEventSource) == 0x000020, "Wrong size on FVanityEventSource");
static_assert(offsetof(FVanityEventSource, EventName) == 0x000000, "Member 'FVanityEventSource::EventName' has a wrong offset!");
static_assert(offsetof(FVanityEventSource, EventIcon) == 0x000018, "Member 'FVanityEventSource::EventIcon' has a wrong offset!");

// ScriptStruct FSD.TattooArmorItem
// 0x0010 (0x0010 - 0x0000)
struct FTattooArmorItem final
{
public:
	class UVanityTattoo*                          Tattoo;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLeftArm;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FlipTexture;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1836[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTattooArmorItem) == 0x000008, "Wrong alignment on FTattooArmorItem");
static_assert(sizeof(FTattooArmorItem) == 0x000010, "Wrong size on FTattooArmorItem");
static_assert(offsetof(FTattooArmorItem, Tattoo) == 0x000000, "Member 'FTattooArmorItem::Tattoo' has a wrong offset!");
static_assert(offsetof(FTattooArmorItem, IsLeftArm) == 0x000008, "Member 'FTattooArmorItem::IsLeftArm' has a wrong offset!");
static_assert(offsetof(FTattooArmorItem, FlipTexture) == 0x000009, "Member 'FTattooArmorItem::FlipTexture' has a wrong offset!");

// ScriptStruct FSD.VanityMasterySettings
// 0x0014 (0x0014 - 0x0000)
struct FVanityMasterySettings final
{
public:
	int32                                         TotalMasteryLevels;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP_RequiredPerLevel;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP_ForCreditSpent;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP_ForMineralSpent;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FashionitesLevelUpReward;                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanityMasterySettings) == 0x000004, "Wrong alignment on FVanityMasterySettings");
static_assert(sizeof(FVanityMasterySettings) == 0x000014, "Wrong size on FVanityMasterySettings");
static_assert(offsetof(FVanityMasterySettings, TotalMasteryLevels) == 0x000000, "Member 'FVanityMasterySettings::TotalMasteryLevels' has a wrong offset!");
static_assert(offsetof(FVanityMasterySettings, XP_RequiredPerLevel) == 0x000004, "Member 'FVanityMasterySettings::XP_RequiredPerLevel' has a wrong offset!");
static_assert(offsetof(FVanityMasterySettings, XP_ForCreditSpent) == 0x000008, "Member 'FVanityMasterySettings::XP_ForCreditSpent' has a wrong offset!");
static_assert(offsetof(FVanityMasterySettings, XP_ForMineralSpent) == 0x00000C, "Member 'FVanityMasterySettings::XP_ForMineralSpent' has a wrong offset!");
static_assert(offsetof(FVanityMasterySettings, FashionitesLevelUpReward) == 0x000010, "Member 'FVanityMasterySettings::FashionitesLevelUpReward' has a wrong offset!");

// ScriptStruct FSD.VanitySlotStore
// 0x0010 (0x0010 - 0x0000)
struct FVanitySlotStore final
{
public:
	TArray<class UVanityItem*>                    VanityItems;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanitySlotStore) == 0x000008, "Wrong alignment on FVanitySlotStore");
static_assert(sizeof(FVanitySlotStore) == 0x000010, "Wrong size on FVanitySlotStore");
static_assert(offsetof(FVanitySlotStore, VanityItems) == 0x000000, "Member 'FVanitySlotStore::VanityItems' has a wrong offset!");

// ScriptStruct FSD.VanitySlotCharacter
// 0x0050 (0x0050 - 0x0000)
struct FVanitySlotCharacter final
{
public:
	TMap<class UPlayerCharacterID*, struct FVanitySlotStore> Characters;                                        // 0x0000(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanitySlotCharacter) == 0x000008, "Wrong alignment on FVanitySlotCharacter");
static_assert(sizeof(FVanitySlotCharacter) == 0x000050, "Wrong size on FVanitySlotCharacter");
static_assert(offsetof(FVanitySlotCharacter, Characters) == 0x000000, "Member 'FVanitySlotCharacter::Characters' has a wrong offset!");

// ScriptStruct FSD.FakeSawMover
// 0x0070 (0x0070 - 0x0000)
struct FFakeSawMover final
{
public:
	struct FVector                                PrevPos;                                           // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextPos;                                           // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0018(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1837[0xC];                                     // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 Plane;                                             // 0x0030(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            VelOverTime;                                       // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedCof;                                          // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickRate;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickTime;                                          // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Moving;                                            // 0x005C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1838[0x3];                                     // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityTimer;                                      // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1839[0xC];                                     // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFakeSawMover) == 0x000010, "Wrong alignment on FFakeSawMover");
static_assert(sizeof(FFakeSawMover) == 0x000070, "Wrong size on FFakeSawMover");
static_assert(offsetof(FFakeSawMover, PrevPos) == 0x000000, "Member 'FFakeSawMover::PrevPos' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, NextPos) == 0x00000C, "Member 'FFakeSawMover::NextPos' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, Velocity) == 0x000018, "Member 'FFakeSawMover::Velocity' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, Plane) == 0x000030, "Member 'FFakeSawMover::Plane' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, VelOverTime) == 0x000040, "Member 'FFakeSawMover::VelOverTime' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, SpeedCof) == 0x000048, "Member 'FFakeSawMover::SpeedCof' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, TickRate) == 0x00004C, "Member 'FFakeSawMover::TickRate' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, TickTime) == 0x000050, "Member 'FFakeSawMover::TickTime' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, AccumulatedTime) == 0x000054, "Member 'FFakeSawMover::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, TotalTime) == 0x000058, "Member 'FFakeSawMover::TotalTime' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, Moving) == 0x00005C, "Member 'FFakeSawMover::Moving' has a wrong offset!");
static_assert(offsetof(FFakeSawMover, GravityTimer) == 0x000060, "Member 'FFakeSawMover::GravityTimer' has a wrong offset!");

// ScriptStruct FSD.WeakpointChannel
// 0x0030 (0x0030 - 0x0000)
struct FWeakpointChannel final
{
public:
	uint8                                         Pad_183A[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFSDPhysicalMaterial*                   WeakPointMaterial;                                 // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_183B[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_183C[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeakpointChannel) == 0x000008, "Wrong alignment on FWeakpointChannel");
static_assert(sizeof(FWeakpointChannel) == 0x000030, "Wrong size on FWeakpointChannel");
static_assert(offsetof(FWeakpointChannel, WeakPointMaterial) == 0x000010, "Member 'FWeakpointChannel::WeakPointMaterial' has a wrong offset!");
static_assert(offsetof(FWeakpointChannel, BoneIndex) == 0x000018, "Member 'FWeakpointChannel::BoneIndex' has a wrong offset!");
static_assert(offsetof(FWeakpointChannel, Mid) == 0x000020, "Member 'FWeakpointChannel::Mid' has a wrong offset!");

// ScriptStruct FSD.WeaponHitCounterEffectItem
// 0x0008 (0x0008 - 0x0000)
struct FWeaponHitCounterEffectItem final
{
public:
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponHitCounterEffectItem) == 0x000004, "Wrong alignment on FWeaponHitCounterEffectItem");
static_assert(sizeof(FWeaponHitCounterEffectItem) == 0x000008, "Wrong size on FWeaponHitCounterEffectItem");
static_assert(offsetof(FWeaponHitCounterEffectItem, Target) == 0x000000, "Member 'FWeaponHitCounterEffectItem::Target' has a wrong offset!");

// ScriptStruct FSD.WeightedRoomSelectorItem
// 0x0010 (0x0010 - 0x0000)
struct FWeightedRoomSelectorItem final
{
public:
	class URoomGenerator*                         Room;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_183D[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedRoomSelectorItem) == 0x000008, "Wrong alignment on FWeightedRoomSelectorItem");
static_assert(sizeof(FWeightedRoomSelectorItem) == 0x000010, "Wrong size on FWeightedRoomSelectorItem");
static_assert(offsetof(FWeightedRoomSelectorItem, Room) == 0x000000, "Member 'FWeightedRoomSelectorItem::Room' has a wrong offset!");
static_assert(offsetof(FWeightedRoomSelectorItem, Weight) == 0x000008, "Member 'FWeightedRoomSelectorItem::Weight' has a wrong offset!");

// ScriptStruct FSD.WeightedRoomSelector
// 0x0010 (0x0010 - 0x0000)
struct FWeightedRoomSelector final
{
public:
	TArray<struct FWeightedRoomSelectorItem>      Items;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedRoomSelector) == 0x000008, "Wrong alignment on FWeightedRoomSelector");
static_assert(sizeof(FWeightedRoomSelector) == 0x000010, "Wrong size on FWeightedRoomSelector");
static_assert(offsetof(FWeightedRoomSelector, Items) == 0x000000, "Member 'FWeightedRoomSelector::Items' has a wrong offset!");

// ScriptStruct FSD.ZipLineConnectorHandler
// 0x0030 (0x0030 - 0x0000)
struct FZipLineConnectorHandler final
{
public:
	TSoftClassPtr<class UClass>                   ConnectorClass;                                    // 0x0000(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AZipLineConnector*                      Connector;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FZipLineConnectorHandler) == 0x000008, "Wrong alignment on FZipLineConnectorHandler");
static_assert(sizeof(FZipLineConnectorHandler) == 0x000030, "Wrong size on FZipLineConnectorHandler");
static_assert(offsetof(FZipLineConnectorHandler, ConnectorClass) == 0x000000, "Member 'FZipLineConnectorHandler::ConnectorClass' has a wrong offset!");
static_assert(offsetof(FZipLineConnectorHandler, Connector) == 0x000028, "Member 'FZipLineConnectorHandler::Connector' has a wrong offset!");

// ScriptStruct FSD.ZipLine
// 0x0038 (0x0038 - 0x0000)
struct FZipLine final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_183E[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZipLine) == 0x000004, "Wrong alignment on FZipLine");
static_assert(sizeof(FZipLine) == 0x000038, "Wrong size on FZipLine");
static_assert(offsetof(FZipLine, Start) == 0x000000, "Member 'FZipLine::Start' has a wrong offset!");
static_assert(offsetof(FZipLine, End) == 0x00000C, "Member 'FZipLine::End' has a wrong offset!");

}

