#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FSDEngine

#include "Basic.hpp"

#include "FSDEngine_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace CG
{

// Class FSDEngine.BuilderBase
// 0x0000 (0x0028 - 0x0028)
class UBuilderBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuilderBase">();
	}
	static class UBuilderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuilderBase>();
	}
};
static_assert(alignof(UBuilderBase) == 0x000008, "Wrong alignment on UBuilderBase");
static_assert(sizeof(UBuilderBase) == 0x000028, "Wrong size on UBuilderBase");

// Class FSDEngine.CSGBase
// 0x0038 (0x0060 - 0x0028)
class UCSGBase : public UBuilderBase
{
public:
	struct FMeshBaseProperties                    BaseProperties;                                    // 0x0028(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C8[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBase">();
	}
	static class UCSGBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBase>();
	}
};
static_assert(alignof(UCSGBase) == 0x000010, "Wrong alignment on UCSGBase");
static_assert(sizeof(UCSGBase) == 0x000060, "Wrong size on UCSGBase");
static_assert(offsetof(UCSGBase, BaseProperties) == 0x000028, "Member 'UCSGBase::BaseProperties' has a wrong offset!");
static_assert(offsetof(UCSGBase, RelativeTransform) == 0x000030, "Member 'UCSGBase::RelativeTransform' has a wrong offset!");

// Class FSDEngine.SimpleMeshWithCachedTree
// 0x0070 (0x00D0 - 0x0060)
class USimpleMeshWithCachedTree : public UCSGBase
{
public:
	uint8                                         Pad_27C9[0x38];                                    // 0x0060(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x0098(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          InvertCSG;                                         // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27CA[0x7];                                     // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleMeshWithCachedTree">();
	}
	static class USimpleMeshWithCachedTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleMeshWithCachedTree>();
	}
};
static_assert(alignof(USimpleMeshWithCachedTree) == 0x000010, "Wrong alignment on USimpleMeshWithCachedTree");
static_assert(sizeof(USimpleMeshWithCachedTree) == 0x0000D0, "Wrong size on USimpleMeshWithCachedTree");
static_assert(offsetof(USimpleMeshWithCachedTree, Materials) == 0x000098, "Member 'USimpleMeshWithCachedTree::Materials' has a wrong offset!");
static_assert(offsetof(USimpleMeshWithCachedTree, InvertCSG) == 0x0000C8, "Member 'USimpleMeshWithCachedTree::InvertCSG' has a wrong offset!");

// Class FSDEngine.ConvexMeshWithCachedTree
// 0x0050 (0x0120 - 0x00D0)
class UConvexMeshWithCachedTree : public USimpleMeshWithCachedTree
{
public:
	struct FConvexNoiseProperties                 Noise;                                             // 0x00D0(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27CB[0x44];                                    // 0x00DC(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvexMeshWithCachedTree">();
	}
	static class UConvexMeshWithCachedTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvexMeshWithCachedTree>();
	}
};
static_assert(alignof(UConvexMeshWithCachedTree) == 0x000010, "Wrong alignment on UConvexMeshWithCachedTree");
static_assert(sizeof(UConvexMeshWithCachedTree) == 0x000120, "Wrong size on UConvexMeshWithCachedTree");
static_assert(offsetof(UConvexMeshWithCachedTree, Noise) == 0x0000D0, "Member 'UConvexMeshWithCachedTree::Noise' has a wrong offset!");

// Class FSDEngine.CSGConvexCollider
// 0x0020 (0x0140 - 0x0120)
class UCSGConvexCollider final : public UConvexMeshWithCachedTree
{
public:
	struct FCSGConvexColliderProperties           Properties;                                        // 0x0120(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27CC[0x18];                                    // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGConvexCollider">();
	}
	static class UCSGConvexCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGConvexCollider>();
	}
};
static_assert(alignof(UCSGConvexCollider) == 0x000010, "Wrong alignment on UCSGConvexCollider");
static_assert(sizeof(UCSGConvexCollider) == 0x000140, "Wrong size on UCSGConvexCollider");
static_assert(offsetof(UCSGConvexCollider, Properties) == 0x000120, "Member 'UCSGConvexCollider::Properties' has a wrong offset!");

// Class FSDEngine.TerrainMaterialBase
// 0x0000 (0x0030 - 0x0030)
class UTerrainMaterialBase : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrainMaterialBase">();
	}
	static class UTerrainMaterialBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrainMaterialBase>();
	}
};
static_assert(alignof(UTerrainMaterialBase) == 0x000008, "Wrong alignment on UTerrainMaterialBase");
static_assert(sizeof(UTerrainMaterialBase) == 0x000030, "Wrong size on UTerrainMaterialBase");

// Class FSDEngine.CSGBuilderBaseSceneComponent
// 0x0000 (0x0200 - 0x0200)
#pragma pack(push, 0x1)
class alignas(0x10) UCSGBuilderBaseSceneComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBuilderBaseSceneComponent">();
	}
	static class UCSGBuilderBaseSceneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBuilderBaseSceneComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCSGBuilderBaseSceneComponent) == 0x000010, "Wrong alignment on UCSGBuilderBaseSceneComponent");
static_assert(sizeof(UCSGBuilderBaseSceneComponent) == 0x000200, "Wrong size on UCSGBuilderBaseSceneComponent");

// Class FSDEngine.CSGSDFInstance
// 0x01B0 (0x0210 - 0x0060)
class UCSGSDFInstance final : public UCSGBase
{
public:
	struct FCSGSDFInstanceProperties              Properties;                                        // 0x0060(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x0088(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USDFBase*                               CSGSDFInstanceRoot;                                // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBakeConfig*                            CurrentBakeConfig;                                 // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ChildLocalSpaceBoundingBox;                        // 0x00C8(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   WorldSpaceBoundingBox;                             // 0x00E4(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDeepCSGFloatTree                      BoundingTree;                                      // 0x0100(0x0018)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_27CD[0x8];                                     // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                TransformMatInv;                                   // 0x0120(0x0040)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27CE[0xB0];                                    // 0x0160(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSDFInstance">();
	}
	static class UCSGSDFInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSDFInstance>();
	}
};
static_assert(alignof(UCSGSDFInstance) == 0x000010, "Wrong alignment on UCSGSDFInstance");
static_assert(sizeof(UCSGSDFInstance) == 0x000210, "Wrong size on UCSGSDFInstance");
static_assert(offsetof(UCSGSDFInstance, Properties) == 0x000060, "Member 'UCSGSDFInstance::Properties' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstance, Materials) == 0x000088, "Member 'UCSGSDFInstance::Materials' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstance, CSGSDFInstanceRoot) == 0x0000B8, "Member 'UCSGSDFInstance::CSGSDFInstanceRoot' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstance, CurrentBakeConfig) == 0x0000C0, "Member 'UCSGSDFInstance::CurrentBakeConfig' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstance, ChildLocalSpaceBoundingBox) == 0x0000C8, "Member 'UCSGSDFInstance::ChildLocalSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstance, WorldSpaceBoundingBox) == 0x0000E4, "Member 'UCSGSDFInstance::WorldSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstance, BoundingTree) == 0x000100, "Member 'UCSGSDFInstance::BoundingTree' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstance, TransformMatInv) == 0x000120, "Member 'UCSGSDFInstance::TransformMatInv' has a wrong offset!");

// Class FSDEngine.TerrainMaterialCore
// 0x0048 (0x0078 - 0x0030)
class UTerrainMaterialCore : public UTerrainMaterialBase
{
public:
	class UTerrainMaterialCore*                   BurntMaterial;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainMaterialCore*                   BulletBurntMaterial;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PathfinderDanger : 1;                              // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PathfinderPreventSpawning : 1;                     // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_27CF[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ScannerMaterial;                                   // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      RenderMaterial;                                    // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrainMaterialCore">();
	}
	static class UTerrainMaterialCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrainMaterialCore>();
	}
};
static_assert(alignof(UTerrainMaterialCore) == 0x000008, "Wrong alignment on UTerrainMaterialCore");
static_assert(sizeof(UTerrainMaterialCore) == 0x000078, "Wrong size on UTerrainMaterialCore");
static_assert(offsetof(UTerrainMaterialCore, BurntMaterial) == 0x000030, "Member 'UTerrainMaterialCore::BurntMaterial' has a wrong offset!");
static_assert(offsetof(UTerrainMaterialCore, BulletBurntMaterial) == 0x000038, "Member 'UTerrainMaterialCore::BulletBurntMaterial' has a wrong offset!");
static_assert(offsetof(UTerrainMaterialCore, ScannerMaterial) == 0x000048, "Member 'UTerrainMaterialCore::ScannerMaterial' has a wrong offset!");
static_assert(offsetof(UTerrainMaterialCore, RenderMaterial) == 0x000050, "Member 'UTerrainMaterialCore::RenderMaterial' has a wrong offset!");

// Class FSDEngine.CSGBake
// 0x00A0 (0x00D0 - 0x0030)
class UCSGBake final : public UDataAsset
{
public:
	struct FBakeSettings                          BakeSettings;                                      // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         NumVariations;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialSeed;                                       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CSG;                                               // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Status;                                            // 0x0070(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   CombinedAABB;                                      // 0x0080(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D0[0x4];                                     // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBakeEntry>                     Entries;                                           // 0x00A0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          IsBaking;                                          // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D1[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBakeConfig*>                    CurrentBakeConfigs;                                // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class ACSGBuilder*                            CDO;                                               // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BakeCSG();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBake">();
	}
	static class UCSGBake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBake>();
	}
};
static_assert(alignof(UCSGBake) == 0x000008, "Wrong alignment on UCSGBake");
static_assert(sizeof(UCSGBake) == 0x0000D0, "Wrong size on UCSGBake");
static_assert(offsetof(UCSGBake, BakeSettings) == 0x000030, "Member 'UCSGBake::BakeSettings' has a wrong offset!");
static_assert(offsetof(UCSGBake, NumVariations) == 0x000040, "Member 'UCSGBake::NumVariations' has a wrong offset!");
static_assert(offsetof(UCSGBake, InitialSeed) == 0x000044, "Member 'UCSGBake::InitialSeed' has a wrong offset!");
static_assert(offsetof(UCSGBake, CSG) == 0x000048, "Member 'UCSGBake::CSG' has a wrong offset!");
static_assert(offsetof(UCSGBake, Status) == 0x000070, "Member 'UCSGBake::Status' has a wrong offset!");
static_assert(offsetof(UCSGBake, CombinedAABB) == 0x000080, "Member 'UCSGBake::CombinedAABB' has a wrong offset!");
static_assert(offsetof(UCSGBake, Entries) == 0x0000A0, "Member 'UCSGBake::Entries' has a wrong offset!");
static_assert(offsetof(UCSGBake, IsBaking) == 0x0000B0, "Member 'UCSGBake::IsBaking' has a wrong offset!");
static_assert(offsetof(UCSGBake, CurrentBakeConfigs) == 0x0000B8, "Member 'UCSGBake::CurrentBakeConfigs' has a wrong offset!");
static_assert(offsetof(UCSGBake, CDO) == 0x0000C8, "Member 'UCSGBake::CDO' has a wrong offset!");

// Class FSDEngine.CSGBakedChildInstance
// 0x00B0 (0x0110 - 0x0060)
class UCSGBakedChildInstance final : public UCSGBase
{
public:
	struct FCSGBakedChildInstanceProperties       Properties;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   ChildLocalSpaceBoundingBox;                        // 0x0070(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   WorldSpaceBoundingBox;                             // 0x008C(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D2[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                TransformMatInv;                                   // 0x00B0(0x0040)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDeepCSGFloatTree                      TempTree;                                          // 0x00F0(0x0018)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D3[0x8];                                     // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBakedChildInstance">();
	}
	static class UCSGBakedChildInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBakedChildInstance>();
	}
};
static_assert(alignof(UCSGBakedChildInstance) == 0x000010, "Wrong alignment on UCSGBakedChildInstance");
static_assert(sizeof(UCSGBakedChildInstance) == 0x000110, "Wrong size on UCSGBakedChildInstance");
static_assert(offsetof(UCSGBakedChildInstance, Properties) == 0x000060, "Member 'UCSGBakedChildInstance::Properties' has a wrong offset!");
static_assert(offsetof(UCSGBakedChildInstance, ChildLocalSpaceBoundingBox) == 0x000070, "Member 'UCSGBakedChildInstance::ChildLocalSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGBakedChildInstance, WorldSpaceBoundingBox) == 0x00008C, "Member 'UCSGBakedChildInstance::WorldSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGBakedChildInstance, TransformMatInv) == 0x0000B0, "Member 'UCSGBakedChildInstance::TransformMatInv' has a wrong offset!");
static_assert(offsetof(UCSGBakedChildInstance, TempTree) == 0x0000F0, "Member 'UCSGBakedChildInstance::TempTree' has a wrong offset!");

// Class FSDEngine.CSGBaseComponent
// 0x0000 (0x0200 - 0x0200)
class UCSGBaseComponent : public UCSGBuilderBaseSceneComponent
{
public:
	struct FMeshBaseProperties                    BaseProperties;                                    // 0x01F8(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D4[0x7];                                     // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBaseComponent">();
	}
	static class UCSGBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBaseComponent>();
	}
};
static_assert(alignof(UCSGBaseComponent) == 0x000010, "Wrong alignment on UCSGBaseComponent");
static_assert(sizeof(UCSGBaseComponent) == 0x000200, "Wrong size on UCSGBaseComponent");
static_assert(offsetof(UCSGBaseComponent, BaseProperties) == 0x0001F8, "Member 'UCSGBaseComponent::BaseProperties' has a wrong offset!");

// Class FSDEngine.CSGBakedChildInstanceComponent
// 0x0010 (0x0210 - 0x0200)
class UCSGBakedChildInstanceComponent final : public UCSGBaseComponent
{
public:
	struct FCSGBakedChildInstanceProperties       Properties;                                        // 0x0200(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBakedChildInstanceComponent">();
	}
	static class UCSGBakedChildInstanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBakedChildInstanceComponent>();
	}
};
static_assert(alignof(UCSGBakedChildInstanceComponent) == 0x000010, "Wrong alignment on UCSGBakedChildInstanceComponent");
static_assert(sizeof(UCSGBakedChildInstanceComponent) == 0x000210, "Wrong size on UCSGBakedChildInstanceComponent");
static_assert(offsetof(UCSGBakedChildInstanceComponent, Properties) == 0x000200, "Member 'UCSGBakedChildInstanceComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGSingleChildBase
// 0x0010 (0x0070 - 0x0060)
#pragma pack(push, 0x1)
class alignas(0x10) UCSGSingleChildBase : public UCSGBase
{
public:
	class UCSGBase*                               Child;                                             // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSingleChildBase">();
	}
	static class UCSGSingleChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSingleChildBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCSGSingleChildBase) == 0x000010, "Wrong alignment on UCSGSingleChildBase");
static_assert(sizeof(UCSGSingleChildBase) == 0x000070, "Wrong size on UCSGSingleChildBase");
static_assert(offsetof(UCSGSingleChildBase, Child) == 0x000060, "Member 'UCSGSingleChildBase::Child' has a wrong offset!");

// Class FSDEngine.CSGDuplicateSingleChildBase
// 0x0010 (0x0070 - 0x0060)
class UCSGDuplicateSingleChildBase : public UCSGBase
{
public:
	TArray<class UCSGBase*>                       Children;                                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGDuplicateSingleChildBase">();
	}
	static class UCSGDuplicateSingleChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGDuplicateSingleChildBase>();
	}
};
static_assert(alignof(UCSGDuplicateSingleChildBase) == 0x000010, "Wrong alignment on UCSGDuplicateSingleChildBase");
static_assert(sizeof(UCSGDuplicateSingleChildBase) == 0x000070, "Wrong size on UCSGDuplicateSingleChildBase");
static_assert(offsetof(UCSGDuplicateSingleChildBase, Children) == 0x000060, "Member 'UCSGDuplicateSingleChildBase::Children' has a wrong offset!");

// Class FSDEngine.CSGBuilderBase
// 0x0068 (0x0288 - 0x0220)
class ACSGBuilderBase : public AActor
{
public:
	struct FBox                                   BoundingBox;                                       // 0x0220(0x001C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         PreviewSeed;                                       // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBakeSettings                          PreviewSettings;                                   // 0x0240(0x0010)(Edit, NativeAccessSpecifierPublic)
	class UTerrainMaterialCore*                   EmptyMat;                                          // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainMaterialCore*                   ErrorMat;                                          // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainMaterialCore*                   SolidMat;                                          // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrainMaterialCore*                   BurnedMat;                                         // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCSGPreviewComponent*                   PreviewComponent;                                  // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D5[0x10];                                    // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PreGenerate(class UBakeConfig* builder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBuilderBase">();
	}
	static class ACSGBuilderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACSGBuilderBase>();
	}
};
static_assert(alignof(ACSGBuilderBase) == 0x000008, "Wrong alignment on ACSGBuilderBase");
static_assert(sizeof(ACSGBuilderBase) == 0x000288, "Wrong size on ACSGBuilderBase");
static_assert(offsetof(ACSGBuilderBase, BoundingBox) == 0x000220, "Member 'ACSGBuilderBase::BoundingBox' has a wrong offset!");
static_assert(offsetof(ACSGBuilderBase, PreviewSeed) == 0x00023C, "Member 'ACSGBuilderBase::PreviewSeed' has a wrong offset!");
static_assert(offsetof(ACSGBuilderBase, PreviewSettings) == 0x000240, "Member 'ACSGBuilderBase::PreviewSettings' has a wrong offset!");
static_assert(offsetof(ACSGBuilderBase, EmptyMat) == 0x000250, "Member 'ACSGBuilderBase::EmptyMat' has a wrong offset!");
static_assert(offsetof(ACSGBuilderBase, ErrorMat) == 0x000258, "Member 'ACSGBuilderBase::ErrorMat' has a wrong offset!");
static_assert(offsetof(ACSGBuilderBase, SolidMat) == 0x000260, "Member 'ACSGBuilderBase::SolidMat' has a wrong offset!");
static_assert(offsetof(ACSGBuilderBase, BurnedMat) == 0x000268, "Member 'ACSGBuilderBase::BurnedMat' has a wrong offset!");
static_assert(offsetof(ACSGBuilderBase, PreviewComponent) == 0x000270, "Member 'ACSGBuilderBase::PreviewComponent' has a wrong offset!");

// Class FSDEngine.CSGBuilder
// 0x0038 (0x02C0 - 0x0288)
class ACSGBuilder final : public ACSGBuilderBase
{
public:
	class UCSGGroupComponent*                     CSGRoot;                                           // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTerrainMaterialCore*>           UsedMaterials;                                     // 0x0290(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UCSGBase*                               CurrentRoot;                                       // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCSGBase*                               CurrentPreviewRoot;                                // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBakeConfig*                            CurrentPreviewConfig;                              // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCSGPreviewScene*                       PreviewScene;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBuilder">();
	}
	static class ACSGBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACSGBuilder>();
	}
};
static_assert(alignof(ACSGBuilder) == 0x000008, "Wrong alignment on ACSGBuilder");
static_assert(sizeof(ACSGBuilder) == 0x0002C0, "Wrong size on ACSGBuilder");
static_assert(offsetof(ACSGBuilder, CSGRoot) == 0x000288, "Member 'ACSGBuilder::CSGRoot' has a wrong offset!");
static_assert(offsetof(ACSGBuilder, UsedMaterials) == 0x000290, "Member 'ACSGBuilder::UsedMaterials' has a wrong offset!");
static_assert(offsetof(ACSGBuilder, CurrentRoot) == 0x0002A0, "Member 'ACSGBuilder::CurrentRoot' has a wrong offset!");
static_assert(offsetof(ACSGBuilder, CurrentPreviewRoot) == 0x0002A8, "Member 'ACSGBuilder::CurrentPreviewRoot' has a wrong offset!");
static_assert(offsetof(ACSGBuilder, CurrentPreviewConfig) == 0x0002B0, "Member 'ACSGBuilder::CurrentPreviewConfig' has a wrong offset!");
static_assert(offsetof(ACSGBuilder, PreviewScene) == 0x0002B8, "Member 'ACSGBuilder::PreviewScene' has a wrong offset!");

// Class FSDEngine.BakeConfig
// 0x0078 (0x00A0 - 0x0028)
class UBakeConfig final : public UObject
{
public:
	uint8                                         Pad_27D6[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBakeSettings                          Settings;                                          // 0x0030(0x0010)(Transient, NativeAccessSpecifierPublic)
	TMap<class FName, class UBuilderBase*>        Objects;                                           // 0x0040(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<class FString>                         Warnings;                                          // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	bool GetBoolSetting(class FName Param_Name, bool DefaultVal);
	float GetFloatSetting(class FName Param_Name, float DefaultVal);
	int32 GetIntSetting(class FName Param_Name, int32 DefaultVal);
	class UBuilderBase* GetObject(class FName Param_Name);
	struct FRandomStream GetRandomStream();
	struct FVector GetVectorSetting(class FName Param_Name, const struct FVector& DefaultVal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeConfig">();
	}
	static class UBakeConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeConfig>();
	}
};
static_assert(alignof(UBakeConfig) == 0x000008, "Wrong alignment on UBakeConfig");
static_assert(sizeof(UBakeConfig) == 0x0000A0, "Wrong size on UBakeConfig");
static_assert(offsetof(UBakeConfig, Settings) == 0x000030, "Member 'UBakeConfig::Settings' has a wrong offset!");
static_assert(offsetof(UBakeConfig, Objects) == 0x000040, "Member 'UBakeConfig::Objects' has a wrong offset!");
static_assert(offsetof(UBakeConfig, Warnings) == 0x000090, "Member 'UBakeConfig::Warnings' has a wrong offset!");

// Class FSDEngine.CSGCellNoise
// 0x00A0 (0x0100 - 0x0060)
class UCSGCellNoise final : public UCSGBase
{
public:
	struct FMeshCellNoiseProperties               Properties;                                        // 0x0060(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D8[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x0080(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                ReciprocalCellSize;                                // 0x00B0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D9[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeepCSGFloatTree                      ApplyTree;                                         // 0x00C0(0x0018)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        CellPositions;                                     // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FDeepCSGNode>                   CellLeaves;                                        // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DA[0x8];                                     // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGCellNoise">();
	}
	static class UCSGCellNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGCellNoise>();
	}
};
static_assert(alignof(UCSGCellNoise) == 0x000010, "Wrong alignment on UCSGCellNoise");
static_assert(sizeof(UCSGCellNoise) == 0x000100, "Wrong size on UCSGCellNoise");
static_assert(offsetof(UCSGCellNoise, Properties) == 0x000060, "Member 'UCSGCellNoise::Properties' has a wrong offset!");
static_assert(offsetof(UCSGCellNoise, Materials) == 0x000080, "Member 'UCSGCellNoise::Materials' has a wrong offset!");
static_assert(offsetof(UCSGCellNoise, ReciprocalCellSize) == 0x0000B0, "Member 'UCSGCellNoise::ReciprocalCellSize' has a wrong offset!");
static_assert(offsetof(UCSGCellNoise, ApplyTree) == 0x0000C0, "Member 'UCSGCellNoise::ApplyTree' has a wrong offset!");
static_assert(offsetof(UCSGCellNoise, CellPositions) == 0x0000D8, "Member 'UCSGCellNoise::CellPositions' has a wrong offset!");
static_assert(offsetof(UCSGCellNoise, CellLeaves) == 0x0000E8, "Member 'UCSGCellNoise::CellLeaves' has a wrong offset!");

// Class FSDEngine.CSGCellNoiseComponent
// 0x0050 (0x0250 - 0x0200)
class UCSGCellNoiseComponent final : public UCSGBaseComponent
{
public:
	struct FMeshCellNoiseProperties               Properties;                                        // 0x0200(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DB[0x4];                                     // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x0220(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGCellNoiseComponent">();
	}
	static class UCSGCellNoiseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGCellNoiseComponent>();
	}
};
static_assert(alignof(UCSGCellNoiseComponent) == 0x000010, "Wrong alignment on UCSGCellNoiseComponent");
static_assert(sizeof(UCSGCellNoiseComponent) == 0x000250, "Wrong size on UCSGCellNoiseComponent");
static_assert(offsetof(UCSGCellNoiseComponent, Properties) == 0x000200, "Member 'UCSGCellNoiseComponent::Properties' has a wrong offset!");
static_assert(offsetof(UCSGCellNoiseComponent, Materials) == 0x000220, "Member 'UCSGCellNoiseComponent::Materials' has a wrong offset!");

// Class FSDEngine.CSGChildInstance
// 0x0160 (0x01C0 - 0x0060)
class UCSGChildInstance final : public UCSGBase
{
public:
	struct FCSGChildInstanceProperties            Properties;                                        // 0x0060(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGeneralTerrainMaterialCombiner        Materials;                                         // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCSGBase*                               CSGChildInstanceRoot;                              // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBakeConfig*                            CurrentBakeConfig;                                 // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ChildLocalSpaceBoundingBox;                        // 0x00E0(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   WorldSpaceBoundingBox;                             // 0x00FC(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDeepCSGFloatTree                      BoundingTree;                                      // 0x0118(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FMatrix                                TransformMatInv;                                   // 0x0130(0x0040)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDeepCSGTree                           TempTree;                                          // 0x0170(0x0048)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DC[0x8];                                     // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGChildInstance">();
	}
	static class UCSGChildInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGChildInstance>();
	}
};
static_assert(alignof(UCSGChildInstance) == 0x000010, "Wrong alignment on UCSGChildInstance");
static_assert(sizeof(UCSGChildInstance) == 0x0001C0, "Wrong size on UCSGChildInstance");
static_assert(offsetof(UCSGChildInstance, Properties) == 0x000060, "Member 'UCSGChildInstance::Properties' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, Materials) == 0x000080, "Member 'UCSGChildInstance::Materials' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, CSGChildInstanceRoot) == 0x0000D0, "Member 'UCSGChildInstance::CSGChildInstanceRoot' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, CurrentBakeConfig) == 0x0000D8, "Member 'UCSGChildInstance::CurrentBakeConfig' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, ChildLocalSpaceBoundingBox) == 0x0000E0, "Member 'UCSGChildInstance::ChildLocalSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, WorldSpaceBoundingBox) == 0x0000FC, "Member 'UCSGChildInstance::WorldSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, BoundingTree) == 0x000118, "Member 'UCSGChildInstance::BoundingTree' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, TransformMatInv) == 0x000130, "Member 'UCSGChildInstance::TransformMatInv' has a wrong offset!");
static_assert(offsetof(UCSGChildInstance, TempTree) == 0x000170, "Member 'UCSGChildInstance::TempTree' has a wrong offset!");

// Class FSDEngine.CSGChildInstanceComponent
// 0x0070 (0x0270 - 0x0200)
class UCSGChildInstanceComponent final : public UCSGBaseComponent
{
public:
	struct FCSGChildInstanceProperties            Properties;                                        // 0x0200(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGeneralTerrainMaterialCombiner        Materials;                                         // 0x0220(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGChildInstanceComponent">();
	}
	static class UCSGChildInstanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGChildInstanceComponent>();
	}
};
static_assert(alignof(UCSGChildInstanceComponent) == 0x000010, "Wrong alignment on UCSGChildInstanceComponent");
static_assert(sizeof(UCSGChildInstanceComponent) == 0x000270, "Wrong size on UCSGChildInstanceComponent");
static_assert(offsetof(UCSGChildInstanceComponent, Properties) == 0x000200, "Member 'UCSGChildInstanceComponent::Properties' has a wrong offset!");
static_assert(offsetof(UCSGChildInstanceComponent, Materials) == 0x000220, "Member 'UCSGChildInstanceComponent::Materials' has a wrong offset!");

// Class FSDEngine.SimpleMeshWithCachedTreeComponent
// 0x0040 (0x0240 - 0x0200)
#pragma pack(push, 0x1)
class alignas(0x10) USimpleMeshWithCachedTreeComponent : public UCSGBaseComponent
{
public:
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x0200(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          InvertCSG;                                         // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DD[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleMeshWithCachedTreeComponent">();
	}
	static class USimpleMeshWithCachedTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleMeshWithCachedTreeComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USimpleMeshWithCachedTreeComponent) == 0x000010, "Wrong alignment on USimpleMeshWithCachedTreeComponent");
static_assert(sizeof(USimpleMeshWithCachedTreeComponent) == 0x000240, "Wrong size on USimpleMeshWithCachedTreeComponent");
static_assert(offsetof(USimpleMeshWithCachedTreeComponent, Materials) == 0x000200, "Member 'USimpleMeshWithCachedTreeComponent::Materials' has a wrong offset!");
static_assert(offsetof(USimpleMeshWithCachedTreeComponent, InvertCSG) == 0x000230, "Member 'USimpleMeshWithCachedTreeComponent::InvertCSG' has a wrong offset!");

// Class FSDEngine.ConvexMeshWithCachedTreeComponent
// 0x0010 (0x0250 - 0x0240)
#pragma pack(push, 0x1)
class alignas(0x10) UConvexMeshWithCachedTreeComponent : public USimpleMeshWithCachedTreeComponent
{
public:
	struct FConvexNoiseProperties                 Noise;                                             // 0x0238(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DE[0x4];                                     // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvexMeshWithCachedTreeComponent">();
	}
	static class UConvexMeshWithCachedTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvexMeshWithCachedTreeComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UConvexMeshWithCachedTreeComponent) == 0x000010, "Wrong alignment on UConvexMeshWithCachedTreeComponent");
static_assert(sizeof(UConvexMeshWithCachedTreeComponent) == 0x000250, "Wrong size on UConvexMeshWithCachedTreeComponent");
static_assert(offsetof(UConvexMeshWithCachedTreeComponent, Noise) == 0x000238, "Member 'UConvexMeshWithCachedTreeComponent::Noise' has a wrong offset!");

// Class FSDEngine.CSGConvexColliderComponent
// 0x0000 (0x0250 - 0x0250)
class UCSGConvexColliderComponent final : public UConvexMeshWithCachedTreeComponent
{
public:
	struct FCSGConvexColliderProperties           Properties;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGConvexColliderComponent">();
	}
	static class UCSGConvexColliderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGConvexColliderComponent>();
	}
};
static_assert(alignof(UCSGConvexColliderComponent) == 0x000010, "Wrong alignment on UCSGConvexColliderComponent");
static_assert(sizeof(UCSGConvexColliderComponent) == 0x000250, "Wrong size on UCSGConvexColliderComponent");
static_assert(offsetof(UCSGConvexColliderComponent, Properties) == 0x000248, "Member 'UCSGConvexColliderComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGGroup
// 0x0010 (0x0070 - 0x0060)
class UCSGGroup : public UCSGBase
{
public:
	TArray<class UCSGBase*>                       Children;                                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGGroup">();
	}
	static class UCSGGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGGroup>();
	}
};
static_assert(alignof(UCSGGroup) == 0x000010, "Wrong alignment on UCSGGroup");
static_assert(sizeof(UCSGGroup) == 0x000070, "Wrong size on UCSGGroup");
static_assert(offsetof(UCSGGroup, Children) == 0x000060, "Member 'UCSGGroup::Children' has a wrong offset!");

// Class FSDEngine.CSGGroupComponent
// 0x0000 (0x0200 - 0x0200)
class UCSGGroupComponent : public UCSGBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGGroupComponent">();
	}
	static class UCSGGroupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGGroupComponent>();
	}
};
static_assert(alignof(UCSGGroupComponent) == 0x000010, "Wrong alignment on UCSGGroupComponent");
static_assert(sizeof(UCSGGroupComponent) == 0x000200, "Wrong size on UCSGGroupComponent");

// Class FSDEngine.CSGLayer
// 0x0140 (0x01B0 - 0x0070)
class UCSGLayer final : public UCSGGroup
{
public:
	struct FMeshLayerProperties                   Properties;                                        // 0x0070(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGeneralTerrainMaterialCombiner        Materials;                                         // 0x0098(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBox                                   WorldSpaceBoundingBox;                             // 0x00E8(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DF[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeepCSGFloatTree                      BoundingTree;                                      // 0x0108(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FDeepCSGTree                           TempTree;                                          // 0x0120(0x0048)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E0[0x8];                                     // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                TransformMatInv;                                   // 0x0170(0x0040)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGLayer">();
	}
	static class UCSGLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGLayer>();
	}
};
static_assert(alignof(UCSGLayer) == 0x000010, "Wrong alignment on UCSGLayer");
static_assert(sizeof(UCSGLayer) == 0x0001B0, "Wrong size on UCSGLayer");
static_assert(offsetof(UCSGLayer, Properties) == 0x000070, "Member 'UCSGLayer::Properties' has a wrong offset!");
static_assert(offsetof(UCSGLayer, Materials) == 0x000098, "Member 'UCSGLayer::Materials' has a wrong offset!");
static_assert(offsetof(UCSGLayer, WorldSpaceBoundingBox) == 0x0000E8, "Member 'UCSGLayer::WorldSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGLayer, BoundingTree) == 0x000108, "Member 'UCSGLayer::BoundingTree' has a wrong offset!");
static_assert(offsetof(UCSGLayer, TempTree) == 0x000120, "Member 'UCSGLayer::TempTree' has a wrong offset!");
static_assert(offsetof(UCSGLayer, TransformMatInv) == 0x000170, "Member 'UCSGLayer::TransformMatInv' has a wrong offset!");

// Class FSDEngine.CSGLayerComponent
// 0x0080 (0x0280 - 0x0200)
class UCSGLayerComponent final : public UCSGGroupComponent
{
public:
	struct FMeshLayerProperties                   Properties;                                        // 0x0200(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGeneralTerrainMaterialCombiner        Materials;                                         // 0x0228(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E1[0x8];                                     // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGLayerComponent">();
	}
	static class UCSGLayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGLayerComponent>();
	}
};
static_assert(alignof(UCSGLayerComponent) == 0x000010, "Wrong alignment on UCSGLayerComponent");
static_assert(sizeof(UCSGLayerComponent) == 0x000280, "Wrong size on UCSGLayerComponent");
static_assert(offsetof(UCSGLayerComponent, Properties) == 0x000200, "Member 'UCSGLayerComponent::Properties' has a wrong offset!");
static_assert(offsetof(UCSGLayerComponent, Materials) == 0x000228, "Member 'UCSGLayerComponent::Materials' has a wrong offset!");

// Class FSDEngine.CSGAddMaterialLayers
// 0x0040 (0x00B0 - 0x0070)
class UCSGAddMaterialLayers final : public UCSGSingleChildBase
{
public:
	struct FCSGAddMaterialLayersProperties        Properties;                                        // 0x0068(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E2[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGAddMaterialLayers">();
	}
	static class UCSGAddMaterialLayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGAddMaterialLayers>();
	}
};
static_assert(alignof(UCSGAddMaterialLayers) == 0x000010, "Wrong alignment on UCSGAddMaterialLayers");
static_assert(sizeof(UCSGAddMaterialLayers) == 0x0000B0, "Wrong size on UCSGAddMaterialLayers");
static_assert(offsetof(UCSGAddMaterialLayers, Properties) == 0x000068, "Member 'UCSGAddMaterialLayers::Properties' has a wrong offset!");

// Class FSDEngine.CSGAddMaterialLayersComponent
// 0x0040 (0x0240 - 0x0200)
class UCSGAddMaterialLayersComponent final : public UCSGBaseComponent
{
public:
	struct FCSGAddMaterialLayersProperties        Properties;                                        // 0x0200(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGAddMaterialLayersComponent">();
	}
	static class UCSGAddMaterialLayersComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGAddMaterialLayersComponent>();
	}
};
static_assert(alignof(UCSGAddMaterialLayersComponent) == 0x000010, "Wrong alignment on UCSGAddMaterialLayersComponent");
static_assert(sizeof(UCSGAddMaterialLayersComponent) == 0x000240, "Wrong size on UCSGAddMaterialLayersComponent");
static_assert(offsetof(UCSGAddMaterialLayersComponent, Properties) == 0x000200, "Member 'UCSGAddMaterialLayersComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGRandomizeTransform
// 0x0050 (0x00C0 - 0x0070)
class UCSGRandomizeTransform final : public UCSGSingleChildBase
{
public:
	struct FCSGRandomizeTransformProperties       Properties;                                        // 0x0068(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E3[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGRandomizeTransform">();
	}
	static class UCSGRandomizeTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGRandomizeTransform>();
	}
};
static_assert(alignof(UCSGRandomizeTransform) == 0x000010, "Wrong alignment on UCSGRandomizeTransform");
static_assert(sizeof(UCSGRandomizeTransform) == 0x0000C0, "Wrong size on UCSGRandomizeTransform");
static_assert(offsetof(UCSGRandomizeTransform, Properties) == 0x000068, "Member 'UCSGRandomizeTransform::Properties' has a wrong offset!");

// Class FSDEngine.CSGRandomizeTransformComponent
// 0x0060 (0x0260 - 0x0200)
class UCSGRandomizeTransformComponent final : public UCSGBaseComponent
{
public:
	struct FCSGRandomizeTransformProperties       Properties;                                        // 0x0200(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E4[0xC];                                     // 0x0254(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGRandomizeTransformComponent">();
	}
	static class UCSGRandomizeTransformComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGRandomizeTransformComponent>();
	}
};
static_assert(alignof(UCSGRandomizeTransformComponent) == 0x000010, "Wrong alignment on UCSGRandomizeTransformComponent");
static_assert(sizeof(UCSGRandomizeTransformComponent) == 0x000260, "Wrong size on UCSGRandomizeTransformComponent");
static_assert(offsetof(UCSGRandomizeTransformComponent, Properties) == 0x000200, "Member 'UCSGRandomizeTransformComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGRandomDisable
// 0x0000 (0x0070 - 0x0070)
class UCSGRandomDisable final : public UCSGSingleChildBase
{
public:
	struct FCSGRandomDisableProperties            Properties;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E5[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGRandomDisable">();
	}
	static class UCSGRandomDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGRandomDisable>();
	}
};
static_assert(alignof(UCSGRandomDisable) == 0x000010, "Wrong alignment on UCSGRandomDisable");
static_assert(sizeof(UCSGRandomDisable) == 0x000070, "Wrong size on UCSGRandomDisable");
static_assert(offsetof(UCSGRandomDisable, Properties) == 0x000068, "Member 'UCSGRandomDisable::Properties' has a wrong offset!");

// Class FSDEngine.CSGRandomDisableComponent
// 0x0010 (0x0210 - 0x0200)
class UCSGRandomDisableComponent final : public UCSGBaseComponent
{
public:
	struct FCSGRandomDisableProperties            Properties;                                        // 0x0200(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E6[0xC];                                     // 0x0204(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGRandomDisableComponent">();
	}
	static class UCSGRandomDisableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGRandomDisableComponent>();
	}
};
static_assert(alignof(UCSGRandomDisableComponent) == 0x000010, "Wrong alignment on UCSGRandomDisableComponent");
static_assert(sizeof(UCSGRandomDisableComponent) == 0x000210, "Wrong size on UCSGRandomDisableComponent");
static_assert(offsetof(UCSGRandomDisableComponent, Properties) == 0x000200, "Member 'UCSGRandomDisableComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGGridDuplicator
// 0x0020 (0x0090 - 0x0070)
class UCSGGridDuplicator final : public UCSGDuplicateSingleChildBase
{
public:
	struct FCSGGridDuplicatorProperties           Properties;                                        // 0x0070(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGGridDuplicator">();
	}
	static class UCSGGridDuplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGGridDuplicator>();
	}
};
static_assert(alignof(UCSGGridDuplicator) == 0x000010, "Wrong alignment on UCSGGridDuplicator");
static_assert(sizeof(UCSGGridDuplicator) == 0x000090, "Wrong size on UCSGGridDuplicator");
static_assert(offsetof(UCSGGridDuplicator, Properties) == 0x000070, "Member 'UCSGGridDuplicator::Properties' has a wrong offset!");

// Class FSDEngine.CSGGridDuplicatorComponent
// 0x0020 (0x0220 - 0x0200)
class UCSGGridDuplicatorComponent final : public UCSGBaseComponent
{
public:
	struct FCSGGridDuplicatorProperties           Properties;                                        // 0x0200(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGGridDuplicatorComponent">();
	}
	static class UCSGGridDuplicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGGridDuplicatorComponent>();
	}
};
static_assert(alignof(UCSGGridDuplicatorComponent) == 0x000010, "Wrong alignment on UCSGGridDuplicatorComponent");
static_assert(sizeof(UCSGGridDuplicatorComponent) == 0x000220, "Wrong size on UCSGGridDuplicatorComponent");
static_assert(offsetof(UCSGGridDuplicatorComponent, Properties) == 0x000200, "Member 'UCSGGridDuplicatorComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGCircleDuplicator
// 0x0010 (0x0080 - 0x0070)
class UCSGCircleDuplicator final : public UCSGDuplicateSingleChildBase
{
public:
	struct FCSGCircleDuplicatorProperties         Properties;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E7[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGCircleDuplicator">();
	}
	static class UCSGCircleDuplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGCircleDuplicator>();
	}
};
static_assert(alignof(UCSGCircleDuplicator) == 0x000010, "Wrong alignment on UCSGCircleDuplicator");
static_assert(sizeof(UCSGCircleDuplicator) == 0x000080, "Wrong size on UCSGCircleDuplicator");
static_assert(offsetof(UCSGCircleDuplicator, Properties) == 0x000070, "Member 'UCSGCircleDuplicator::Properties' has a wrong offset!");

// Class FSDEngine.CSGCircleDuplicatorComponent
// 0x0010 (0x0210 - 0x0200)
class UCSGCircleDuplicatorComponent final : public UCSGBaseComponent
{
public:
	struct FCSGCircleDuplicatorProperties         Properties;                                        // 0x0200(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E8[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGCircleDuplicatorComponent">();
	}
	static class UCSGCircleDuplicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGCircleDuplicatorComponent>();
	}
};
static_assert(alignof(UCSGCircleDuplicatorComponent) == 0x000010, "Wrong alignment on UCSGCircleDuplicatorComponent");
static_assert(sizeof(UCSGCircleDuplicatorComponent) == 0x000210, "Wrong size on UCSGCircleDuplicatorComponent");
static_assert(offsetof(UCSGCircleDuplicatorComponent, Properties) == 0x000200, "Member 'UCSGCircleDuplicatorComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGPreviewComponent
// 0x0090 (0x0290 - 0x0200)
class UCSGPreviewComponent final : public USceneComponent
{
public:
	class ACSGBuilderBase*                        BaseBuilder;                                       // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBakeConfig*                            CurrentBakeConfig;                                 // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FChunkId, class UDeepProceduralMeshComponent*> Meshes;                                            // 0x0208(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          UsePreviewScene;                                   // 0x0258(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E9[0x2B];                                    // 0x0259(0x002B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeCount;                                       // 0x0284(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EA[0x8];                                     // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGPreviewComponent">();
	}
	static class UCSGPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGPreviewComponent>();
	}
};
static_assert(alignof(UCSGPreviewComponent) == 0x000010, "Wrong alignment on UCSGPreviewComponent");
static_assert(sizeof(UCSGPreviewComponent) == 0x000290, "Wrong size on UCSGPreviewComponent");
static_assert(offsetof(UCSGPreviewComponent, BaseBuilder) == 0x0001F8, "Member 'UCSGPreviewComponent::BaseBuilder' has a wrong offset!");
static_assert(offsetof(UCSGPreviewComponent, CurrentBakeConfig) == 0x000200, "Member 'UCSGPreviewComponent::CurrentBakeConfig' has a wrong offset!");
static_assert(offsetof(UCSGPreviewComponent, Meshes) == 0x000208, "Member 'UCSGPreviewComponent::Meshes' has a wrong offset!");
static_assert(offsetof(UCSGPreviewComponent, UsePreviewScene) == 0x000258, "Member 'UCSGPreviewComponent::UsePreviewScene' has a wrong offset!");
static_assert(offsetof(UCSGPreviewComponent, ChangeCount) == 0x000284, "Member 'UCSGPreviewComponent::ChangeCount' has a wrong offset!");

// Class FSDEngine.CSGPreviewScene
// 0x0028 (0x0058 - 0x0030)
class UCSGPreviewScene final : public UDataAsset
{
public:
	TSubclassOf<class ACSGBuilder>                Mesh;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBakeSettings                          Settings;                                          // 0x0038(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EB[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTerrainMaterialCore*                   TerrainMaterial;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGPreviewScene">();
	}
	static class UCSGPreviewScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGPreviewScene>();
	}
};
static_assert(alignof(UCSGPreviewScene) == 0x000008, "Wrong alignment on UCSGPreviewScene");
static_assert(sizeof(UCSGPreviewScene) == 0x000058, "Wrong size on UCSGPreviewScene");
static_assert(offsetof(UCSGPreviewScene, Mesh) == 0x000030, "Member 'UCSGPreviewScene::Mesh' has a wrong offset!");
static_assert(offsetof(UCSGPreviewScene, Settings) == 0x000038, "Member 'UCSGPreviewScene::Settings' has a wrong offset!");
static_assert(offsetof(UCSGPreviewScene, Seed) == 0x000048, "Member 'UCSGPreviewScene::Seed' has a wrong offset!");
static_assert(offsetof(UCSGPreviewScene, TerrainMaterial) == 0x000050, "Member 'UCSGPreviewScene::TerrainMaterial' has a wrong offset!");

// Class FSDEngine.CSGPlane
// 0x0000 (0x0120 - 0x0120)
class UCSGPlane final : public UConvexMeshWithCachedTree
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGPlane">();
	}
	static class UCSGPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGPlane>();
	}
};
static_assert(alignof(UCSGPlane) == 0x000010, "Wrong alignment on UCSGPlane");
static_assert(sizeof(UCSGPlane) == 0x000120, "Wrong size on UCSGPlane");

// Class FSDEngine.CSGPlaneComponent
// 0x0000 (0x0250 - 0x0250)
class UCSGPlaneComponent final : public UConvexMeshWithCachedTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGPlaneComponent">();
	}
	static class UCSGPlaneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGPlaneComponent>();
	}
};
static_assert(alignof(UCSGPlaneComponent) == 0x000010, "Wrong alignment on UCSGPlaneComponent");
static_assert(sizeof(UCSGPlaneComponent) == 0x000250, "Wrong size on UCSGPlaneComponent");

// Class FSDEngine.CSGBox
// 0x0020 (0x0140 - 0x0120)
class UCSGBox final : public UConvexMeshWithCachedTree
{
public:
	struct FMeshBoxProperties                     Properties;                                        // 0x0120(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EC[0xC];                                     // 0x0134(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBox">();
	}
	static class UCSGBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBox>();
	}
};
static_assert(alignof(UCSGBox) == 0x000010, "Wrong alignment on UCSGBox");
static_assert(sizeof(UCSGBox) == 0x000140, "Wrong size on UCSGBox");
static_assert(offsetof(UCSGBox, Properties) == 0x000120, "Member 'UCSGBox::Properties' has a wrong offset!");

// Class FSDEngine.CSGBoxComponent
// 0x0010 (0x0260 - 0x0250)
class UCSGBoxComponent final : public UConvexMeshWithCachedTreeComponent
{
public:
	struct FMeshBoxProperties                     Properties;                                        // 0x0248(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27ED[0x4];                                     // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGBoxComponent">();
	}
	static class UCSGBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGBoxComponent>();
	}
};
static_assert(alignof(UCSGBoxComponent) == 0x000010, "Wrong alignment on UCSGBoxComponent");
static_assert(sizeof(UCSGBoxComponent) == 0x000260, "Wrong size on UCSGBoxComponent");
static_assert(offsetof(UCSGBoxComponent, Properties) == 0x000248, "Member 'UCSGBoxComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGCylinder
// 0x0010 (0x0130 - 0x0120)
class UCSGCylinder final : public UConvexMeshWithCachedTree
{
public:
	struct FCSGCylinderProperties                 Properties;                                        // 0x0120(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EE[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGCylinder">();
	}
	static class UCSGCylinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGCylinder>();
	}
};
static_assert(alignof(UCSGCylinder) == 0x000010, "Wrong alignment on UCSGCylinder");
static_assert(sizeof(UCSGCylinder) == 0x000130, "Wrong size on UCSGCylinder");
static_assert(offsetof(UCSGCylinder, Properties) == 0x000120, "Member 'UCSGCylinder::Properties' has a wrong offset!");

// Class FSDEngine.CSGCylinderComponent
// 0x0010 (0x0260 - 0x0250)
class UCSGCylinderComponent final : public UConvexMeshWithCachedTreeComponent
{
public:
	struct FCSGCylinderProperties                 Properties;                                        // 0x0248(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EF[0xC];                                     // 0x0254(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGCylinderComponent">();
	}
	static class UCSGCylinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGCylinderComponent>();
	}
};
static_assert(alignof(UCSGCylinderComponent) == 0x000010, "Wrong alignment on UCSGCylinderComponent");
static_assert(sizeof(UCSGCylinderComponent) == 0x000260, "Wrong size on UCSGCylinderComponent");
static_assert(offsetof(UCSGCylinderComponent, Properties) == 0x000248, "Member 'UCSGCylinderComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGCone
// 0x0010 (0x0130 - 0x0120)
class UCSGCone final : public UConvexMeshWithCachedTree
{
public:
	struct FCSGConeProperties                     Properties;                                        // 0x0120(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGCone">();
	}
	static class UCSGCone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGCone>();
	}
};
static_assert(alignof(UCSGCone) == 0x000010, "Wrong alignment on UCSGCone");
static_assert(sizeof(UCSGCone) == 0x000130, "Wrong size on UCSGCone");
static_assert(offsetof(UCSGCone, Properties) == 0x000120, "Member 'UCSGCone::Properties' has a wrong offset!");

// Class FSDEngine.CSGConeComponent
// 0x0010 (0x0260 - 0x0250)
class UCSGConeComponent final : public UConvexMeshWithCachedTreeComponent
{
public:
	struct FCSGConeProperties                     Properties;                                        // 0x0248(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F0[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGConeComponent">();
	}
	static class UCSGConeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGConeComponent>();
	}
};
static_assert(alignof(UCSGConeComponent) == 0x000010, "Wrong alignment on UCSGConeComponent");
static_assert(sizeof(UCSGConeComponent) == 0x000260, "Wrong size on UCSGConeComponent");
static_assert(offsetof(UCSGConeComponent, Properties) == 0x000248, "Member 'UCSGConeComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGSphere
// 0x0020 (0x0140 - 0x0120)
class UCSGSphere final : public UConvexMeshWithCachedTree
{
public:
	struct FCSGSphereProperties                   Properties;                                        // 0x0120(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F1[0xC];                                     // 0x0134(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSphere">();
	}
	static class UCSGSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSphere>();
	}
};
static_assert(alignof(UCSGSphere) == 0x000010, "Wrong alignment on UCSGSphere");
static_assert(sizeof(UCSGSphere) == 0x000140, "Wrong size on UCSGSphere");
static_assert(offsetof(UCSGSphere, Properties) == 0x000120, "Member 'UCSGSphere::Properties' has a wrong offset!");

// Class FSDEngine.CSGSphereComponent
// 0x0010 (0x0260 - 0x0250)
class UCSGSphereComponent final : public UConvexMeshWithCachedTreeComponent
{
public:
	struct FCSGSphereProperties                   Properties;                                        // 0x0248(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F2[0x4];                                     // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSphereComponent">();
	}
	static class UCSGSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSphereComponent>();
	}
};
static_assert(alignof(UCSGSphereComponent) == 0x000010, "Wrong alignment on UCSGSphereComponent");
static_assert(sizeof(UCSGSphereComponent) == 0x000260, "Wrong size on UCSGSphereComponent");
static_assert(offsetof(UCSGSphereComponent, Properties) == 0x000248, "Member 'UCSGSphereComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGWarped
// 0x00E0 (0x0150 - 0x0070)
class UCSGWarped : public UCSGSingleChildBase
{
public:
	struct FWarpedProperties                      Properties;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F3[0xC0];                                    // 0x0090(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGWarped">();
	}
	static class UCSGWarped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGWarped>();
	}
};
static_assert(alignof(UCSGWarped) == 0x000010, "Wrong alignment on UCSGWarped");
static_assert(sizeof(UCSGWarped) == 0x000150, "Wrong size on UCSGWarped");
static_assert(offsetof(UCSGWarped, Properties) == 0x000068, "Member 'UCSGWarped::Properties' has a wrong offset!");

// Class FSDEngine.CSGWarpedComponent
// 0x0030 (0x0230 - 0x0200)
#pragma pack(push, 0x1)
class alignas(0x10) UCSGWarpedComponent : public UCSGBaseComponent
{
public:
	struct FWarpedProperties                      Properties;                                        // 0x0200(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGWarpedComponent">();
	}
	static class UCSGWarpedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGWarpedComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCSGWarpedComponent) == 0x000010, "Wrong alignment on UCSGWarpedComponent");
static_assert(sizeof(UCSGWarpedComponent) == 0x000230, "Wrong size on UCSGWarpedComponent");
static_assert(offsetof(UCSGWarpedComponent, Properties) == 0x000200, "Member 'UCSGWarpedComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGSplineWarp
// 0x00F0 (0x0240 - 0x0150)
class UCSGSplineWarp final : public UCSGWarped
{
public:
	struct FSplineWarpProperties                  SplineProperties;                                  // 0x0150(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSplineCurves                          SplineCurves;                                      // 0x0170(0x0070)(NativeAccessSpecifierPublic)
	TArray<struct FBox>                           AABBs;                                             // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Keys;                                              // 0x01F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector4>                       Planes;                                            // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBox                                   TotalAABB;                                         // 0x0210(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F4[0x14];                                    // 0x022C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSplineWarp">();
	}
	static class UCSGSplineWarp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSplineWarp>();
	}
};
static_assert(alignof(UCSGSplineWarp) == 0x000010, "Wrong alignment on UCSGSplineWarp");
static_assert(sizeof(UCSGSplineWarp) == 0x000240, "Wrong size on UCSGSplineWarp");
static_assert(offsetof(UCSGSplineWarp, SplineProperties) == 0x000150, "Member 'UCSGSplineWarp::SplineProperties' has a wrong offset!");
static_assert(offsetof(UCSGSplineWarp, SplineCurves) == 0x000170, "Member 'UCSGSplineWarp::SplineCurves' has a wrong offset!");
static_assert(offsetof(UCSGSplineWarp, AABBs) == 0x0001E0, "Member 'UCSGSplineWarp::AABBs' has a wrong offset!");
static_assert(offsetof(UCSGSplineWarp, Keys) == 0x0001F0, "Member 'UCSGSplineWarp::Keys' has a wrong offset!");
static_assert(offsetof(UCSGSplineWarp, Planes) == 0x000200, "Member 'UCSGSplineWarp::Planes' has a wrong offset!");
static_assert(offsetof(UCSGSplineWarp, TotalAABB) == 0x000210, "Member 'UCSGSplineWarp::TotalAABB' has a wrong offset!");

// Class FSDEngine.CSGSplineWarpComponent
// 0x0020 (0x0250 - 0x0230)
class UCSGSplineWarpComponent final : public UCSGWarpedComponent
{
public:
	struct FSplineWarpProperties                  SplineProperties;                                  // 0x0228(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F5[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSplineWarpComponent">();
	}
	static class UCSGSplineWarpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSplineWarpComponent>();
	}
};
static_assert(alignof(UCSGSplineWarpComponent) == 0x000010, "Wrong alignment on UCSGSplineWarpComponent");
static_assert(sizeof(UCSGSplineWarpComponent) == 0x000250, "Wrong size on UCSGSplineWarpComponent");
static_assert(offsetof(UCSGSplineWarpComponent, SplineProperties) == 0x000228, "Member 'UCSGSplineWarpComponent::SplineProperties' has a wrong offset!");

// Class FSDEngine.CSGSDFInstanceComponent
// 0x0060 (0x0260 - 0x0200)
class UCSGSDFInstanceComponent final : public UCSGBaseComponent
{
public:
	struct FCSGSDFInstanceProperties              Properties;                                        // 0x0200(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x0228(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F6[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSDFInstanceComponent">();
	}
	static class UCSGSDFInstanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSDFInstanceComponent>();
	}
};
static_assert(alignof(UCSGSDFInstanceComponent) == 0x000010, "Wrong alignment on UCSGSDFInstanceComponent");
static_assert(sizeof(UCSGSDFInstanceComponent) == 0x000260, "Wrong size on UCSGSDFInstanceComponent");
static_assert(offsetof(UCSGSDFInstanceComponent, Properties) == 0x000200, "Member 'UCSGSDFInstanceComponent::Properties' has a wrong offset!");
static_assert(offsetof(UCSGSDFInstanceComponent, Materials) == 0x000228, "Member 'UCSGSDFInstanceComponent::Materials' has a wrong offset!");

// Class FSDEngine.CSGModulatedSDFInstance
// 0x01B0 (0x0210 - 0x0060)
class UCSGModulatedSDFInstance final : public UCSGBase
{
public:
	struct FCSGSDFModulatedInstanceProperties     Properties;                                        // 0x0060(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x00B0(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USDFBase*                               CSGSDFInstanceRoot;                                // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBakeConfig*                            CurrentBakeConfig;                                 // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USDFBase*                               CSGSDFModulatedInstanceRoot;                       // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBakeConfig*                            CurrentModulatedBakeConfig;                        // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ChildLocalSpaceBoundingBox;                        // 0x0100(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   WorldSpaceBoundingBox;                             // 0x011C(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDeepCSGFloatTree                      BoundingTree;                                      // 0x0138(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FMatrix                                TransformMatInv;                                   // 0x0150(0x0040)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F7[0x80];                                    // 0x0190(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGModulatedSDFInstance">();
	}
	static class UCSGModulatedSDFInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGModulatedSDFInstance>();
	}
};
static_assert(alignof(UCSGModulatedSDFInstance) == 0x000010, "Wrong alignment on UCSGModulatedSDFInstance");
static_assert(sizeof(UCSGModulatedSDFInstance) == 0x000210, "Wrong size on UCSGModulatedSDFInstance");
static_assert(offsetof(UCSGModulatedSDFInstance, Properties) == 0x000060, "Member 'UCSGModulatedSDFInstance::Properties' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, Materials) == 0x0000B0, "Member 'UCSGModulatedSDFInstance::Materials' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, CSGSDFInstanceRoot) == 0x0000E0, "Member 'UCSGModulatedSDFInstance::CSGSDFInstanceRoot' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, CurrentBakeConfig) == 0x0000E8, "Member 'UCSGModulatedSDFInstance::CurrentBakeConfig' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, CSGSDFModulatedInstanceRoot) == 0x0000F0, "Member 'UCSGModulatedSDFInstance::CSGSDFModulatedInstanceRoot' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, CurrentModulatedBakeConfig) == 0x0000F8, "Member 'UCSGModulatedSDFInstance::CurrentModulatedBakeConfig' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, ChildLocalSpaceBoundingBox) == 0x000100, "Member 'UCSGModulatedSDFInstance::ChildLocalSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, WorldSpaceBoundingBox) == 0x00011C, "Member 'UCSGModulatedSDFInstance::WorldSpaceBoundingBox' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, BoundingTree) == 0x000138, "Member 'UCSGModulatedSDFInstance::BoundingTree' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstance, TransformMatInv) == 0x000150, "Member 'UCSGModulatedSDFInstance::TransformMatInv' has a wrong offset!");

// Class FSDEngine.CSGModulatedSDFInstanceComponent
// 0x0080 (0x0280 - 0x0200)
class UCSGModulatedSDFInstanceComponent final : public UCSGBaseComponent
{
public:
	struct FCSGSDFModulatedInstanceProperties     Properties;                                        // 0x0200(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBinaryTerrainMaterialCombiner         Materials;                                         // 0x0250(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGModulatedSDFInstanceComponent">();
	}
	static class UCSGModulatedSDFInstanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGModulatedSDFInstanceComponent>();
	}
};
static_assert(alignof(UCSGModulatedSDFInstanceComponent) == 0x000010, "Wrong alignment on UCSGModulatedSDFInstanceComponent");
static_assert(sizeof(UCSGModulatedSDFInstanceComponent) == 0x000280, "Wrong size on UCSGModulatedSDFInstanceComponent");
static_assert(offsetof(UCSGModulatedSDFInstanceComponent, Properties) == 0x000200, "Member 'UCSGModulatedSDFInstanceComponent::Properties' has a wrong offset!");
static_assert(offsetof(UCSGModulatedSDFInstanceComponent, Materials) == 0x000250, "Member 'UCSGModulatedSDFInstanceComponent::Materials' has a wrong offset!");

// Class FSDEngine.CSGVoronoi
// 0x0020 (0x00F0 - 0x00D0)
class UCSGVoronoi final : public USimpleMeshWithCachedTree
{
public:
	struct FVoronoiProperties                     Properties;                                        // 0x00D0(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F8[0x4];                                     // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGVoronoi">();
	}
	static class UCSGVoronoi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGVoronoi>();
	}
};
static_assert(alignof(UCSGVoronoi) == 0x000010, "Wrong alignment on UCSGVoronoi");
static_assert(sizeof(UCSGVoronoi) == 0x0000F0, "Wrong size on UCSGVoronoi");
static_assert(offsetof(UCSGVoronoi, Properties) == 0x0000D0, "Member 'UCSGVoronoi::Properties' has a wrong offset!");

// Class FSDEngine.CSGVoronoiComponent
// 0x0020 (0x0260 - 0x0240)
class UCSGVoronoiComponent final : public USimpleMeshWithCachedTreeComponent
{
public:
	struct FVoronoiProperties                     Properties;                                        // 0x0238(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F9[0xC];                                     // 0x0254(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGVoronoiComponent">();
	}
	static class UCSGVoronoiComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGVoronoiComponent>();
	}
};
static_assert(alignof(UCSGVoronoiComponent) == 0x000010, "Wrong alignment on UCSGVoronoiComponent");
static_assert(sizeof(UCSGVoronoiComponent) == 0x000260, "Wrong size on UCSGVoronoiComponent");
static_assert(offsetof(UCSGVoronoiComponent, Properties) == 0x000238, "Member 'UCSGVoronoiComponent::Properties' has a wrong offset!");

// Class FSDEngine.CSGSTL
// 0x0010 (0x00E0 - 0x00D0)
class UCSGSTL final : public USimpleMeshWithCachedTree
{
public:
	struct FCSGSTLProperties                      Properties;                                        // 0x00D0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FA[0x8];                                     // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSTL">();
	}
	static class UCSGSTL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSTL>();
	}
};
static_assert(alignof(UCSGSTL) == 0x000010, "Wrong alignment on UCSGSTL");
static_assert(sizeof(UCSGSTL) == 0x0000E0, "Wrong size on UCSGSTL");
static_assert(offsetof(UCSGSTL, Properties) == 0x0000D0, "Member 'UCSGSTL::Properties' has a wrong offset!");

// Class FSDEngine.CSGSTLComponent
// 0x0000 (0x0240 - 0x0240)
class UCSGSTLComponent final : public USimpleMeshWithCachedTreeComponent
{
public:
	struct FCSGSTLProperties                      Properties;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGSTLComponent">();
	}
	static class UCSGSTLComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGSTLComponent>();
	}
};
static_assert(alignof(UCSGSTLComponent) == 0x000010, "Wrong alignment on UCSGSTLComponent");
static_assert(sizeof(UCSGSTLComponent) == 0x000240, "Wrong size on UCSGSTLComponent");
static_assert(offsetof(UCSGSTLComponent, Properties) == 0x000238, "Member 'UCSGSTLComponent::Properties' has a wrong offset!");

// Class FSDEngine.DeepCSGSection
// 0x0008 (0x0228 - 0x0220)
class ADeepCSGSection final : public AActor
{
public:
	class UDeepProceduralMeshComponent*           DeepMesh;                                          // 0x0220(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeepCSGSection">();
	}
	static class ADeepCSGSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeepCSGSection>();
	}
};
static_assert(alignof(ADeepCSGSection) == 0x000008, "Wrong alignment on ADeepCSGSection");
static_assert(sizeof(ADeepCSGSection) == 0x000228, "Wrong size on ADeepCSGSection");
static_assert(offsetof(ADeepCSGSection, DeepMesh) == 0x000220, "Member 'ADeepCSGSection::DeepMesh' has a wrong offset!");

// Class FSDEngine.DeepProceduralMeshComponent
// 0x0050 (0x04D0 - 0x0480)
class UDeepProceduralMeshComponent final : public UMeshComponent
{
public:
	class UBodySetup*                             ProcMeshBodySetup;                                 // 0x0478(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FB[0x50];                                    // 0x0480(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTerrainMaterialCore* FindTerrainMaterialFromPhysicalMaterial(class UPhysicalMaterial* Material) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeepProceduralMeshComponent">();
	}
	static class UDeepProceduralMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeepProceduralMeshComponent>();
	}
};
static_assert(alignof(UDeepProceduralMeshComponent) == 0x000010, "Wrong alignment on UDeepProceduralMeshComponent");
static_assert(sizeof(UDeepProceduralMeshComponent) == 0x0004D0, "Wrong size on UDeepProceduralMeshComponent");
static_assert(offsetof(UDeepProceduralMeshComponent, ProcMeshBodySetup) == 0x000478, "Member 'UDeepProceduralMeshComponent::ProcMeshBodySetup' has a wrong offset!");

// Class FSDEngine.SDFBuilder
// 0x0020 (0x02A8 - 0x0288)
class ASDFBuilder final : public ACSGBuilderBase
{
public:
	EPreviewCellSize                              PreviewSize;                                       // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FC[0x7];                                     // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTerrainMaterialCore*                   PreviewMaterial;                                   // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USDFBase*                               CurrentRoot;                                       // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USDFUnionOpComponent*                   SDFRoot;                                           // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFBuilder">();
	}
	static class ASDFBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASDFBuilder>();
	}
};
static_assert(alignof(ASDFBuilder) == 0x000008, "Wrong alignment on ASDFBuilder");
static_assert(sizeof(ASDFBuilder) == 0x0002A8, "Wrong size on ASDFBuilder");
static_assert(offsetof(ASDFBuilder, PreviewSize) == 0x000288, "Member 'ASDFBuilder::PreviewSize' has a wrong offset!");
static_assert(offsetof(ASDFBuilder, PreviewMaterial) == 0x000290, "Member 'ASDFBuilder::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(ASDFBuilder, CurrentRoot) == 0x000298, "Member 'ASDFBuilder::CurrentRoot' has a wrong offset!");
static_assert(offsetof(ASDFBuilder, SDFRoot) == 0x0002A0, "Member 'ASDFBuilder::SDFRoot' has a wrong offset!");

// Class FSDEngine.HeightMapWithMinMaxQuadTree
// 0x0090 (0x00C0 - 0x0030)
class UHeightMapWithMinMaxQuadTree final : public UDataAsset
{
public:
	class FString                                 Status;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  InputRenderTarget;                                 // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                InputTexture;                                      // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHMMinMaxLevel>                 MinMaxTree;                                        // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinHeight;                                         // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Heights;                                           // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Dimensions;                                        // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Initialized;                                       // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FD[0x3];                                     // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Generate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeightMapWithMinMaxQuadTree">();
	}
	static class UHeightMapWithMinMaxQuadTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeightMapWithMinMaxQuadTree>();
	}
};
static_assert(alignof(UHeightMapWithMinMaxQuadTree) == 0x000008, "Wrong alignment on UHeightMapWithMinMaxQuadTree");
static_assert(sizeof(UHeightMapWithMinMaxQuadTree) == 0x0000C0, "Wrong size on UHeightMapWithMinMaxQuadTree");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, Status) == 0x000030, "Member 'UHeightMapWithMinMaxQuadTree::Status' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, InputRenderTarget) == 0x000040, "Member 'UHeightMapWithMinMaxQuadTree::InputRenderTarget' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, InputTexture) == 0x000068, "Member 'UHeightMapWithMinMaxQuadTree::InputTexture' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, MinMaxTree) == 0x000090, "Member 'UHeightMapWithMinMaxQuadTree::MinMaxTree' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, MinHeight) == 0x0000A0, "Member 'UHeightMapWithMinMaxQuadTree::MinHeight' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, MaxHeight) == 0x0000A4, "Member 'UHeightMapWithMinMaxQuadTree::MaxHeight' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, Heights) == 0x0000A8, "Member 'UHeightMapWithMinMaxQuadTree::Heights' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, Dimensions) == 0x0000B8, "Member 'UHeightMapWithMinMaxQuadTree::Dimensions' has a wrong offset!");
static_assert(offsetof(UHeightMapWithMinMaxQuadTree, Initialized) == 0x0000BC, "Member 'UHeightMapWithMinMaxQuadTree::Initialized' has a wrong offset!");

// Class FSDEngine.SDFBase
// 0x0038 (0x0060 - 0x0028)
class USDFBase : public UBuilderBase
{
public:
	struct FSDFBaseProperties                     BaseProperties;                                    // 0x0028(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FE[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFBase">();
	}
	static class USDFBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFBase>();
	}
};
static_assert(alignof(USDFBase) == 0x000010, "Wrong alignment on USDFBase");
static_assert(sizeof(USDFBase) == 0x000060, "Wrong size on USDFBase");
static_assert(offsetof(USDFBase, BaseProperties) == 0x000028, "Member 'USDFBase::BaseProperties' has a wrong offset!");
static_assert(offsetof(USDFBase, RelativeTransform) == 0x000030, "Member 'USDFBase::RelativeTransform' has a wrong offset!");

// Class FSDEngine.SDFHeightMap
// 0x0020 (0x0080 - 0x0060)
class USDFHeightMap final : public USDFBase
{
public:
	struct FSDFHeightMaproperties                 Properties;                                        // 0x0060(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FF[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHeightMapWithMinMaxQuadTree*           Heightmap;                                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2800[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFHeightMap">();
	}
	static class USDFHeightMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFHeightMap>();
	}
};
static_assert(alignof(USDFHeightMap) == 0x000010, "Wrong alignment on USDFHeightMap");
static_assert(sizeof(USDFHeightMap) == 0x000080, "Wrong size on USDFHeightMap");
static_assert(offsetof(USDFHeightMap, Properties) == 0x000060, "Member 'USDFHeightMap::Properties' has a wrong offset!");
static_assert(offsetof(USDFHeightMap, Heightmap) == 0x000070, "Member 'USDFHeightMap::Heightmap' has a wrong offset!");

// Class FSDEngine.SDFBaseComponent
// 0x0000 (0x0200 - 0x0200)
class USDFBaseComponent : public UCSGBuilderBaseSceneComponent
{
public:
	struct FSDFBaseProperties                     BaseProperties;                                    // 0x01F8(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2801[0x7];                                     // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFBaseComponent">();
	}
	static class USDFBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFBaseComponent>();
	}
};
static_assert(alignof(USDFBaseComponent) == 0x000010, "Wrong alignment on USDFBaseComponent");
static_assert(sizeof(USDFBaseComponent) == 0x000200, "Wrong size on USDFBaseComponent");
static_assert(offsetof(USDFBaseComponent, BaseProperties) == 0x0001F8, "Member 'USDFBaseComponent::BaseProperties' has a wrong offset!");

// Class FSDEngine.SDFHeightMapComponent
// 0x0020 (0x0220 - 0x0200)
class USDFHeightMapComponent final : public USDFBaseComponent
{
public:
	struct FSDFHeightMaproperties                 Properties;                                        // 0x0200(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2802[0x4];                                     // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHeightMapWithMinMaxQuadTree*           Heightmap;                                         // 0x0210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2803[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFHeightMapComponent">();
	}
	static class USDFHeightMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFHeightMapComponent>();
	}
};
static_assert(alignof(USDFHeightMapComponent) == 0x000010, "Wrong alignment on USDFHeightMapComponent");
static_assert(sizeof(USDFHeightMapComponent) == 0x000220, "Wrong size on USDFHeightMapComponent");
static_assert(offsetof(USDFHeightMapComponent, Properties) == 0x000200, "Member 'USDFHeightMapComponent::Properties' has a wrong offset!");
static_assert(offsetof(USDFHeightMapComponent, Heightmap) == 0x000210, "Member 'USDFHeightMapComponent::Heightmap' has a wrong offset!");

// Class FSDEngine.SDFSingleChildBase
// 0x0010 (0x0070 - 0x0060)
#pragma pack(push, 0x1)
class alignas(0x10) USDFSingleChildBase : public USDFBase
{
public:
	class USDFBase*                               Child;                                             // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFSingleChildBase">();
	}
	static class USDFSingleChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFSingleChildBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(USDFSingleChildBase) == 0x000010, "Wrong alignment on USDFSingleChildBase");
static_assert(sizeof(USDFSingleChildBase) == 0x000070, "Wrong size on USDFSingleChildBase");
static_assert(offsetof(USDFSingleChildBase, Child) == 0x000060, "Member 'USDFSingleChildBase::Child' has a wrong offset!");

// Class FSDEngine.SDFModifier
// 0x0070 (0x00E0 - 0x0070)
class USDFModifier final : public USDFSingleChildBase
{
public:
	struct FSDFModifierProperties                 Properties;                                        // 0x0068(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2804[0x40];                                    // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFModifier">();
	}
	static class USDFModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFModifier>();
	}
};
static_assert(alignof(USDFModifier) == 0x000010, "Wrong alignment on USDFModifier");
static_assert(sizeof(USDFModifier) == 0x0000E0, "Wrong size on USDFModifier");
static_assert(offsetof(USDFModifier, Properties) == 0x000068, "Member 'USDFModifier::Properties' has a wrong offset!");

// Class FSDEngine.SDFModifierComponent
// 0x0040 (0x0240 - 0x0200)
class USDFModifierComponent final : public USDFBaseComponent
{
public:
	struct FSDFModifierProperties                 Properties;                                        // 0x0200(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2805[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFModifierComponent">();
	}
	static class USDFModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFModifierComponent>();
	}
};
static_assert(alignof(USDFModifierComponent) == 0x000010, "Wrong alignment on USDFModifierComponent");
static_assert(sizeof(USDFModifierComponent) == 0x000240, "Wrong size on USDFModifierComponent");
static_assert(offsetof(USDFModifierComponent, Properties) == 0x000200, "Member 'USDFModifierComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFUnionOp
// 0x0020 (0x0080 - 0x0060)
class USDFUnionOp final : public USDFBase
{
public:
	struct FSDFSmoothingProperties                Properties;                                        // 0x0060(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<class USDFBase*>                       Arguments;                                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2806[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFUnionOp">();
	}
	static class USDFUnionOp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFUnionOp>();
	}
};
static_assert(alignof(USDFUnionOp) == 0x000010, "Wrong alignment on USDFUnionOp");
static_assert(sizeof(USDFUnionOp) == 0x000080, "Wrong size on USDFUnionOp");
static_assert(offsetof(USDFUnionOp, Properties) == 0x000060, "Member 'USDFUnionOp::Properties' has a wrong offset!");
static_assert(offsetof(USDFUnionOp, Arguments) == 0x000068, "Member 'USDFUnionOp::Arguments' has a wrong offset!");

// Class FSDEngine.SDFUnionOpComponent
// 0x0010 (0x0210 - 0x0200)
class USDFUnionOpComponent final : public USDFBaseComponent
{
public:
	struct FSDFSmoothingProperties                Properties;                                        // 0x0200(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2807[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFUnionOpComponent">();
	}
	static class USDFUnionOpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFUnionOpComponent>();
	}
};
static_assert(alignof(USDFUnionOpComponent) == 0x000010, "Wrong alignment on USDFUnionOpComponent");
static_assert(sizeof(USDFUnionOpComponent) == 0x000210, "Wrong size on USDFUnionOpComponent");
static_assert(offsetof(USDFUnionOpComponent, Properties) == 0x000200, "Member 'USDFUnionOpComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFIntersectOp
// 0x0020 (0x0080 - 0x0060)
class USDFIntersectOp final : public USDFBase
{
public:
	struct FSDFSmoothingProperties                Properties;                                        // 0x0060(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<class USDFBase*>                       Arguments;                                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2808[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFIntersectOp">();
	}
	static class USDFIntersectOp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFIntersectOp>();
	}
};
static_assert(alignof(USDFIntersectOp) == 0x000010, "Wrong alignment on USDFIntersectOp");
static_assert(sizeof(USDFIntersectOp) == 0x000080, "Wrong size on USDFIntersectOp");
static_assert(offsetof(USDFIntersectOp, Properties) == 0x000060, "Member 'USDFIntersectOp::Properties' has a wrong offset!");
static_assert(offsetof(USDFIntersectOp, Arguments) == 0x000068, "Member 'USDFIntersectOp::Arguments' has a wrong offset!");

// Class FSDEngine.SDFIntersectOpComponent
// 0x0010 (0x0210 - 0x0200)
class USDFIntersectOpComponent final : public USDFBaseComponent
{
public:
	struct FSDFSmoothingProperties                Properties;                                        // 0x0200(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2809[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFIntersectOpComponent">();
	}
	static class USDFIntersectOpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFIntersectOpComponent>();
	}
};
static_assert(alignof(USDFIntersectOpComponent) == 0x000010, "Wrong alignment on USDFIntersectOpComponent");
static_assert(sizeof(USDFIntersectOpComponent) == 0x000210, "Wrong size on USDFIntersectOpComponent");
static_assert(offsetof(USDFIntersectOpComponent, Properties) == 0x000200, "Member 'USDFIntersectOpComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFSubOp
// 0x0020 (0x0080 - 0x0060)
class USDFSubOp final : public USDFBase
{
public:
	struct FSDFSmoothingProperties                Properties;                                        // 0x0060(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	class USDFBase*                               A;                                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USDFBase*                               B;                                                 // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280A[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFSubOp">();
	}
	static class USDFSubOp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFSubOp>();
	}
};
static_assert(alignof(USDFSubOp) == 0x000010, "Wrong alignment on USDFSubOp");
static_assert(sizeof(USDFSubOp) == 0x000080, "Wrong size on USDFSubOp");
static_assert(offsetof(USDFSubOp, Properties) == 0x000060, "Member 'USDFSubOp::Properties' has a wrong offset!");
static_assert(offsetof(USDFSubOp, A) == 0x000068, "Member 'USDFSubOp::A' has a wrong offset!");
static_assert(offsetof(USDFSubOp, B) == 0x000070, "Member 'USDFSubOp::B' has a wrong offset!");

// Class FSDEngine.SDFSubOpComponent
// 0x0010 (0x0210 - 0x0200)
class USDFSubOpComponent final : public USDFBaseComponent
{
public:
	struct FSDFSmoothingProperties                Properties;                                        // 0x0200(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280B[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFSubOpComponent">();
	}
	static class USDFSubOpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFSubOpComponent>();
	}
};
static_assert(alignof(USDFSubOpComponent) == 0x000010, "Wrong alignment on USDFSubOpComponent");
static_assert(sizeof(USDFSubOpComponent) == 0x000210, "Wrong size on USDFSubOpComponent");
static_assert(offsetof(USDFSubOpComponent, Properties) == 0x000200, "Member 'USDFSubOpComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFOnion
// 0x0010 (0x0070 - 0x0060)
class USDFOnion final : public USDFBase
{
public:
	struct FSDFOnionProperties                    Properties;                                        // 0x0060(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280C[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USDFBase*                               Argument;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFOnion">();
	}
	static class USDFOnion* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFOnion>();
	}
};
static_assert(alignof(USDFOnion) == 0x000010, "Wrong alignment on USDFOnion");
static_assert(sizeof(USDFOnion) == 0x000070, "Wrong size on USDFOnion");
static_assert(offsetof(USDFOnion, Properties) == 0x000060, "Member 'USDFOnion::Properties' has a wrong offset!");
static_assert(offsetof(USDFOnion, Argument) == 0x000068, "Member 'USDFOnion::Argument' has a wrong offset!");

// Class FSDEngine.SDFOnionComponent
// 0x0010 (0x0210 - 0x0200)
class USDFOnionComponent final : public USDFBaseComponent
{
public:
	struct FSDFOnionProperties                    Properties;                                        // 0x0200(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280D[0xC];                                     // 0x0204(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFOnionComponent">();
	}
	static class USDFOnionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFOnionComponent>();
	}
};
static_assert(alignof(USDFOnionComponent) == 0x000010, "Wrong alignment on USDFOnionComponent");
static_assert(sizeof(USDFOnionComponent) == 0x000210, "Wrong size on USDFOnionComponent");
static_assert(offsetof(USDFOnionComponent, Properties) == 0x000200, "Member 'USDFOnionComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFRandomizeTransform
// 0x0050 (0x00C0 - 0x0070)
class USDFRandomizeTransform final : public USDFSingleChildBase
{
public:
	struct FSDFRandomizeTransformProperties       Properties;                                        // 0x0068(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280E[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFRandomizeTransform">();
	}
	static class USDFRandomizeTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFRandomizeTransform>();
	}
};
static_assert(alignof(USDFRandomizeTransform) == 0x000010, "Wrong alignment on USDFRandomizeTransform");
static_assert(sizeof(USDFRandomizeTransform) == 0x0000C0, "Wrong size on USDFRandomizeTransform");
static_assert(offsetof(USDFRandomizeTransform, Properties) == 0x000068, "Member 'USDFRandomizeTransform::Properties' has a wrong offset!");

// Class FSDEngine.SDFRandomizeTransformComponent
// 0x0060 (0x0260 - 0x0200)
class USDFRandomizeTransformComponent final : public USDFBaseComponent
{
public:
	struct FSDFRandomizeTransformProperties       Properties;                                        // 0x0200(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280F[0xC];                                     // 0x0254(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFRandomizeTransformComponent">();
	}
	static class USDFRandomizeTransformComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFRandomizeTransformComponent>();
	}
};
static_assert(alignof(USDFRandomizeTransformComponent) == 0x000010, "Wrong alignment on USDFRandomizeTransformComponent");
static_assert(sizeof(USDFRandomizeTransformComponent) == 0x000260, "Wrong size on USDFRandomizeTransformComponent");
static_assert(offsetof(USDFRandomizeTransformComponent, Properties) == 0x000200, "Member 'USDFRandomizeTransformComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFRandomDisable
// 0x0000 (0x0070 - 0x0070)
class USDFRandomDisable final : public USDFSingleChildBase
{
public:
	struct FSDFRandomDisableProperties            Properties;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2810[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFRandomDisable">();
	}
	static class USDFRandomDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFRandomDisable>();
	}
};
static_assert(alignof(USDFRandomDisable) == 0x000010, "Wrong alignment on USDFRandomDisable");
static_assert(sizeof(USDFRandomDisable) == 0x000070, "Wrong size on USDFRandomDisable");
static_assert(offsetof(USDFRandomDisable, Properties) == 0x000068, "Member 'USDFRandomDisable::Properties' has a wrong offset!");

// Class FSDEngine.SDFRandomDisableComponent
// 0x0010 (0x0210 - 0x0200)
class USDFRandomDisableComponent final : public USDFBaseComponent
{
public:
	struct FSDFRandomDisableProperties            Properties;                                        // 0x0200(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2811[0xC];                                     // 0x0204(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFRandomDisableComponent">();
	}
	static class USDFRandomDisableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFRandomDisableComponent>();
	}
};
static_assert(alignof(USDFRandomDisableComponent) == 0x000010, "Wrong alignment on USDFRandomDisableComponent");
static_assert(sizeof(USDFRandomDisableComponent) == 0x000210, "Wrong size on USDFRandomDisableComponent");
static_assert(offsetof(USDFRandomDisableComponent, Properties) == 0x000200, "Member 'USDFRandomDisableComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFBaseWithTransform
// 0x00D0 (0x0130 - 0x0060)
class USDFBaseWithTransform : public USDFBase
{
public:
	uint8                                         Pad_2812[0xD0];                                    // 0x0060(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFBaseWithTransform">();
	}
	static class USDFBaseWithTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFBaseWithTransform>();
	}
};
static_assert(alignof(USDFBaseWithTransform) == 0x000010, "Wrong alignment on USDFBaseWithTransform");
static_assert(sizeof(USDFBaseWithTransform) == 0x000130, "Wrong size on USDFBaseWithTransform");

// Class FSDEngine.SDFBaseWithTransformComponent
// 0x0000 (0x0200 - 0x0200)
class USDFBaseWithTransformComponent : public USDFBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFBaseWithTransformComponent">();
	}
	static class USDFBaseWithTransformComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFBaseWithTransformComponent>();
	}
};
static_assert(alignof(USDFBaseWithTransformComponent) == 0x000010, "Wrong alignment on USDFBaseWithTransformComponent");
static_assert(sizeof(USDFBaseWithTransformComponent) == 0x000200, "Wrong size on USDFBaseWithTransformComponent");

// Class FSDEngine.SDFSphere
// 0x0010 (0x0140 - 0x0130)
class USDFSphere final : public USDFBaseWithTransform
{
public:
	struct FSDFSphereProperties                   Properties;                                        // 0x0130(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2813[0x4];                                     // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFSphere">();
	}
	static class USDFSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFSphere>();
	}
};
static_assert(alignof(USDFSphere) == 0x000010, "Wrong alignment on USDFSphere");
static_assert(sizeof(USDFSphere) == 0x000140, "Wrong size on USDFSphere");
static_assert(offsetof(USDFSphere, Properties) == 0x000130, "Member 'USDFSphere::Properties' has a wrong offset!");

// Class FSDEngine.SDFSphereComponent
// 0x0010 (0x0210 - 0x0200)
class USDFSphereComponent final : public USDFBaseWithTransformComponent
{
public:
	struct FSDFSphereProperties                   Properties;                                        // 0x0200(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2814[0x4];                                     // 0x020C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFSphereComponent">();
	}
	static class USDFSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFSphereComponent>();
	}
};
static_assert(alignof(USDFSphereComponent) == 0x000010, "Wrong alignment on USDFSphereComponent");
static_assert(sizeof(USDFSphereComponent) == 0x000210, "Wrong size on USDFSphereComponent");
static_assert(offsetof(USDFSphereComponent, Properties) == 0x000200, "Member 'USDFSphereComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFPlane
// 0x0000 (0x0130 - 0x0130)
class USDFPlane final : public USDFBaseWithTransform
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFPlane">();
	}
	static class USDFPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFPlane>();
	}
};
static_assert(alignof(USDFPlane) == 0x000010, "Wrong alignment on USDFPlane");
static_assert(sizeof(USDFPlane) == 0x000130, "Wrong size on USDFPlane");

// Class FSDEngine.SDFPlaneComponent
// 0x0000 (0x0200 - 0x0200)
class USDFPlaneComponent final : public USDFBaseWithTransformComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFPlaneComponent">();
	}
	static class USDFPlaneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFPlaneComponent>();
	}
};
static_assert(alignof(USDFPlaneComponent) == 0x000010, "Wrong alignment on USDFPlaneComponent");
static_assert(sizeof(USDFPlaneComponent) == 0x000200, "Wrong size on USDFPlaneComponent");

// Class FSDEngine.SDFBox
// 0x0010 (0x0140 - 0x0130)
class USDFBox final : public USDFBaseWithTransform
{
public:
	struct FSDFBoxProperties                      Properties;                                        // 0x0130(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2815[0x4];                                     // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFBox">();
	}
	static class USDFBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFBox>();
	}
};
static_assert(alignof(USDFBox) == 0x000010, "Wrong alignment on USDFBox");
static_assert(sizeof(USDFBox) == 0x000140, "Wrong size on USDFBox");
static_assert(offsetof(USDFBox, Properties) == 0x000130, "Member 'USDFBox::Properties' has a wrong offset!");

// Class FSDEngine.SDFBoxComponent
// 0x0010 (0x0210 - 0x0200)
class USDFBoxComponent final : public USDFBaseWithTransformComponent
{
public:
	struct FSDFBoxProperties                      Properties;                                        // 0x0200(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2816[0x4];                                     // 0x020C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFBoxComponent">();
	}
	static class USDFBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFBoxComponent>();
	}
};
static_assert(alignof(USDFBoxComponent) == 0x000010, "Wrong alignment on USDFBoxComponent");
static_assert(sizeof(USDFBoxComponent) == 0x000210, "Wrong size on USDFBoxComponent");
static_assert(offsetof(USDFBoxComponent, Properties) == 0x000200, "Member 'USDFBoxComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFCylinder
// 0x0010 (0x0140 - 0x0130)
class USDFCylinder final : public USDFBaseWithTransform
{
public:
	struct FSDFCylinderProperties                 Properties;                                        // 0x0130(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2817[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFCylinder">();
	}
	static class USDFCylinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFCylinder>();
	}
};
static_assert(alignof(USDFCylinder) == 0x000010, "Wrong alignment on USDFCylinder");
static_assert(sizeof(USDFCylinder) == 0x000140, "Wrong size on USDFCylinder");
static_assert(offsetof(USDFCylinder, Properties) == 0x000130, "Member 'USDFCylinder::Properties' has a wrong offset!");

// Class FSDEngine.SDFCylinderComponent
// 0x0010 (0x0210 - 0x0200)
class USDFCylinderComponent final : public USDFBaseWithTransformComponent
{
public:
	struct FSDFCylinderProperties                 Properties;                                        // 0x0200(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2818[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFCylinderComponent">();
	}
	static class USDFCylinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFCylinderComponent>();
	}
};
static_assert(alignof(USDFCylinderComponent) == 0x000010, "Wrong alignment on USDFCylinderComponent");
static_assert(sizeof(USDFCylinderComponent) == 0x000210, "Wrong size on USDFCylinderComponent");
static_assert(offsetof(USDFCylinderComponent, Properties) == 0x000200, "Member 'USDFCylinderComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFCapsule
// 0x0010 (0x0140 - 0x0130)
class USDFCapsule final : public USDFBaseWithTransform
{
public:
	struct FSDFCapsuleProperties                  Properties;                                        // 0x0130(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2819[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFCapsule">();
	}
	static class USDFCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFCapsule>();
	}
};
static_assert(alignof(USDFCapsule) == 0x000010, "Wrong alignment on USDFCapsule");
static_assert(sizeof(USDFCapsule) == 0x000140, "Wrong size on USDFCapsule");
static_assert(offsetof(USDFCapsule, Properties) == 0x000130, "Member 'USDFCapsule::Properties' has a wrong offset!");

// Class FSDEngine.SDFCapsuleComponent
// 0x0010 (0x0210 - 0x0200)
class USDFCapsuleComponent final : public USDFBaseWithTransformComponent
{
public:
	struct FSDFCapsuleProperties                  Properties;                                        // 0x0200(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_281A[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFCapsuleComponent">();
	}
	static class USDFCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFCapsuleComponent>();
	}
};
static_assert(alignof(USDFCapsuleComponent) == 0x000010, "Wrong alignment on USDFCapsuleComponent");
static_assert(sizeof(USDFCapsuleComponent) == 0x000210, "Wrong size on USDFCapsuleComponent");
static_assert(offsetof(USDFCapsuleComponent, Properties) == 0x000200, "Member 'USDFCapsuleComponent::Properties' has a wrong offset!");

// Class FSDEngine.SDFTorus
// 0x0010 (0x0140 - 0x0130)
class USDFTorus final : public USDFBaseWithTransform
{
public:
	struct FSDFTorusProperties                    Properties;                                        // 0x0130(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFTorus">();
	}
	static class USDFTorus* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFTorus>();
	}
};
static_assert(alignof(USDFTorus) == 0x000010, "Wrong alignment on USDFTorus");
static_assert(sizeof(USDFTorus) == 0x000140, "Wrong size on USDFTorus");
static_assert(offsetof(USDFTorus, Properties) == 0x000130, "Member 'USDFTorus::Properties' has a wrong offset!");

// Class FSDEngine.SDFTorusComponent
// 0x0010 (0x0210 - 0x0200)
class USDFTorusComponent final : public USDFBaseWithTransformComponent
{
public:
	struct FSDFTorusProperties                    Properties;                                        // 0x0200(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SDFTorusComponent">();
	}
	static class USDFTorusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USDFTorusComponent>();
	}
};
static_assert(alignof(USDFTorusComponent) == 0x000010, "Wrong alignment on USDFTorusComponent");
static_assert(sizeof(USDFTorusComponent) == 0x000210, "Wrong size on USDFTorusComponent");
static_assert(offsetof(USDFTorusComponent, Properties) == 0x000200, "Member 'USDFTorusComponent::Properties' has a wrong offset!");

// Class FSDEngine.StaticMeshCarver
// 0x0088 (0x00B8 - 0x0030)
class UStaticMeshCarver final : public UDataAsset
{
public:
	class FString                                 Status;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   AABB;                                              // 0x0068(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_281B[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeepCSGFloatTree                      BSPTree;                                           // 0x0088(0x0018)(NativeAccessSpecifierPublic)
	struct FDeepCSGFloatTreePacked                BSPTreePacked;                                     // 0x00A0(0x0018)(NativeAccessSpecifierPublic)

public:
	void ExportPreviewMesh();
	void Generate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshCarver">();
	}
	static class UStaticMeshCarver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMeshCarver>();
	}
};
static_assert(alignof(UStaticMeshCarver) == 0x000008, "Wrong alignment on UStaticMeshCarver");
static_assert(sizeof(UStaticMeshCarver) == 0x0000B8, "Wrong size on UStaticMeshCarver");
static_assert(offsetof(UStaticMeshCarver, Status) == 0x000030, "Member 'UStaticMeshCarver::Status' has a wrong offset!");
static_assert(offsetof(UStaticMeshCarver, Mesh) == 0x000040, "Member 'UStaticMeshCarver::Mesh' has a wrong offset!");
static_assert(offsetof(UStaticMeshCarver, AABB) == 0x000068, "Member 'UStaticMeshCarver::AABB' has a wrong offset!");
static_assert(offsetof(UStaticMeshCarver, BSPTree) == 0x000088, "Member 'UStaticMeshCarver::BSPTree' has a wrong offset!");
static_assert(offsetof(UStaticMeshCarver, BSPTreePacked) == 0x0000A0, "Member 'UStaticMeshCarver::BSPTreePacked' has a wrong offset!");

}

